From 87e7a17faad4291e7155fefef933f068deed5cdf Mon Sep 17 00:00:00 2001
From: Nick Bofferding <bofferdn@us.ibm.com>
Date: Tue, 13 Sep 2016 00:16:28 -0500
Subject: [PATCH 2/3] Support signing utility wrapper script

---
 scripts/crtSignedContainer.pl | 1622 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 1622 insertions(+)
 create mode 100755 scripts/crtSignedContainer.pl

diff --git a/scripts/crtSignedContainer.pl b/scripts/crtSignedContainer.pl
new file mode 100755
index 0000000..ffd28e4
--- /dev/null
+++ b/scripts/crtSignedContainer.pl
@@ -0,0 +1,1622 @@
+#!/usr/bin/perl
+# IBM_PROLOG_BEGIN_TAG
+# This is an automatically generated prolog.
+#
+# $Source: scripts/crtSignedContainer.pl $
+#
+# OpenPOWER sb-signing-utils Project
+#
+# Contributors Listed Below - COPYRIGHT 2016
+# [+] International Business Machines Corp.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+# implied. See the License for the specific language governing
+# permissions and limitations under the License.
+#
+# IBM_PROLOG_END_TAG
+#
+#
+#############################################################
+#
+# This script supports development mode only at this point.
+#
+# It will allow the caller to either
+# - create a valid FW key pair via openssl (in
+#    development mode)
+#
+# OR
+#  - create a signed container
+#
+# TODO (for production mode):
+# - update to tie into SignAgent interface since HW & FW
+#   private keys will reside in HSM
+#
+#############################################################
+
+use strict;
+use Carp;
+use Cwd;
+use Pod::Usage;
+use IO::File;
+use POSIX qw(strftime);
+use File::Basename;
+use File::Temp;
+use Getopt::Long qw(GetOptions);
+
+### TODO - make sure lines are <= 80 chars
+
+############
+#
+# Constants
+#
+############
+# Algorithm to use when calculating the digest value for the
+# binary to be signed
+#
+my $HASH_ALG = "sha512sum";
+
+use constant hexBytesPerHash      => 64;
+use constant asciiCharPerHexByte  => 2;
+use constant expectedHexPubKeyLen => 132;
+use constant hexBytesPerSignature => 132;
+
+
+############
+#
+# Variables
+#
+############
+
+# This temporary directory is used to store the
+# signatures that are generated,etc during this
+# processing. It should be cleaned up at the end.
+my $g_tmpdir = "";
+
+# global vars
+my @g_tmpFiles              = ();
+
+my %g_var; ### = {};
+$g_var{signing_mode}      = "development"; # or 'production'
+
+# being called only to create a key pair
+$g_var{createAkeyPair}    = 0;
+$g_var{createContainer}   = 1;   # create the container on each call
+$g_var{verbose}           = 0;
+
+my $g_pathPrefix          = "";
+my $g_ldLibPathPrefix     = "";
+
+# By default, the protected payload (and unprotected
+# payload, if specified) is attached to the end of
+# container object.
+$g_var{attachPayloads} = 1;
+
+# path to the sign tool/utility to call
+# (used to validate that the Linux
+# OS-supplied binary in /usr/bin is not
+# at the top of the caller's $PATH)
+$g_var{signutility} = `which signtool`;
+chomp($g_var{signutility});
+
+# The hardware keys are used to sign a digest of a
+# structure containing the digest of the FW public keys.
+# The signatures are stored in these binaries.
+my ($g_hwsignA, $g_hwsignB, $g_hwsignC) = "";
+
+my ($g_HWpubKeyA, $g_HWpubKeyB, $g_HWpubKeyC) = "";
+
+# These are the FW public keys that are stored
+# as a protected payload in the prefix key header.
+my ($g_SWpubKeyP, $g_SWpubKeyQ, $g_SWpubKeyR) = "";
+
+# Signatures that were generated associated with the FW
+# public keys
+my ($g_SWsignP, $g_SWsignQ, $g_SWsignR) = "";
+
+my $g_cfgHelp = 0;
+my $g_cfgMan  = 0;
+
+# global temp vars
+my $g_CMD      = "";
+my $g_cmdParms = "";
+my $g_rc       = 0;
+my @g_cmdOut   = ();
+
+####
+
+GetOptions (
+  'createKey:s'    => \$g_var{createKeyPair},
+  'privKeyPath:s'  => \$g_var{newPrivKeyPath},
+  'pubKeyPath:s'   => \$g_var{newPubKeyPath},
+
+
+  'protectedPayload:s'   => \$g_var{protected_payload},
+  'unprotectedPayload:s' => \$g_var{unprotected_payload},
+  'out:s'                => \$g_var{signed_container_name},
+
+  'hwPrivKeyA:s'         => \$g_var{HWprivKeyA},
+  'hwPrivKeyB:s'         => \$g_var{HWprivKeyB},
+  'hwPrivKeyC:s'         => \$g_var{HWprivKeyC},
+
+  'swPrivKeyP:s'         => \$g_var{SWprivKeyP},
+  'swPrivKeyQ:s'         => \$g_var{SWprivKeyQ},
+  'swPrivKeyR:s'         => \$g_var{SWprivKeyR},
+
+  'mode:s'               => \$g_var{signing_mode},
+
+  'flags-fw-key-ind:s'  => \$g_var{flags_fw_key_ind},
+  'code-start-offset:s' => \$g_var{code_start_offset},
+  'cont-size:s'         => \$g_var{input_final_cont_size},
+  'target-HRMOR:s'      => \$g_var{target_HRMOR},
+  'inst-start:s'        => \$g_var{inst_start},
+
+  'tempdir:s'           => \$g_var{inputTempDir},
+
+  'update'              => sub { $g_var{createContainer} = 0},
+  'noattach'            => sub { $g_var{attachPayloads} = 0},
+
+  'paramFile:s'         => \$g_var{paramFile},
+
+  'help'                => \$g_cfgHelp,
+  'man'                 => \$g_cfgMan,
+  'verbose'             => \$g_var{verbose} ) || pod2usage(-verbose => 0);
+
+pod2usage(-verbose => 1) if $g_cfgHelp;
+pod2usage(-verbose => 2) if $g_cfgMan;
+
+# pull out the parent dir for use in processing later
+if ($g_var{signed_container_name} =~ /\//) {
+   $g_var{signed_container_dir} = File::Basename::dirname($g_var{signed_container_name});
+} else {
+    $g_var{signed_container_dir} = cwd();
+}
+# for our intermediate files, put them in a space
+# the caller defines
+if ($g_var{inputTempDir}) {
+    $g_tmpdir = $g_var{inputTempDir};
+} else {
+   # get a temp dir, mark it for clean up upon exit
+   $g_tmpdir = File::Temp::tempdir(CLEANUP => 1);
+}
+
+# be nice and create the 'to' dir for the caller if it
+# doesn't exist
+if (!(-e "$g_var{signed_container_dir}")) {
+   print "$g_var{signed_container_dir} does not exist - creating it for you\n" if $g_var{verbose};
+   system("mkdir -p $g_var{signed_container_dir}");
+   if ($?) {
+      die "Unable to create $g_var{signed_container_dir}\n";
+   }
+}
+
+############################################################
+
+
+########################
+#
+#  (Optionally) load parameters from the input
+#    parameter file.
+#
+#  Verify all the parameters.
+#
+########################
+
+if ($g_var{paramFile}) {
+    # if parameter file specified, load its parameters first
+    parseParmFile(parmfile   => $g_var{paramFile},
+                  splitchars => "~~");
+
+    if ($g_pathPrefix) {
+        print "Updating the PATH to contain: $g_pathPrefix\n" if $g_var{verbose};
+        $ENV{PATH} = $g_pathPrefix . ":" . $ENV{PATH};
+        $g_var{signutility}              = `which signtool`;
+        chomp($g_var{signutility});
+    }
+    if ($g_ldLibPathPrefix) {
+        print "Updating the LD_LIBRARY_PATH to contain: $g_ldLibPathPrefix\n" if $g_var{verbose};
+        $ENV{LD_LIBRARY_PATH} = $g_ldLibPathPrefix . ":" . $ENV{LD_LIBRARY_PATH};
+    }
+}
+
+verifyParms();
+
+
+#######################
+#
+#  Environment set up
+#
+#######################
+
+# debug info - make sure we are running the right signing utility
+print "signtool = $g_var{signutility}\n" if $g_var{verbose};
+if ($g_var{signutility} =~ /^\/usr\/bin\/signtool/) {
+    print "Current path = $ENV{PATH}\n";
+    die "You are not set up to run the proper signtool binary - $g_var{signutility}\n";
+}
+
+
+#######################
+#
+#    Mainline
+#
+#######################
+
+# Called to create a private/public key pair using the
+# ECDSA 512 algorithm
+if ($g_var{createAkeyPair}) {
+
+    if ($g_var{verbose}) {
+      print "\n#############################################\n";
+      print "### --------  Key Pair Creation  -------- ###\n";
+    }
+    if ($g_var{newPrivKeyPath}) {
+    # caller requested a specific path to contain the new key pair
+        my ($rc, $msg) = createKeyPair(
+                       privKeyPath => $g_var{newPrivKeyPath},
+                       pubKeyPath  => $g_var{newPubKeyPath},
+                       verbose     => 1);
+        if ($g_rc> 0) {
+            die "$msg";
+        } elsif ($g_var{verbose}) {
+            print "New key pairs have been created as:\n $g_var{newPrivKeyPath} \n$g_var{newPubKeyPath}\n";
+        }
+        exit 0;
+    }
+}
+
+# The public keys all are added to the signed container
+# header(s), so do this one call to extract them from
+# the private key files that the caller passed in
+# (this step applicable to development mode only)
+extractPubKeysFromPriv(
+            mode   => $g_var{signing_mode},
+            hwkeya => $g_var{HWprivKeyA},
+            hwkeyb => $g_var{HWprivKeyB},
+            hwkeyc => $g_var{HWprivKeyC},
+            swkeyp => $g_var{SWprivKeyP},
+            swkeyq => $g_var{SWprivKeyQ},
+            swkeyr => $g_var{SWprivKeyR}
+            );
+
+# Concatenate the FW keys into one blob so their size
+# and hash can be calculated
+if ($g_var{verbose}) {
+    print "\n##########################################################################\n";
+    print "### --------  Concat FW keys, get size and hash of that blob  -------- ###\n";
+}
+my ($psrc, $hdrPayloadSize, $hdrPayloadHash, $hdrHashLen) = prepFWkeyBlob();
+if ($psrc > 0) {
+    die "prepFWkeyBlob failed.  FW keys were not processed successfully.";
+}
+if ($g_var{verbose}) {
+    print "*************************** Calculated FW key info:\n";
+    print "FW key hash size  : $hdrPayloadSize\n";
+    print "FW key hash       : $hdrPayloadHash\n";
+    print "FW key(s) hash len: $hdrHashLen\n";
+}
+
+#########
+#
+# Create an EC 521 Curve Keypair :
+#   <sign utility> --mode development --create_key --privkeyfile ecpriv.pem --pubkeyfile ecpub.pem
+#
+# Sign a sha-512 digest using openssl keys created above
+# echo "this is a test message" > /tmp/message.txt
+# SHA512_SUM=`sha512sum /tmp/message.txt | awk '{print $1}'`
+# <sign utility> --mode development --sign --projname ecpriv.pem --sigfile message.sig --digest $SHA512_SUM
+#
+# Verify a sha-512 digest signed by openssl keys
+# echo "this is a test message" > /tmp/message.txt
+# SHA512_SUM=`sha512sum /tmp/message.txt | awk '{print $1}'`
+# <sign utility> --mode development --verify --pubkeyfile ecpub.pem --sigfile message.sig --digest $SHA512_SUM
+#
+##########
+
+if ($g_var{createContainer}) {
+    if ($g_var{verbose}) {
+        print "\n###############################################\n";
+        print "### ---- Create the basic container header ----- ####\n";
+
+        print "\n\nCall the tool to create the prefix header structure for a signed container (which includes some defaults and signature placeholders)\n";
+    }
+    $g_cmdParms = "--create-container";
+    updCont($g_cmdParms);
+
+    if ($g_var{verbose}) {
+        print "\nNewly-created (mostly-empty signed container, with just a few default values set in it) can be found in:\n";
+        print "$g_var{signed_container_name}\n";
+    }
+} else {
+    if ($g_var{verbose}) {
+        print "Skip creation of the container.\n";
+    }
+}
+
+if ($g_var{verbose}) {
+    print "\n###########################################################\n";
+    print "### ----  Start updating fields in the container ----- ####\n";
+
+    print "\nNow updating some of the base fields in the container\n";
+}
+
+######################
+#
+# Fields at the top of the hardware header
+
+if ($g_var{target_HRMOR}) {
+  if ($g_var{verbose}) {
+      print "Now update the target HRMOR in the container\n";
+  }
+  $g_cmdParms = "--fldname target-hrmor --fldvalue $g_var{target_HRMOR}";
+  updCont($g_cmdParms);
+}
+
+if ($g_var{inst_start}) {
+  if ($g_var{verbose}) {
+      print "Now update the instruction start stack pointer address in the container\n";
+  }
+  $g_cmdParms = "--fldname stack-pointer --fldvalue $g_var{inst_start}";
+  updCont($g_cmdParms);
+}
+
+#########################
+#
+# Make sure the hardware prefix header fields are filled in
+
+if ($g_var{flags_fw_key_ind}) {
+  if ($g_var{verbose}) {
+      print "Now update the firmware key indicator flags in the container\n";
+  }
+  $g_cmdParms = "--fldname hdr-flags --fldvalue $g_var{flags_fw_key_ind} ";
+  updCont($g_cmdParms);
+}
+
+if ($g_var{verbose}) {
+    print "Now update the prefix key header's protected payload size in the container\n";
+}
+# header's protected payload size must be the hex represenation of:
+#  # bytes * number of FW public keys
+my $verifySize = expectedHexPubKeyLen * $g_var{in_swKeyCount};
+my $hexSize = convertValueToHexStr($verifySize);
+if ($hexSize != $hdrPayloadSize) {
+    die "ERROR: Expected size for the 'header payload size'is $hexSize (decimal size, $verifySize). Actual size is $hdrPayloadSize. ";
+}
+$g_cmdParms = "--fldname hdr-payload-size --fldvalue $hdrPayloadSize";
+updCont($g_cmdParms);
+
+my $verifyHashLen   = length($hdrPayloadHash);
+my $hashShouldBeLen = hexBytesPerHash * asciiCharPerHexByte;
+if ($verifyHashLen != $hashShouldBeLen) {
+    die "ERROR: The length of the header payload hash' should be $hashShouldBeLen. Actual value is $verifyHashLen";
+}
+
+print "\n*****  Update the 'hash of protected payload' value in the prefix key header\n" if $g_var{verbose};
+$g_cmdParms = "--fldname hdr-payload-hash --fldvalue $hdrPayloadHash ";
+updCont($g_cmdParms);
+
+# Update the FW public keys into the container
+#   (Need to do this here so the FW public key count is valid in the
+#  hardware header before the payload is hashed and signed)
+my ($swrc, $swdet) = SWkeys();
+if ($swrc > 0) {
+    die "ERROR: Failed to update the FW public keys into the container: $swdet\n";
+}
+
+###############
+#
+# call <sign utility> to compute a signature over the digest
+# of the hardware prefix header (digest excludes HW signatures
+# and FW public keys)
+#
+# Get the digest of the hardware prefix header (digest excludes
+# HW signatures and FW public keys)
+$g_CMD = "$g_var{signutility} --imagefile $g_var{signed_container_name} --calchash --fldtype prefix_hdr";
+my $hwPrefixHdrDigest = `$g_CMD`;
+if ($? > 0) {
+    die "ERROR: Failed to get the digest of the hardware prefix header.\n";
+}
+chomp($hwPrefixHdrDigest);
+print "Hardware prefix header digest: $hwPrefixHdrDigest\n" if $g_var{verbose};
+
+#
+# Sign that digest using each of the hardware private keys to
+# get the hdw signatures
+my $skrc = signPrefixKeyHeaderDigest(digestToSign => $hwPrefixHdrDigest);
+if ($skrc > 0) {
+    die "ERROR: Failed to calculate the signature of the hardware prefix key header digest";
+}
+
+# Update the hardware keys and signatures into the
+# container
+HWkeyInfo();
+
+
+###############
+#
+#   Software header
+#
+
+# Calculate the size of the binary that we are to sign and
+# get the associated hash value.
+if ($g_var{verbose}) {
+  print "\n#################################################################\n";
+  print "### ------  Calc size and hash of protected payload ------ ###\n";
+}
+my ($pshrc, $sfwPayloadSize, $sfwPayloadHash, $sfwHashLen) = getSizeAndHash($g_var{protected_payload});
+if ($pshrc > 0) {
+    die "ERROR: getSizeAndHash failed while processing $g_var{protected_payload}";
+}
+if ($g_var{verbose}) {
+    print "Binary size : $sfwPayloadSize\n";
+    print "Binary hash : $sfwPayloadHash\n";
+    print "hash len    : $sfwHashLen\n";
+}
+
+# code start offset is specified as "x(hex value)"
+if ($g_var{code_start_offset}) {
+   # normalize values back to decimal (since the
+   # caller can pass in '0xZZZ' or 'ZZZ') to allow
+   # for an easier comparison
+   my $dec_code_start = hex($g_var{code_start_offset});
+   my $dec_payloadlen = hex($sfwPayloadSize);
+   if ($dec_code_start >= $dec_payloadlen) {
+     die "ERROR: code-start-offset, $g_var{code_start_offset}, appears to be outside the bounds of the protected payload, $g_var{protected_payload}; size of which (in hex) is $sfwPayloadSize\n";
+   }
+  if ($g_var{verbose}) {
+      print "Now update the code start offset in the container\n";
+  }
+  $g_cmdParms = "--fldname sw-code-start-offset --fldvalue $g_var{code_start_offset}";
+  updCont($g_cmdParms);
+}
+
+# Update the size of the software payload (the size of the
+# binary the caller asked us to sign)
+$g_cmdParms = "--fldname sw-payload-size --fldvalue $sfwPayloadSize";
+updCont($g_cmdParms);
+
+# Add the protected payload hash to the container
+print  "\nAdd the protected payload hash to the container\n" if $g_var{verbose};
+$g_cmdParms = "--fldname sw-payload-hash --fldvalue $sfwPayloadHash";
+updCont($g_cmdParms);
+
+###############
+#
+# call <sign utility> to get a signature over the digest
+#  of the software header (excluding software signatures
+#  and padding)
+#
+
+$g_CMD = "$g_var{signutility} --imagefile $g_var{signed_container_name} --calchash --fldtype software_hdr";
+my $sfwHeaderDigest = `$g_CMD`;
+if ($? > 0) {
+   die "ERROR: Failure encountered creating the software header digest";
+}
+chomp($sfwHeaderDigest);
+print "Software header digest:  $sfwHeaderDigest\n" if $g_var{verbose};
+
+# Sign the software header digest
+my $snrc = signSoftwareHeaderDigest(hashToSign => $sfwHeaderDigest);
+if ($snrc > 0) {
+    die "ERROR: signSoftwareHeaderDigest failed";
+}
+
+
+#########
+#
+# Finish up by updating the FW signatures, and
+# (optionally) attaching the protected and
+# unprotected payloads.
+
+# Update the software signatures into the container
+SWsigns();
+
+# Attach the binary that we just created a signature for
+# to make a temporary object so we can get what will be
+# the size of the final container object.
+my $tmpFinalContainer = "";
+my $prc = 0;
+my $containerSize = 0;
+my $containerHash = "";
+my $contHashLen   = 0;
+if ($g_var{attachPayloads}) {
+    $tmpFinalContainer = $g_var{signed_container_name} . "_temp";
+    attachBinaryToContainer(finalContainer => $g_var{signed_container_name},
+                            protected      => $g_var{protected_payload},
+                            unprotected    => $g_var{unprotected_payload},
+                            outfile        => $tmpFinalContainer,
+                            createFinal    => 0);
+
+    print "\nCalculate the size of the interim final container\n" if $g_var{verbose};
+    ($prc, $containerSize, $containerHash, $contHashLen) = getSizeAndHash($tmpFinalContainer);
+    if ($prc > 0) {
+       die "ERROR: getSizeAndHash failed while processing $tmpFinalContainer";
+    }
+} else {
+    # get the size of the container (the header) alone
+    ($prc, $containerSize, $containerHash, $contHashLen) = getSizeAndHash($g_var{signed_container_name});
+    if ($prc > 0) {
+       die "ERROR: getSizeAndHash failed while processing $g_var{signed_container_name}";
+    }
+}
+
+# Have to calculate what the final size WOULD BE once the payload
+# (the binary to be signed) is attached, then update the header
+# with that size.
+#    THEN, attach the binary to the signed container later. Trying
+# to update the size in the container after that payload binary
+# is attached will remove the attached binary.
+if ($g_var{input_final_cont_size}) {
+  if ($g_var{verbose}) {
+      print "Total container size, $g_var{input_final_cont_size} was passed in. It will be updated into the header\n";
+  }
+  $g_cmdParms = "--fldname container-size --fldvalue $g_var{input_final_cont_size}";
+} else {
+  # go with the size that we calculated
+  $g_cmdParms = "--fldname container-size --fldvalue $containerSize";
+}
+updCont($g_cmdParms);
+
+if ($g_var{attachPayloads}) {
+    # NOW really attach the binary to the final header
+    attachBinaryToContainer(finalContainer => $g_var{signed_container_name},
+                            protected      => $g_var{protected_payload},
+                            unprotected    => $g_var{unprotected_payload},
+                            outfile        => $tmpFinalContainer,
+                            createFinal    => 1);
+}
+
+print "\n$g_var{signed_container_name} created/updated\n";
+my $timest = `stat -c %z $g_var{signed_container_name}`;
+print "Create time: $timest\n" if $g_var{verbose};
+
+
+exit 0;
+
+#############################################################
+#
+#  Subroutines
+#
+############################################################
+
+#
+# Verify the existence and relationships of the input parameters.
+#  This should do verification of only the things that the
+# signtool doesn't (and likely, shouldn't do), such as making
+# sure we have the right number of keys.
+#
+sub verifyParms {
+
+    if ($g_var{signing_mode} and
+        ( ($g_var{signing_mode} eq "development") or
+          ($g_var{signing_mode} eq "production")) ) {
+       # then ok
+    } else {
+        die "-mode must be 'production' or 'development'\n";
+    }
+
+    if (!(exists($g_var{createAkeyPair})) and
+        !(exists($g_var{protected_payload}))) {
+        die "You must specify either --protectedPayload OR the --createKey option to create a key pair";
+    } elsif ($g_var{createAkeyPair} and $g_var{protected_payload}) {
+        die "You may not specify both --protectedPayload and --createKey";
+    }
+    # Called only to create a key pair
+    if ($g_var{createAkeyPair}) {
+        if (!$g_var{newPrivKeyPath}) {
+            die "Path to private key file to be generated is required";
+        }
+        if (!$g_var{newPubKeyPath}) {
+            die "Path to public key file to be generated is required";
+        }
+    } else {
+        if (!(-e "$g_var{protected_payload}")) {
+            die "Protected payload, $g_var{protected_payload}, is not found";
+        }
+    }
+
+    if ($g_var{createContainer}) {
+    # 3 hardware private keys are required
+    if (!$g_var{HWprivKeyA}) {
+        die "Hardware private key A required\n";
+    } elsif  (!(-e $g_var{HWprivKeyA})) {
+        die "Hardware signing key A, $g_var{HWprivKeyA}, not found\n";
+    }
+    if (!$g_var{HWprivKeyB}) {
+        die "Hardware private key B required\n";
+    } elsif  (!(-e $g_var{HWprivKeyB})) {
+        die "Hardware signing key B, $g_var{HWprivKeyB}, not found\n";
+    }
+    if (!$g_var{HWprivKeyC}) {
+        die "Hardware private key C required\n";
+    } elsif  (!(-e $g_var{HWprivKeyC})) {
+        die "Hardware signing key C, $g_var{HWprivKeyC}, not found\n";
+    }
+    # 1 software private key is required
+    if (!$g_var{SWprivKeyP}) {
+        die "Software private key P required\n";
+    } elsif  (!(-e $g_var{SWprivKeyP})) {
+        die "Software signing key P,$g_var{SWprivKeyP}, not found\n";
+    } else {
+        $g_var{in_swKeyCount}++;
+    }
+
+    # Validate the existence of the optional keys, Q and R, if
+        # specified
+        if ($g_var{SWprivKeyQ}) {
+            $g_var{in_swKeyCount}++;
+        if (!(-e $g_var{SWprivKeyQ})) {
+          die "FW signing key Q,$g_var{SWprivKeyQ}, not found\n";
+        }
+    }
+
+    if ($g_var{SWprivKeyR}) {
+        $g_var{in_swKeyCount}++;
+        if (!(-e $g_var{SWprivKeyR})) {
+          die "FW signing key R,$g_var{SWprivKeyR}, not found\n";
+        }
+    }
+    }
+    if ($g_var{unprotected_payload}) {
+        if (!(-e "$g_var{unprotected_payload}")) {
+            die "$g_var{unprotected_payload} not found\n";
+        }
+    }
+
+    # outfile is required
+    if (!$g_var{signed_container_name}) {
+        die "Output file (-out) is required\n";
+    } elsif (!$g_var{createContainer}) {
+        if (!(-e "$g_var{signed_container_name}")) {
+            die "$g_var{signed_container_name} not found";
+        }
+    }
+}
+
+
+
+#
+# Call the sign utility to create a key pair
+sub createKeyPair {
+    my %data        = @_;
+    my $privKeyPath = $data{privKeyPath} || "";
+    my $pubKeyPath  = $data{pubKeyPath}  || "";
+
+    my $keyDir      = $data{keyDir}      || "";
+    my $newPrivKey  = $data{privKeyName} || "";
+    my $newPubKey   = $data{pubKeyName}  || "";
+    my $verbose     = $data{verbose}     || 0;
+
+    if (!$privKeyPath and !$keyDir) {
+        confess "createKeyPair: privKeyPath (full path) or keyDir,privKeyName (dir, file) are required";
+    }
+    if ($privKeyPath) {
+        $keyDir = dirname($privKeyPath);
+    } else {
+        $privKeyPath = $keyDir . "/$newPrivKey";
+        $pubKeyPath  = $keyDir . "/$newPubKey";
+    }
+
+    print "\n\nCalling $g_var{signutility} to create an EC 521 Curve Keypair.\n" if $verbose;
+    if (!(-e "$keyDir")) {
+        system("mkdir -p $keyDir");
+        if ($?) {
+            die "ERROR: createKeyPair unable to create directory, $keyDir";
+        }
+    }
+    $g_CMD = "$g_var{signutility} --mode $g_var{signing_mode} --create_key --privkeyfile $privKeyPath --pubkeyfile $pubKeyPath";
+    ($g_rc, @g_cmdOut) = runCmd($g_CMD);
+    if ($g_rc> 0) {
+        print "Returned: $g_rc, @g_cmdOut\n";
+        return 1, "ERROR: Unable to create a key pair\n";
+    }
+    if (!(-e "$privKeyPath")) {
+        return 1, "ERROR:$privKeyPath was not created";
+    }
+    if (!(-e "$pubKeyPath")) {
+        return 1, "ERROR:$privKeyPath was not created";
+    }
+    print "New private and public keys have been created now in $keyDir\n" if $verbose;
+    return 0, "";
+}
+#
+# Convert value to hexstring
+sub convertValueToHexStr {
+   my $invalue = shift;
+   return `printf "%x" $invalue`;
+}
+#
+# Validate that all chars in the string are
+# valid hex chars
+sub validHexCharStr {
+    my $inhexstr = shift;
+    if ($inhexstr =~ /^[\da-f]+\z/i) {
+        return 1;
+    } else {
+        return 0;
+    }
+}
+#
+# Calculate the size of the input binary, convert
+# value to hex.
+# Calculate sum value of the binary
+#
+sub getSizeAndHash {
+    my $binaryPathOrStr = shift;
+
+    # Get the size of the binary that was passed in (one of the
+    # values in the header is the 'payload' size)
+    #if (!(-e "$binaryPathOrStr")) {
+    #    die "getSizeAndHash:ERROR:$binaryPathOrStr not found\n";
+    #}
+    my $hexSize = 0;
+    my $tmpSize  = 0;
+
+    if (-e "$binaryPathOrStr") {
+      # if the value passed in is a file, then get the size
+      $tmpSize  = `stat -c %s $binaryPathOrStr`;
+      if ($? > 0) {
+        die "ERROR: getSizeAndHash failed on 'stat' of $binaryPathOrStr";
+      }
+    } else {
+       # it must be just a string
+       $tmpSize = length($binaryPathOrStr);
+    }
+    $hexSize = convertValueToHexStr($tmpSize);
+    # Get a hash of the binary
+    my $binHash = "";
+    if (-e "$binaryPathOrStr") {
+      $binHash = `$HASH_ALG $binaryPathOrStr | awk '{print $1}'`;
+      if ($? > 0) {
+        die "ERROR: getSizeAndHash failed attempting to run $HASH_ALG on $binaryPathOrStr";
+      }
+    } else {
+      # die until it is fixed - for next delivery
+      die "getSizeAndHash subr does not work for strings yet\n";
+
+      #print " if a string and not a file ($binaryPathOrStr not found)\n";
+      # my $str = "some string";
+      # -n = do not add newline to end of supplied string
+      my $binHash = `echo -n '$binaryPathOrStr' | $HASH_ALG -`;
+      chomp($binHash);
+      $binHash =~ s%  -%%;
+    }
+    my @tmpvals   = split(' ', $binHash);
+    my $hashValue = $tmpvals[0];
+    my $hashLen   = length($hashValue);
+    if ($g_var{verbose}) {
+      print "getSizeAndHash returning:\n Size:$hexSize\n Hash:'$hashValue'\nHash value length:$hashLen\n";
+    }
+    return 0, $hexSize, $hashValue, $hashLen;
+}
+
+#
+# Input to this is a hash of the binary to be signed, the key to
+# use to do the signing and an outfile that is to receive the
+# signature.
+sub generateSignature {
+    my %data           = @_;
+    my $digestToBeSigned = $data{digestToSign} || confess "digest required";
+    my $keyToUse         = $data{keyToUse}     || confess "key for signing the digest is required";
+    my $tmp_sig_file     = $data{sigfile}      || confess "sigfile required";
+    my $verbose          = $data{verbose}      || 0;
+
+    ### TODO (production mode): ... the name of the key to use ... how does this get handled dev vs prod. Prod needs name of a project with associated key, dev could point to any key and dev users would not have a notion of a project.
+    $g_var{projname_or_key} = "--projname $keyToUse";
+
+    # basic validation - valid hex chars in the string?
+    if (!(validHexCharStr($digestToBeSigned))) {
+        die "ERROR: generateSignature received a digest containing non-hex characters (digest: '$digestToBeSigned')";
+    }
+    # length what we expect?
+    my $actualLen = length($digestToBeSigned);
+    my $expectedDigestLength = hexBytesPerHash * asciiCharPerHexByte;
+    if ($actualLen != $expectedDigestLength) {
+        die "ERROR: generateSignature expected a digest length of $expectedDigestLength, actual length is $actualLen for $digestToBeSigned";
+    }
+    # Sign the hash (digest) passed in and save the signature
+    # value into the sigfile
+    print  "generateSignature: Signing the digest \n" if $verbose;
+    $g_CMD = "$g_var{signutility} --mode $g_var{signing_mode} --sign $g_var{projname_or_key} --sigfile $tmp_sig_file --digest $digestToBeSigned";
+    ($g_rc, @g_cmdOut) = runCmd($g_CMD);
+    if ($g_rc> 0) {
+        print "Returned: $g_rc, @g_cmdOut\n";
+        return $g_rc, "ERROR:Signing operation failed";
+    }
+    return $g_rc, "";
+}
+
+#
+# Accepts just the parms to build up and run the sign utility
+sub updCont {
+  my $parms   = shift;
+
+  my $utilCmd = "$g_var{signutility} --mode $g_var{signing_mode} --imagefile $g_var{signed_container_name} ";
+  $utilCmd .= $parms;
+  if ($g_var{verbose}) { print "$utilCmd\n"; }
+  system($utilCmd);
+  if ($?)  {
+    die ( "'$utilCmd' failed to execute: $!\n" );
+  } else {
+      print "\nCommand:\n$utilCmd\nCompletion : OK\n" if ($g_var{verbose});
+  }
+}
+
+# Runs a given command, capturing the output in an array as well
+# as displaying output of the command to stdout in real time
+# (as opposed to waiting until the program is finished running
+# and then dumping the output all at once).
+#
+sub runCmd
+{
+  my $l_cmd   = shift;
+  my $logfile = shift || "";
+
+  my $l_rc= 0;
+  my @output = ();
+
+  logit ( "Issuing - $l_cmd\n", 0, $logfile, 0, 1 ) if $g_var{verbose};
+  open ( CMD, "$l_cmd 2>&1 |" ) or die "$l_cmd failed to execute";
+  while ( <CMD> )  {
+    logit ( $_, 0, $logfile, 0, 0 );
+    push ( @output, $_ );
+  }
+  close ( CMD ) or CMD->autoflush() and die "$l_cmd failed";
+
+  if ( $? != 0 )  {
+    $l_rc = 1;
+    logit ( "'$l_cmd' failed to execute: $!\n" );
+  }
+  return $l_rc, @output;
+}
+
+# Prints the given message string, prepended with a date stamp,
+# to stdout and, if specified, to the given logfile. If in
+# testing mode, will only print to stdout, not to the logfile.
+sub logit
+{
+  my $message = shift;
+  my $noprint = shift || 0;
+  my $logfile = shift || "";
+  my $testing = shift || 0;
+  my $addtime = shift || 0;
+
+  # Apparently having a ' in the string to output will cause
+  # some errors to pop up so we need to convert the string to
+  # be shell literal
+  $message =~ s/'/'\\''/g;
+
+  my $curtime = getNowTime();
+  if ($addtime){
+    $message = "$curtime    $message";
+  }
+  print "$message\n"     if !$noprint;
+  if ($logfile && !$testing) {
+    `echo '$message' >> $logfile`;
+  }
+}
+
+#
+# Get the current date in a couple of specific formats
+sub getNowTime {
+   my $format = shift || "Ymd_HMS";
+
+   my $now = "";
+   if ($format eq "Ymd_HMS") {
+     $now = strftime "%Y%m%d_%H%M%S", localtime;
+   } elsif ($format eq "Y-m-d H:M:S") {
+     $now = strftime "%Y-%m-%d %H:%M:%S", localtime;
+   }
+   return $now;
+}
+
+#
+# The hash value here is calculated over the prefix key
+# header (excluding HW signatures and SW public keys) and
+# signed by the hardware private keys.
+sub signPrefixKeyHeaderDigest  {
+    my %data = @_;
+    my $digestToSign = $data{digestToSign} || confess "digest required";
+
+    my $rtrc = 0;
+    if ($g_var{verbose}) {
+      print "\n#######################################################\n";
+      print "### -------  Sign prefix key header   -------- ###\n\n";
+    }
+
+    print "digest to sign passed in: $digestToSign\n" if $g_var{verbose};
+
+    # Sign the digest over the prefix key header (excluding HW
+    # signatures and FW public keys) with the three hardware keys.
+    my $hwsignA_tmp = "$g_tmpdir/hwsignA.bin";
+    push(@g_tmpFiles, $hwsignA_tmp);
+
+    my $genRc = generateSignature(digestToSign => $digestToSign,
+                  keyToUse     => $g_var{HWprivKeyA},
+                  sigfile      => $hwsignA_tmp,
+                  verbose      => $g_var{verbose});
+    $rtrc += $genRc;
+    $g_hwsignA = $hwsignA_tmp;
+
+    my $hwsignB_tmp = "$g_tmpdir/hwsignB.bin";
+    $genRc = generateSignature(digestToSign => $digestToSign,
+                   keyToUse     => $g_var{HWprivKeyB},
+                   sigfile      => $hwsignB_tmp,
+                   verbose      => $g_var{verbose});
+    $rtrc += $genRc;
+    $g_hwsignB = $hwsignB_tmp;
+    push(@g_tmpFiles, $hwsignB_tmp);
+
+    my $hwsignC_tmp = "$g_tmpdir/hwsignC.bin";
+    $genRc = generateSignature(digestToSign => $digestToSign,
+                   keyToUse     => $g_var{HWprivKeyC},
+                   sigfile      => $hwsignC_tmp,
+                   verbose      => $g_var{verbose});
+    $rtrc += $genRc;
+    $g_hwsignC = $hwsignC_tmp;
+    push(@g_tmpFiles, $hwsignC_tmp);
+
+    return $rtrc;
+}
+
+
+#
+# The hash value for this routine is calculated over the
+# software header (excluding SW signatures).
+sub signSoftwareHeaderDigest {
+    my %data = @_;
+    my $binaryHash = $data{hashToSign} || confess "hash required";
+
+    if ($g_var{verbose}) {
+      print "\n#############################################\n";
+      print "### --- Sign the software header digest ---- ###\n\n";
+    }
+    # Sign the digest using each of the FW private
+    # keys (up to 3 keys may be specified)
+    my $SWsignP_tmp = "$g_tmpdir/swsignP.bin";
+
+    my $retrc = 0;
+    my $genRc = generateSignature(digestToSign => $binaryHash,
+                  keyToUse     => $g_var{SWprivKeyP},
+                  sigfile      => $SWsignP_tmp,
+                  verbose      => $g_var{verbose});
+    $retrc += $genRc;
+    $g_SWsignP = $SWsignP_tmp;
+    push(@g_tmpFiles, $SWsignP_tmp);
+
+    if ($g_var{SWprivKeyQ}) {
+        my $SWsignQ_tmp = "$g_tmpdir/swsignQ.bin";
+        $genRc = generateSignature(digestToSign => $binaryHash,
+                   keyToUse     => $g_var{SWprivKeyQ},
+                   sigfile      => $SWsignQ_tmp,
+                   verbose      => $g_var{verbose});
+        $retrc += $genRc;
+        $g_SWsignQ = $SWsignQ_tmp;
+        push(@g_tmpFiles, $SWsignQ_tmp);
+    }
+
+    if ($g_var{SWprivKeyR}) {
+        my $SWsignR_tmp = "$g_tmpdir/swsignR.bin";
+        $genRc = generateSignature(digestToSign => $binaryHash,
+                   keyToUse     => $g_var{SWprivKeyR},
+                   sigfile      => $SWsignR_tmp,
+                   verbose      => $g_var{verbose});
+        $retrc += $genRc;
+        $g_SWsignR = $SWsignR_tmp;
+        push(@g_tmpFiles, $SWsignR_tmp);
+    }
+    return $retrc;
+}
+
+
+# Update the hardware public keys and signatures into the
+# hardware header.
+sub HWkeyInfo {
+    if ($g_var{verbose}) {
+      print "\n#########################################################\n";
+      print "### --  Add hardware public key data to container  -- ###\n\n";
+    }
+
+    # Set up the hardware key and signature fields
+    print "Updating the hdw key A \n" if $g_var{verbose};
+    updCont("--fldname hw-keya --fldvalue $g_HWpubKeyA");
+
+    print "Updating the hdw key A signature\n" if $g_var{verbose};
+    updCont("--fldname hw-signa --fldvalue $g_hwsignA");
+
+    print "Updating the hdw key B \n" if $g_var{verbose};
+    updCont("--fldname hw-keyb --fldvalue $g_var{HWpubKeyB}");
+
+    print "Updating the hdw key B signature\n" if $g_var{verbose};
+    updCont("--fldname hw-signb --fldvalue $g_hwsignB");
+
+    print "Updating the hdw key C \n" if $g_var{verbose};
+    updCont("--fldname hw-keyc --fldvalue $g_var{HWpubKeyC}");
+
+    print "Updating the hdw key C signature\n" if $g_var{verbose};
+    updCont("--fldname hw-signc --fldvalue $g_hwsignC");
+
+    return;
+}
+#
+# Update the FW public keys in the container
+sub SWkeys {
+    if ($g_var{verbose}) {
+      print "\n#############################################################\n";
+      print "### -------  Add FW public key data to container  -------- ###\n\n";
+    }
+    my$sw_key_count = 0;
+
+    ## There should always be at least one FW public key - key P
+    print "Updating the FW key P \n" if $g_var{verbose};
+    updCont("--fldname sw-keyp --fldvalue $g_SWpubKeyP");
+    $sw_key_count = 1;
+
+    print "\n$g_var{signed_container_name} first set of fields updated\n" if $g_var{verbose};
+
+    # Now set up the optional fields (the 2nd and 3rd FW public keys)
+    print "\nUpdating the secondary FW public keys and signatures in the container\n" if $g_var{verbose};
+
+    if ($g_var{SWprivKeyQ}) {
+        print "Updating the FW key Q \n" if $g_var{verbose};
+        updCont("--fldname sw-keyq --fldvalue $g_SWpubKeyQ");
+        $sw_key_count++;
+    }
+    if ($g_var{SWprivKeyR}) {
+        print "Updating the FW key R \n" if $g_var{verbose};
+        updCont("--fldname sw-keyr --fldvalue $g_SWpubKeyR");
+        $sw_key_count++;
+    }
+    if ( ($sw_key_count < 1) or ($sw_key_count > 3) ) {
+        return 1, "ERROR: Count of FW public keys must be between 1-3\n";
+    }
+    return 0, "";
+}
+
+#
+# Update the FW signatures in the container
+sub SWsigns {
+    if ($g_var{verbose}) {
+      print "\n#############################################################\n";
+      print "### -------  Update FW signatures into container  -------- ###\n\n";
+    }
+    print "Updating the FW signature P signature\n" if $g_var{verbose};
+    updCont("--fldname sw-signp --fldvalue $g_SWsignP");
+
+    print "\n$g_var{signed_container_name} first set of fields updated\n" if $g_var{verbose};
+
+    # Now set up the optional fields (the 2nd and 3rd FW keys)
+    print "\nUpdating the secondary FW keys and signatures in the container\n" if $g_var{verbose};
+    if ($g_var{SWprivKeyQ}) {
+        print "Updating the FW signature Q data\n" if $g_var{verbose};
+        updCont("--fldname sw-signq --fldvalue $g_SWsignQ");
+    }
+    if ($g_var{SWprivKeyR}) {
+        print "Updating the FW signature R signature\n" if $g_var{verbose};
+        updCont("--fldname sw-signr --fldvalue $g_SWsignR");
+    }
+    return ;
+}
+
+#
+# Concatenate the SFW public keys into one binary blob,
+# get the hash and size and return to caller
+#
+sub prepFWkeyBlob {
+    #
+    #  In the prefix key header, there is a field for hash
+    # of protected payload - that is the digest
+    # generated over the concatenation of the sfw public
+    # keys.
+    my ($plrc, $sfwPubKeysSize, $sfwKeysHash, $sfwHashLen);
+
+    #### In development mode, manually pull out the
+    #### pub: key string from the public key extracted
+    #### from the private key, chop off the first byte,
+    #### dump the rest of the bits back to a file and
+    #### hash that file to get the hash of the sfw keys.
+    my $sprc     = 0;
+    my $tmpPkey = "";
+    # Start with P first, since there should always be
+    # the one key sfw key P
+    $tmpPkey = parseCharPubKeyToGetBinaryFileToHash(
+                 sfwPrivKey  => $g_var{SWprivKeyP} );
+
+    my $concatedKeyStr = $tmpPkey;
+
+    # else we are ok, set up a temp file name, just in case
+    # we have 2 more keys to process
+    my $concatedPubKeyFilesToHash = "$g_tmpdir/concatedSfwKeysToHash";
+    push(@g_tmpFiles, $concatedPubKeyFilesToHash);
+
+    my $tmpQkey = "";
+    if ($g_var{SWprivKeyQ}) {
+        $tmpQkey = parseCharPubKeyToGetBinaryFileToHash(
+                                sfwPrivKey  => $g_var{SWprivKeyQ} );
+        $concatedKeyStr .= $tmpQkey;
+    }
+    my $tmpRkey = "";
+    if ($g_var{SWprivKeyR}) {
+        $tmpRkey = parseCharPubKeyToGetBinaryFileToHash(
+                                sfwPrivKey  => $g_var{SWprivKeyR} );
+
+        $concatedKeyStr .= $tmpRkey;
+    }
+    open(TEMPFILE, ">$concatedPubKeyFilesToHash") or die "Could not open temp file to hold concatenated FW public keys";
+    print TEMPFILE "$concatedKeyStr";
+    close(TEMPFILE) || die "close failed for : $!";;
+    my $concatCmd = "echo $concatedKeyStr > $concatedPubKeyFilesToHash";
+    if ($g_var{verbose}) {
+       print "SFW keys concatenated into: $concatedPubKeyFilesToHash\n";
+    }
+
+    print "Getting hash of file, $concatedPubKeyFilesToHash\n" if $g_var{verbose};
+    ($plrc, $sfwPubKeysSize, $sfwKeysHash, $sfwHashLen) = getSizeAndHash($concatedPubKeyFilesToHash);
+
+    # this call fails - need to use the prior one until the subr
+    # can properly deal with a string vs file
+    # - leaving here for debug for next delivery
+    #print "Getting hash of string, '$concatedKeyStr'\n" if $g_var{verbose};
+    #($plrc, $sfwPubKeysSize, $sfwKeysHash, $sfwHashLen) = getSizeAndHash($concatedKeyStr);
+
+    print "prepFWkeyBlob: Returning sfw public key(s) size: $sfwPubKeysSize\n  hash: $sfwKeysHash\nhash len: $sfwHashLen\n" if $g_var{verbose};
+    return $plrc, $sfwPubKeysSize, $sfwKeysHash, $sfwHashLen;
+}
+
+# Given a FW private key:
+#   dump it as text to a file
+#   parse that text file, looking for the character representation
+#     of the public key (the strings x:y:z... follow 'pub:')
+#   lump all those xyz... values into one char string
+#   strip off the '04' at the start (to get 132 bytes)
+#   convert the resulting string to binary
+#   write it to a file
+#
+# There SHOULD be a better way to do this - via some
+# magic openssl command...but we need to make progress...
+# so need to revisit this once things are working...
+sub parseCharPubKeyToGetBinaryFileToHash {
+    my %data = @_;
+    my $sfwPrivKey = $data{sfwPrivKey}  || confess "FW private key file required";
+
+    my $l_cmd = "openssl ec -in $sfwPrivKey -text";
+    print "\n*** Dump the software private key $sfwPrivKey as text: $l_cmd\n" if $g_var{verbose};
+    my $keyText = `$l_cmd`;
+    if ($?) {
+        die "ERROR: parseCharPubKeyToGetBinaryFileToHash failed on the call to openssl";
+    }
+
+    # Define a second file where we can output the 'hashable'
+    #  public key.
+
+    # parse out the char key string that follows 'pub:' and
+    # dump it to the hashablepubkey var (this will be the
+    # format of the software public key that we need to
+    # hash (or concat and hash) and sign to come up with
+    # the magic signature that matches what the ROM code
+    # will validate against.
+    my $hashAblePubKey = parsePubKeyTextOut($keyText);
+    my $pubKeyLen = length($hashAblePubKey);
+    if ($pubKeyLen > expectedHexPubKeyLen) {
+       die "parseCharPubKeyToGetBinaryFileToHash: ERROR: public key length, $pubKeyLen, is longer than expected";
+    }
+
+    return $hashAblePubKey;
+}
+
+# The container header contains the hardware public keys
+# and software public keys. We need to get these public
+# keys from the private keys that were passed in (in
+# development mode, at least..)
+sub extractPubKey {
+   my %data = @_;
+   my $mode          = $data{mode}    || confess "production or development mode required";
+   my $privKeyFile   = $data{keyfile} || confess "key file required";
+   my $tmpPubKeyFile = $data{outfile} || confess "output file required";
+
+   my $cm = "";
+   if ($mode eq "development") {
+       #####$cm = "openssl rsa -in $privKeyFile -pubout > $tmpPubKeyFile";
+       # this returns something that can be sent to signtool to put into
+       # the container...but the output file is huge
+       $cm = "openssl ec -in $privKeyFile -pubout -out $tmpPubKeyFile";
+
+       my $openssl = `which openssl`;
+       chomp($openssl);
+       print "extractPubKey using $openssl\n" if $g_var{verbose};
+       system($cm);
+       if ($?) {
+         die "$openssl failed \n";
+       } elsif ($g_var{verbose}) {
+        print "public key extracted to $tmpPubKeyFile\n" if $g_var{verbose};
+       }
+   } else {
+       # we need to call the signtool to extract the public
+       # key
+   }
+   return ;
+}
+
+# One subroutine to do all the public key extraction
+# calls in one place
+sub extractPubKeysFromPriv {
+    my %data = @_;
+    my $mode = $data{mode}  || confess "mode is required";
+    my $hwA = $data{hwkeya} || confess "Hardware private key A required";
+    my $hwB = $data{hwkeyb} || confess "Hardware private key B required";
+    my $hwC = $data{hwkeyc} || confess "Hardware private key C required";
+
+    my $swP = $data{swkeyp} || confess "Software private key P required";
+    my $swQ = $data{swkeyq} || "";
+    my $swR = $data{swkeyr} || "";
+
+    # add all possible temp files created in this subr to our
+    # array to clean up
+    push(@g_tmpFiles, "$g_tmpdir/hwpubkeya");
+    push(@g_tmpFiles, "$g_tmpdir/hwpubkeyb");
+    push(@g_tmpFiles, "$g_tmpdir/hwpubkeyc");
+    push(@g_tmpFiles, "$g_tmpdir/swpubkeyp");
+    push(@g_tmpFiles, "$g_tmpdir/swpubkeyq");
+    push(@g_tmpFiles, "$g_tmpdir/swpubkeyr");
+
+    # In development mode, we can use openssl to extract the
+    # public key from the private.
+    extractPubKey(  mode    => $mode,
+                    keyfile => $hwA,
+                    outfile => "$g_tmpdir/hwpubkeya");
+    $g_HWpubKeyA = "$g_tmpdir/hwpubkeya";
+
+    extractPubKey(  mode    => $mode,
+                    keyfile => $hwB,
+                    outfile => "$g_tmpdir/hwpubkeyb");
+    $g_var{HWpubKeyB} = "$g_tmpdir/hwpubkeyb";
+
+    extractPubKey(  mode    => $mode,
+                    keyfile => $hwC,
+                    outfile => "$g_tmpdir/hwpubkeyc");
+    $g_var{HWpubKeyC} = "$g_tmpdir/hwpubkeyc";
+
+    extractPubKey(  mode    => $mode,
+                    keyfile => $swP,
+                    outfile => "$g_tmpdir/swpubkeyp");
+    $g_SWpubKeyP = "$g_tmpdir/swpubkeyp";
+
+    if ($g_var{SWprivKeyQ}) {
+        extractPubKey(  mode    => $mode,
+                        keyfile => $swQ,
+                        outfile => "$g_tmpdir/swpubkeyq");
+        $g_SWpubKeyQ = "$g_tmpdir/swpubkeyq";
+    }
+    if ($g_var{SWprivKeyR}) {
+        extractPubKey(  mode    => $mode,
+                        keyfile => $swR,
+                        outfile => "$g_tmpdir/swpubkeyr");
+                        $g_SWpubKeyR = "$g_tmpdir/swpubkeyr";
+    }
+    return ;
+}
+
+# To create a full signed container, the binary that we
+# just signed should be appended to the end of the headers.
+sub attachBinaryToContainer {
+    my %data = @_;
+    my $tmpFinalContainer = $data{outfile}        || confess "output file required";
+    my $protected_bin     = $data{protected}      || confess "protected binary required";
+    my $finalCont         = $data{finalContainer} || confess "final signed container path required";
+    my $unprotected       = $data{unprotected}    || "";
+    my $createFinal       = $data{createFinal}    || 0;
+
+    my ($prc, $containerSize, $containerHash) = getSizeAndHash($finalCont);
+    print "before attaching binary to the end of the container, the container size of $finalCont was $containerSize\n" if $g_var{verbose};
+
+    print "\nAttaching the protected payload, $protected_bin, (and if specified, the unprotected binary, $unprotected) to the end of the container to create a temp file, $tmpFinalContainer\n" if $g_var{verbose};
+    $g_CMD = "cat $finalCont $protected_bin > $tmpFinalContainer";
+    if ($unprotected) {
+       $g_CMD = "cat $finalCont $protected_bin $unprotected > $tmpFinalContainer";
+    }
+    system($g_CMD);
+    if ($?) {
+       die "$g_CMD failed";
+    }
+    if ($createFinal) {
+        print "\nNow copy the temp file ($tmpFinalContainer) to the final signed container name ($finalCont)\n" if $g_var{verbose};
+        $g_CMD = "cp $tmpFinalContainer $finalCont";
+        system($g_CMD);
+	if ($?) {
+          die "$g_CMD failed. Unable to construct the final container\n";
+        }
+    }
+}
+
+#
+# Pass in a parameter file, formatted as:
+#   varname(splitchars)value
+# as in:
+# HWprivKeyA~~<file path>
+#
+sub parseParmFile {
+  my %data = @_;
+  my $parmfile   = $data{parmfile}   || confess "parmfile required";
+  my $splitchars = $data{splitchars} || "~~";
+  my $verbose    = $data{verbose}    || 0;
+
+  open(PARMFILE, "$parmfile") || die "Unable to open parameter file,  $parmfile";
+  my @parmlines = <PARMFILE>;
+  close(PARMFILE) || die "close failed for : $!";
+  print "Found $#parmlines in $parmfile\n" if $verbose;
+
+  foreach my $line (@parmlines) {
+    if (($line !~ /$splitchars/) || ($line =~ /^#/)) { next; }
+    chomp($line);
+    my ($key, $value) = split($splitchars, $line);
+    if (!$value) { next; }
+    if (!$g_var{$key}) {
+       $g_var{$key} = $value;
+    }
+  }
+  return ;
+}
+
+sub parsePubKeyTextOut {
+   my $keyTextVar = shift;
+
+   my $foundPubLine = 0;
+   my @lines = split('\n', $keyTextVar);
+   my $fullstring = "";
+   print "parsePubKeyTextOut: parse the public key from the dump of the private, concat the strings we find to make one big string\n" if $g_var{verbose};
+   foreach my $l (@lines) {
+       chomp($l);
+       if (!$l) { next; }
+       if ($l =~ /pub:/) {
+            $foundPubLine = 1;
+            next;
+       } elsif ($l =~ /Field Type:/) {
+            last;
+       } elsif ($l =~ /ASN1/) {
+            last;
+
+       } elsif ($foundPubLine) {
+           # else we are reading the output of the key dump
+           # need to get the binary forms of each
+            $l =~ s%:%%g;
+            $l =~ s% %%g;
+            $fullstring .= $l;
+       }
+   }
+   # strip off the first 2 chars ('04')
+   my $len = length($fullstring) - 1;
+   $fullstring = substr($fullstring, 2, $len);
+   print "parsePubKeyTextOut: converting my new string with the first 04 string stripped off ($fullstring) to binary\n" if $g_var{verbose};
+   my $binaryPublicKey = pack ("H*",$fullstring);
+
+   return $binaryPublicKey;
+
+}
+
+sub valPubKeyLen {
+    my $inkeyfile = shift;
+    my $instring = `cat $inkeyfile`;
+    if ($?) {
+       die "Unable to read/process $inkeyfile";
+    }
+    $instring =~ s%-----BEGIN PUBLIC KEY-----%%;
+    $instring =~ s%-----END PUBLIC KEY-----%%;
+
+    my $expectedLen = asciiCharPerHexByte * expectedHexPubKeyLen;
+    my $actualLen = length($instring);
+    if ($actualLen != $expectedLen) {
+        die "ERROR: valPubKeyLen expected a key length of $expectedLen. Actual length is $actualLen";
+    }
+
+}
+
+
+__END__
+
+=head1 NAME
+
+crtSignedContainer.pl
+
+=head1 SYNOPSIS
+
+crtSignedContainer.pl [options]
+
+=head1 OPTIONS
+
+=over 8
+
+=item B<--help>
+
+Print a brief help message and exits.
+
+=item B<--man>
+
+Prints the manual page and exits.
+
+
+
+
+=item B<--createKey>
+
+Create a FW key pair (using openssl)
+
+=item B<--privKeyPath>
+
+Fully-qualified path to file to contain private key
+
+=item B<--pubKeyPath>
+
+Fully-qualified path to file to contain public key
+
+
+
+=item B<--protectedPayload>
+
+Binary blob to be signed
+
+
+=item B<--out>
+
+Path to signed container to be created
+
+=item B<--hwPrivKeyA>
+
+Hardware private key A (required)
+
+=item B<--hwPrivKeyB>
+
+Hardware private key B (required)
+
+=item B<--hwPrivKeyC>
+
+Hardware private key C (required)
+
+=item B<--swPrivKeyP>
+
+FW private key P (required)
+
+
+=item B<--update>
+
+Update the existing container
+
+=item B<--mode>
+
+development or production
+   (Only development mode supported initially)
+
+=item B<--paramFile>=FILE
+
+File containing a list of parameter values
+
+=item B<--swPrivKeyQ>
+
+Software private key Q
+
+=item B<--swPrivKeyR>
+
+Software private key R
+
+=item B<--flags_fw_key_ind>
+
+Flags (firmware key indicator - prefix key header)
+  hex, formatted like 0x00000000
+
+
+=item B<--code-start-offset>
+
+Code start offset (software header)
+  hex, formatted like 0x0000000000000000
+
+=item B<--cont-size>
+
+Total size of the container
+  hex, formatted like 0x0000000000000000
+
+=item B<--target-HRMOR>
+
+Target HRMOR
+  hex, formatted like 0x0000000000000000
+
+=item B<--inst-start>
+
+Instruction start stack pointer address
+  hex, formatted like 0x0000000000000000
+
+=item B<--unprotectedPayload>
+
+File containing the unprotected payload
+
+=item B<--noattach>
+
+Do NOT attach the -protectedPayload <binary>
+  (and optional -unprotectedPayload <binary>)
+  to the end of the signed container
+
+
+=item B<--tempdir>=DIRECTORY
+
+Temporary workspace used only when signing a
+  binary (files in this directory will not
+  be removed upon exit).
+
+
+=item B<--verbose>
+
+Prints out details of internal workings
+
+=back
+
+=head1 DESCRIPTION
+
+B<crtSignedContainer.pl> will allow the caller to do all
+of the following in just one call:
+
+- create a valid FW key pair via openssl
+
+ OR
+- create an empty container prefix header with defaults
+  filled in
+- get a hash of the binary to be signed for inclusion
+  in the appropriate prefix key or firmware header
+- concatenate the FW public key(s) and get a hash of
+  the resulting file
+- sign the hash of the prefix key header (which includes
+  the hash of the firmware (FW) public keys) using
+  each of the hardware private keys (to generate the
+  3 hardware signatures)
+- sign the hash of the protected payload (such as
+  hostboot.bin) using each of the 1-3 FW
+  private keys (to generate the 1-3 FW signatures)
+- update the hardware header with the hardware
+  public keys
+- update the prefix key header with the FW keys
+  and hardware signatures
+- update the software header with the FW signature(s)
+- attach the protected payload (if desired), producing
+  a signed container object
+- update other fields in the headers, such as final
+  container size, target HRMOR, code start offset,
+  etc
+- attach the unprotected payload (if provided)
+
+The sign 'utility' has parms for the field 'name' and
+the associated value to be inserted into the binary. So,
+for the multiple field/value combinations that must be
+updated into the final signed container, it must be
+called multiple times (once for each of the HW keys
+and associated signatures, once for each of the SFW
+keys and associated signatures, etc).
+
+As part of the container, there are headers that consist
+of 3 Hardware public Keys
+      * HW-KeyA - Hardware Public Key A
+      * HW-KeyB - Hardware Public Key B
+      * HW-KeyC - Hardware Public Key C
+3 corresponding Hardware Signatures
+      * HW-SigA - Hardware Signature A
+      * HW-SigB - Hardware Signature B
+      * HW-SigC - Hardware Signature C
+
+and 1 to 3 FW Keys (the number of keys used/required
+depends on the settings for each 'project')
+      * SW-KeyP - FW Public Key P
+      * SW-KeyQ - FW Public Key Q
+      * SW-KeyR - FW Public Key R
+and the associated Software Signatures
+      * SW-SigP - FW Signature P
+      * SW-SigQ - FW Signature Q
+      * SW-SigR - FW Signature R
+
+The protected payload (the actual signed binary
+'blob') is (optionally) appended to the container.
+Same is true for the unprotected payload.
+
+=cut
-- 
1.8.2.2

