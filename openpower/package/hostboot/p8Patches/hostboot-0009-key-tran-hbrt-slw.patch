From e0d838377aa98cec9daead323cf7185274bcc2e9 Mon Sep 17 00:00:00 2001
From: Jaymes Wilks <mjwilks@us.ibm.com>
Date: Tue, 6 Sep 2016 15:41:15 -0500
Subject: [PATCH 01/20] Secure PNOR Resource Provider SectionInfo Cleanup

Provides increased maintainability and minimized user code impacts
when loading and accessing secure sections.

RTC:156118
Change-Id: I3a73bb8e070e1845b5e9d52ac6cfc6a120e04dc3
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/28423
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Reviewed-by: Stephen M. Cprek <smcprek@us.ibm.com>
Reviewed-by: Nicholas E. Bofferding <bofferdn@us.ibm.com>
Reviewed-by: Daniel M. Crowell <dcrowell@us.ibm.com>
---
 src/include/usr/pnor/pnorif.H                | 14 ++++++
 src/usr/hwpf/hwp/load_payload/load_payload.C |  5 --
 src/usr/pnor/pnor_common.C                   | 42 ++++++++--------
 src/usr/pnor/pnorrp.C                        | 50 ++++++++++++-------
 src/usr/pnor/spnorrp.C                       | 74 ++++++++++++++++------------
 src/usr/sbe/sbe_update.C                     | 15 ------
 src/usr/targeting/attrrp.C                   |  6 ---
 src/usr/vfs/vfsrp.C                          | 18 +++----
 8 files changed, 115 insertions(+), 109 deletions(-)

diff --git a/src/include/usr/pnor/pnorif.H b/src/include/usr/pnor/pnorif.H
index bc1d0c8..c32b5ce 100644
--- a/src/include/usr/pnor/pnorif.H
+++ b/src/include/usr/pnor/pnorif.H
@@ -90,6 +90,11 @@ struct SectionInfo_t
     bool sha512perEC;   /**< Version Checking perEC */
     bool readOnly;      /**< Section is read only */
     bool reprovision;   /**< Erase this section during a reprovision */
+#ifdef CONFIG_SECUREBOOT
+    size_t secureProtectedPayloadSize; /**< Cache the secure payload size so
+                                              that the secure container only
+                                              needs to be parsed once */
+#endif
 };
 
 /**
@@ -182,6 +187,15 @@ errlHndl_t unloadSecureSection(SectionId i_section);
 #endif // CONFIG_SECUREBOOT
 
 /**
+ *  @brief Determines whether the given section is secured by secure boot
+ *
+ *  @param[in] i_section PNOR section to test.
+ *
+ *  @return bool True if secure section, false otherwise.
+ */
+bool isSecureSection(const uint32_t i_section);
+
+/**
  * @brief  Write the data back from hostboot memory to PNOR of a given section
  *         of PNOR
  *
diff --git a/src/usr/hwpf/hwp/load_payload/load_payload.C b/src/usr/hwpf/hwp/load_payload/load_payload.C
index b130d34..4b6c681 100644
--- a/src/usr/hwpf/hwp/load_payload/load_payload.C
+++ b/src/usr/hwpf/hwp/load_payload/load_payload.C
@@ -170,11 +170,6 @@ static errlHndl_t load_pnor_section(PNOR::SectionId i_section,
         return err;
     }
 
-    // @TODO RTC:156118 remove workaround with getSectionInfo cleanup.
-    #ifdef CONFIG_SECUREBOOT
-    pnorSectionInfo.vaddr += PAGE_SIZE;
-    #endif
-
     uint64_t l_vaddr = pnorSectionInfo.vaddr;
 
     // XZ repository: http://git.tukaani.org/xz.git
diff --git a/src/usr/pnor/pnor_common.C b/src/usr/pnor/pnor_common.C
index 4d6a15a..27a1ed4 100644
--- a/src/usr/pnor/pnor_common.C
+++ b/src/usr/pnor/pnor_common.C
@@ -453,23 +453,14 @@ errlHndl_t PNOR::parseTOC(uint8_t* i_toc0Buffer, uint8_t* i_toc1Buffer,
 
                     // @TODO RTC:153773 move header handling to secure pnor rp
                     // Don't skip header if verification is needed.
-                    bool isSecure = false;
-                    #ifdef CONFIG_SECUREBOOT
-                    isSecure = (secId == PNOR::HB_EXT_CODE) ||
-                               (secId == PNOR::HB_DATA) ||
-                               (secId == PNOR::SBE_IPL) ||
-                               (secId == PNOR::CENTAUR_SBE) ||
-                               (secId == PNOR::PAYLOAD);
-                    #endif
+                    bool isSecure = PNOR::isSecureSection(secId);
                     if (o_TOC[secId].version == FFS_VERS_SHA512 || isSecure)
                     {
                         uint32_t l_addr = o_TOC[secId].flashAddr;
 
                         size_t l_headerSize = 0;
-                    #ifdef CONFIG_SECUREBOOT
-                        if(!isSecure)
+                        if(!isSecure) // if not a secure section skip header
                         {
-                    #endif
                             TRACFCOMP(g_trac_pnor, "PNOR::parseTOC: Incrementing"
                                                 " Flash Address for SHA Header");
 
@@ -483,9 +474,11 @@ errlHndl_t PNOR::parseTOC(uint8_t* i_toc0Buffer, uint8_t* i_toc1Buffer,
                                 o_TOC[secId].flashAddr += PAGESIZE;
                                 l_headerSize = PAGESIZE;
                             }
-                    #ifdef CONFIG_SECUREBOOT
+
+                            // now that we've skipped the header
+                            // adjust the size to reflect that
+                            o_TOC[secId].size -= PAGESIZE;
                         }
-                    #endif
 
                         bool extend = true;
                         // If secureboot is compiled out, then we extend HBB
@@ -510,8 +503,6 @@ errlHndl_t PNOR::parseTOC(uint8_t* i_toc0Buffer, uint8_t* i_toc1Buffer,
                                 break;
                             }
                         }
-
-                        o_TOC[secId].size -= PAGESIZE;
                     }
 
                     if((o_TOC[secId].flashAddr + o_TOC[secId].size) >
@@ -573,15 +564,9 @@ errlHndl_t PNOR::parseTOC(uint8_t* i_toc0Buffer, uint8_t* i_toc1Buffer,
                     else
                     {
                         // Need to set permissions to R/W
-
-                        // TODO RTC: 156118 Remove the HBI size workaround
-                        size_t extra = 0;
-#ifdef CONFIG_SECUREBOOT
-                        extra = isSecure ? PAGESIZE : 0;
-#endif
                         int rc = mm_set_permission(
                                             (void*)o_TOC[secId].virtAddr,
-                                            o_TOC[secId].size + extra,
+                                            o_TOC[secId].size,
                                             WRITABLE | WRITE_TRACKED);
                         if (rc)
                         {
@@ -696,3 +681,16 @@ errlHndl_t PNOR::extendHash(uint64_t i_addr, size_t i_size, const char* i_name)
 
     return l_errhdl;
 }
+
+bool PNOR::isSecureSection(const uint32_t i_section)
+{
+#ifdef CONFIG_SECUREBOOT
+    return i_section == HB_EXT_CODE ||
+           i_section == HB_DATA ||
+           i_section == SBE_IPL ||
+           i_section == CENTAUR_SBE ||
+           i_section == PAYLOAD;
+#else
+    return false;
+#endif
+}
diff --git a/src/usr/pnor/pnorrp.C b/src/usr/pnor/pnorrp.C
index da77779..fb19c2b 100644
--- a/src/usr/pnor/pnorrp.C
+++ b/src/usr/pnor/pnorrp.C
@@ -51,6 +51,8 @@
 #include <console/consoleif.H>
 
 #ifdef CONFIG_SECUREBOOT
+#include <secureboot/service.H>
+#include <secureboot/containerheader.H>
 #include <secureboot/settings.H>
 #include <secureboot/header.H>
 #include <secureboot/trustedbootif.H>
@@ -519,21 +521,42 @@ errlHndl_t PnorRP::getSectionInfo( PNOR::SectionId i_section,
         o_info.name = cv_EYECATCHER[id];
 
 #ifdef CONFIG_SECUREBOOT
+        o_info.secureProtectedPayloadSize = 0; // for non secure sections
+                                               // the protected payload size
+                                               // defaults to zero
         // handle secure sections in SPnorRP's address space
-        if (o_info.id == HB_EXT_CODE ||
-            o_info.id == HB_DATA ||
-            o_info.id == SBE_IPL ||
-            o_info.id == CENTAUR_SBE ||
-            o_info.id == PAYLOAD)
+        if (PNOR::isSecureSection(o_info.id))
         {
+            uint8_t* l_vaddr = reinterpret_cast<uint8_t*>(iv_TOC[id].virtAddr);
             // By adding VMM_VADDR_SPNOR_DELTA twice we can translate a pnor
             // address into a secure pnor address, since pnor, temp, and spnor
             // spaces are equidistant.
             // See comments in SPnorRP::verifySections() method in spnorrp.C
             // and the definition of VMM_VADDR_SPNOR_DELTA in vmmconst.h
             // for specifics.
-            o_info.vaddr = iv_TOC[id].virtAddr + VMM_VADDR_SPNOR_DELTA
-                                               + VMM_VADDR_SPNOR_DELTA;
+            o_info.vaddr = reinterpret_cast<uint64_t>(l_vaddr)
+                                                       + VMM_VADDR_SPNOR_DELTA
+                                                       + VMM_VADDR_SPNOR_DELTA;
+
+            // Get size of the secured payload for the secure section
+            // Note: the payloadSize we get back is untrusted because
+            // we are parsing the header in pnor (non secure space).
+            SECUREBOOT::ContainerHeader l_conHdr(l_vaddr);
+            size_t payloadTextSize = l_conHdr.payloadTextSize();
+
+            assert(payloadTextSize > 0,"Non-zero payload text size expected.");
+
+            // skip secure header for secure sections at this point in time
+            o_info.vaddr += PAGESIZE;
+            // now that we've skipped the header we also need to adjust the
+            // size of the section to reflect that.
+            // Note: For unsecured sections, the header skip and size decrement
+            // was done previously in pnor_common.C
+            o_info.size -= PAGESIZE;
+
+            // cache the value in SectionInfo struct so that we can
+            // parse the container header less often
+            o_info.secureProtectedPayloadSize = payloadTextSize;
         }
         else
 #endif
@@ -1400,19 +1423,8 @@ errlHndl_t PnorRP::computeSection( uint64_t i_vaddr,
              id < PNOR::NUM_SECTIONS;
              id = (PNOR::SectionId) (id + 1) )
         {
-            // TODO RTC: 156118 Remove the HBI size workaround
-            size_t extra = 0;
-#ifdef CONFIG_SECUREBOOT
-            bool isSecure = (id == HB_EXT_CODE ||
-                             id == HB_DATA ||
-                             id == SBE_IPL ||
-                             id == CENTAUR_SBE ||
-                             id == PAYLOAD);
-            extra = (isSecure) ? PAGE_SIZE : 0;
-#endif
             if( (i_vaddr >= iv_TOC[id].virtAddr)
-                && (i_vaddr < (iv_TOC[id].virtAddr + iv_TOC[id].size
-                    + extra)) )
+                && (i_vaddr < (iv_TOC[id].virtAddr + iv_TOC[id].size)) )
             {
                 o_id = iv_TOC[id].id;
                 break;
diff --git a/src/usr/pnor/spnorrp.C b/src/usr/pnor/spnorrp.C
index 959de71..89a1ad4 100644
--- a/src/usr/pnor/spnorrp.C
+++ b/src/usr/pnor/spnorrp.C
@@ -276,6 +276,9 @@ void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
         TRACDCOMP(g_trac_pnor,"SPnorRP::verifySections getSectionInfo succeeded for sec = %s",
                   l_info.name);
 
+        l_info.vaddr -= PAGESIZE; // back up a page to expose the secure header
+        l_info.size += PAGESIZE; // add a page to size to account for the header
+
         // it's a coding error if l_info.vaddr is not in secure space
         assert(l_info.vaddr >= SBASE_VADDR);
 
@@ -291,36 +294,13 @@ void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
         // calcluate unsecured address from temp address
         uint8_t* l_unsecuredAddr = l_tempAddr - VMM_VADDR_SPNOR_DELTA;
 
-        // get size of text section (secured portion)
-        // Note: the textSize we get back is untrusted until verification
-        // completes and should not be treated as correct until then.
-        SECUREBOOT::ContainerHeader l_conHdr(l_unsecuredAddr);
-
-        assert(  l_conHdr.totalContainerSize() >= PAGESIZE +
-               + l_conHdr.payloadTextSize(),
-               "For section %s, total container size (%d) was less than header "
-               "size (4096) + payload text size (%d)",
-               l_info.name,
-               l_conHdr.totalContainerSize(),
-               l_conHdr.payloadTextSize());
-
-        assert(l_info.size + PAGESIZE >= l_conHdr.totalContainerSize(),
-               "For section %s, logical section size (%d) was less than total "
-               "container size (%d)",
-               l_info.name,
-               l_info.size + PAGESIZE,
-               l_conHdr.totalContainerSize());
-
-        o_rec->textSize = l_conHdr.payloadTextSize();
-
         TRACFCOMP(g_trac_pnor,"SPnorRP::verifySections section start address "
                     "in temp space is 0x%.16llX, "
                     "section start address in unsecured space is 0x%.16llX, "
                     "l_info.size = 0x%.16llX, "
-                    "payload size = 0x%.16llX, "
-                    "Total container size = 0x%.16llX",
-                    l_tempAddr,l_unsecuredAddr, l_info.size, o_rec->textSize,
-                    l_conHdr.totalContainerSize());
+                    "payload size = 0x%.16llX, ",
+                    l_tempAddr, l_unsecuredAddr, l_info.size,
+                    l_info.secureProtectedPayloadSize);
 
         TRACDBIN(g_trac_pnor,"SPnorRP::verifySections unsecured mem now: ",
                              l_unsecuredAddr, 128);
@@ -328,9 +308,30 @@ void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
         TRACDCOMP(g_trac_pnor,"SPnorRP::verifySections about to do memcpy");
 
         // copy from unsecured PNOR space to temp PNOR space
-        memcpy(l_tempAddr, l_unsecuredAddr, o_rec->textSize
+        memcpy(l_tempAddr, l_unsecuredAddr, l_info.secureProtectedPayloadSize
                                           + PAGESIZE); // plus header size
 
+        SECUREBOOT::ContainerHeader l_conHdr(l_tempAddr);
+        size_t l_totalContainerSize = l_conHdr.totalContainerSize();
+
+        TRACDCOMP(g_trac_pnor, "SPnorRP::verifySections "
+                "Total container size = 0x%.16llX", l_totalContainerSize);
+
+        assert(l_totalContainerSize >= PAGESIZE +
+               + l_info.secureProtectedPayloadSize,
+               "For section %s, total container size (%d) was less than header "
+               "size (4096) + payload text size (%d)",
+               l_info.name,
+               l_totalContainerSize,
+               l_info.secureProtectedPayloadSize);
+
+        assert(l_info.size >= l_totalContainerSize,
+               "For section %s, logical section size (%d) was less than total "
+               "container size (%d)",
+               l_info.name,
+               l_info.size,
+               l_totalContainerSize);
+
         TRACDCOMP(g_trac_pnor,"SPnorRP::verifySections did memcpy");
         TRACDBIN(g_trac_pnor,"SPnorRP::verifySections temp mem now: ",
                              l_tempAddr, 128);
@@ -345,7 +346,7 @@ void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
         if (SECUREBOOT::enabled())
         {
             l_errhdl = SECUREBOOT::verifyContainer(l_tempAddr,
-                                                 l_conHdr.totalContainerSize());
+                                                         l_totalContainerSize);
             if (l_errhdl)
             {
                 TRACFCOMP(g_trac_pnor, "< SPnorrRP::verifySections - section "
@@ -366,6 +367,14 @@ void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
 
         // verification succeeded
 
+        // parse container header now that it is verified
+        // store the payload text size in the section load record
+        // Note: the text size we get back is now trusted
+        o_rec->textSize = l_conHdr.payloadTextSize();
+        l_totalContainerSize = l_conHdr.totalContainerSize();
+
+        assert(o_rec->textSize == l_info.secureProtectedPayloadSize);
+
         // pcr extension of PNOR hash
         l_errhdl = TRUSTEDBOOT::extendPnorSectionHash(l_conHdr,
                                         (l_tempAddr + PAGESIZE),
@@ -376,14 +385,17 @@ void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
             break;
         }
 
+        // remove secure header page in temp space
+        mm_remove_pages(RELEASE, l_tempAddr, PAGESIZE);
+
         // keep track of info size in load record
-        o_rec->infoSize = l_conHdr.totalContainerSize() - PAGESIZE;
+        o_rec->infoSize = l_totalContainerSize - PAGESIZE;
 
         // skip the header to block secure header access
         uint8_t* l_securePayloadStart = o_rec->secAddr + PAGESIZE;
 
         // set permissions on the secured pages to writable
-        l_errhdl = setPermission(l_securePayloadStart - PAGESIZE,
+        l_errhdl = setPermission(o_rec->secAddr,
                                           o_rec->textSize + PAGESIZE, WRITABLE);
         // TODO RTC 156118 - change above two lines of code to below:
         //l_errhdl = setPermission(l_securePayloadStart, o_rec->textSize, WRITABLE);
@@ -396,7 +408,7 @@ void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
 
         // set permissions on the unsecured pages to write tracked so that any
         // unprotected payload pages with dirty writes can flow back to PNOR.
-        uint64_t unprotectedPayloadSize = l_conHdr.totalContainerSize()
+        uint64_t unprotectedPayloadSize = l_totalContainerSize
             - PAGESIZE - o_rec->textSize;
         if (unprotectedPayloadSize) // only write track a non-zero range
         {
diff --git a/src/usr/sbe/sbe_update.C b/src/usr/sbe/sbe_update.C
index 3284c89..9d7f9b0 100644
--- a/src/usr/sbe/sbe_update.C
+++ b/src/usr/sbe/sbe_update.C
@@ -586,21 +586,6 @@ namespace SBE
                        TARGETING::get_huid(i_target),
                        pnorSectionId, pnorInfo.vaddr);
 
-// @TODO RTC:156118 - Once Secure PNOR load/getSectionInfo is operational
-// we won't need to move past the secure header (size is 1 page/4K)
-#ifdef CONFIG_SECUREBOOT
-// Move pnorInfo pointer past secure header
-uint64_t tmp_vaddr = pnorInfo.vaddr;
-pnorInfo.vaddr += PAGESIZE;
-
-//debug info
-uint32_t tmp0=0, tmp1=0;
-memcpy(&tmp0, (void*)tmp_vaddr, sizeof(tmp0));
-memcpy(&tmp1, (void*)pnorInfo.vaddr, sizeof(tmp1));
-
-TRACFCOMP( g_trac_sbe, INFO_MRK"findSBEInPnor: Temporary Secureboot workaround: pnorInfo.vaddr was 0x%.16llX (0x%X) and now 0x%.16llX (0x%X)", tmp_vaddr, tmp0, pnorInfo.vaddr, tmp1);
-#endif
-
             sbeToc = reinterpret_cast<sbeToc_t*>( pnorInfo.vaddr );
 
             if (sbeToc->eyeCatch != SBETOC_EYECATCH)
diff --git a/src/usr/targeting/attrrp.C b/src/usr/targeting/attrrp.C
index 3184679..2fba3a5 100644
--- a/src/usr/targeting/attrrp.C
+++ b/src/usr/targeting/attrrp.C
@@ -278,12 +278,6 @@ namespace TARGETING
                 break;
             }
 
-            // @TODO RTC:156118 this should be adjusted in getSectionInfo by spnorrp
-            // spnorrp. For now, increment past header
-            #ifdef CONFIG_SECUREBOOT
-            l_pnorSectionInfo.vaddr += PAGESIZE;
-            #endif
-
             // Find attribute section header.
             TargetingHeader* l_header =
                 reinterpret_cast<TargetingHeader*>(l_pnorSectionInfo.vaddr);
diff --git a/src/usr/vfs/vfsrp.C b/src/usr/vfs/vfsrp.C
index 54fa7d6..e7b3b6c 100644
--- a/src/usr/vfs/vfsrp.C
+++ b/src/usr/vfs/vfsrp.C
@@ -166,19 +166,15 @@ errlHndl_t VfsRp::_init()
         iv_pnor_vaddr = l_pnor_info.vaddr;
 
         #ifdef CONFIG_SECUREBOOT
-        // @TODO RTC:156118 this will no longer be needed when getSectionInfo
-        SECUREBOOT::ContainerHeader l_conHdr(reinterpret_cast<void*>(iv_pnor_vaddr));
-
-        // @TODO RTC:156118 this should be adjusted in getSectionInfo by spnorrp
-        // For now, done with the container header so increment vaddr
-        iv_pnor_vaddr += PAGE_SIZE;
-
-        // @TODO RTC:156118 These variables will be set and obtained via
-        // getSectionInfo. l_conHdr will not exist after that story is complete.
+        // store the hash page table offset for reference
         iv_hashPageTableOffset = iv_pnor_vaddr;
+
+        // calculate the hash page table size
         TRACFCOMP(g_trac_vfs, "VfsRp::_init HB_EXT payload_text_size = 0x%X",
-                    l_conHdr.payloadTextSize());
-        iv_hashPageTableSize = l_conHdr.payloadTextSize()-VFS_MODULE_TABLE_SIZE;
+                    l_pnor_info.secureProtectedPayloadSize);
+        iv_hashPageTableSize = l_pnor_info.secureProtectedPayloadSize
+                                                       - VFS_MODULE_TABLE_SIZE;
+        // skip the hash page table
         iv_pnor_vaddr += iv_hashPageTableSize;
         #endif
 
-- 
2.9.2


From ceed442fef375d7c090158b81bc91832fa6491be Mon Sep 17 00:00:00 2001
From: Jaymes Wilks <mjwilks@us.ibm.com>
Date: Fri, 19 Aug 2016 09:50:39 -0500
Subject: [PATCH 02/20] SPNORRP secure header size cleanup

Remove the PAGESIZE adjustments from the code to make it easier
to read and maintain.

Change-Id: I6832944e609c10dbf6fe77c26038d507038e24c9
RTC:156118
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/28564
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Reviewed-by: Stephen M. Cprek <smcprek@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Reviewed-by: Nicholas E. Bofferding <bofferdn@us.ibm.com>
Reviewed-by: Daniel M. Crowell <dcrowell@us.ibm.com>
---
 src/usr/pnor/spnorrp.C | 35 ++++++++++-------------------------
 1 file changed, 10 insertions(+), 25 deletions(-)

diff --git a/src/usr/pnor/spnorrp.C b/src/usr/pnor/spnorrp.C
index 89a1ad4..53f9491 100644
--- a/src/usr/pnor/spnorrp.C
+++ b/src/usr/pnor/spnorrp.C
@@ -280,7 +280,8 @@ void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
         l_info.size += PAGESIZE; // add a page to size to account for the header
 
         // it's a coding error if l_info.vaddr is not in secure space
-        assert(l_info.vaddr >= SBASE_VADDR);
+        assert(l_info.vaddr >= SBASE_VADDR, "For section %s, getSectionInfo"
+            " returned a non secure space address", l_info.name);
 
         // Note: A pointer to virtual memory in one PNOR space can be converted
         // to a pointer to any of the other two PNOR spaces and visa versa.
@@ -337,7 +338,7 @@ void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
                              l_tempAddr, 128);
 
         // store secure space pointer in load record
-        o_rec->secAddr = reinterpret_cast<uint8_t*>(l_info.vaddr);
+        o_rec->secAddr = reinterpret_cast<uint8_t*>(l_info.vaddr) + PAGESIZE;
 
         TRACFCOMP(g_trac_pnor,"section start address in secure space is "
                               "0x%.16llX",o_rec->secAddr);
@@ -391,14 +392,8 @@ void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
         // keep track of info size in load record
         o_rec->infoSize = l_totalContainerSize - PAGESIZE;
 
-        // skip the header to block secure header access
-        uint8_t* l_securePayloadStart = o_rec->secAddr + PAGESIZE;
-
         // set permissions on the secured pages to writable
-        l_errhdl = setPermission(o_rec->secAddr,
-                                          o_rec->textSize + PAGESIZE, WRITABLE);
-        // TODO RTC 156118 - change above two lines of code to below:
-        //l_errhdl = setPermission(l_securePayloadStart, o_rec->textSize, WRITABLE);
+        l_errhdl = setPermission(o_rec->secAddr, o_rec->textSize, WRITABLE);
         if(l_errhdl)
         {
             TRACFCOMP(g_trac_pnor,"SPnorRP::verifySections set permissions "
@@ -425,7 +420,7 @@ void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
                     "payload",
                     l_info.name);
 
-            l_errhdl = setPermission(l_securePayloadStart + o_rec->textSize,
+            l_errhdl = setPermission(o_rec->secAddr + o_rec->textSize,
                                        unprotectedPayloadSize,
                                        WRITABLE | WRITE_TRACKED);
             if(l_errhdl)
@@ -437,7 +432,7 @@ void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
 
             // Register the write tracked memory range to be flushed on
             // shutdown.
-            INITSERVICE::registerBlock(l_securePayloadStart + o_rec->textSize,
+            INITSERVICE::registerBlock(o_rec->secAddr + o_rec->textSize,
                                         unprotectedPayloadSize, SPNOR_PRIORITY);
         }
         else
@@ -506,10 +501,7 @@ void SPnorRP::waitForMessage()
                         // check and see if our cached section information
                         // is obsolete and if so, change it
                         if ( (eff_addr < l_rec.secAddr) ||
-                             (eff_addr >= (l_rec.secAddr + l_rec.infoSize
-                                                                   + PAGESIZE))
-                            // TODO RTC 156118 remove the PAGESIZE adjustment
-                            // as soon as getSectionInfo offset change is in
+                             (eff_addr >= (l_rec.secAddr + l_rec.infoSize))
                            )
                         {
                             bool l_found = false;
@@ -522,8 +514,7 @@ void SPnorRP::waitForMessage()
                                 LoadRecord* l_record = (*i).second;
                                 if ( (eff_addr >= l_record->secAddr) &&
                                      (eff_addr < (l_record->secAddr +
-                                                l_record->infoSize + PAGESIZE))
-                                    // TODO RTC 156118 also remove this PAGESIZE
+                                                l_record->infoSize))
                                    )
                                 {
                                     l_rec = *l_record;
@@ -555,10 +546,7 @@ void SPnorRP::waitForMessage()
                         // whether it is part of the secure payload.
                         // by the way, this if could be removed to make this
                         // purely arithmetic
-                        if (eff_addr >= (l_rec.secAddr + l_rec.textSize
-                                                                 + PAGESIZE))
-                        // TODO RTC 156118 remove the PAGESIZE adjustment after
-                        // the getSectionOffset stuff gets closed out
+                        if (eff_addr >= (l_rec.secAddr + l_rec.textSize))
                         {
                             delta += VMM_VADDR_SPNOR_DELTA;
                         }
@@ -571,10 +559,7 @@ void SPnorRP::waitForMessage()
                         memcpy(user_addr, eff_addr - delta, PAGESIZE);
                         // if the page came from temp space then free up
                         // the temp page now that we're done with it
-                        if (eff_addr < (l_rec.secAddr + l_rec.textSize
-                                                                   + PAGESIZE))
-                        // TODO RTC 156118 remove the PAGESIZE adjustment here
-                        // as well for the same reason as above
+                        if (eff_addr < (l_rec.secAddr + l_rec.textSize))
                         {
                             mm_remove_pages(RELEASE, eff_addr - delta,
                                             PAGESIZE);
-- 
2.9.2


From bac18bcbda65c3e8c2c19aa370a67c00720b5d2e Mon Sep 17 00:00:00 2001
From: Elizabeth Liner <eliner@us.ibm.com>
Date: Wed, 27 Jul 2016 15:13:03 -0500
Subject: [PATCH 03/20] Porting non-hdat from powervm-p8 into master-p8

Change-Id: I59aa0edc736b8490bfaca2fe4c23f4e7c31c824d
Depends-on: I78ee5084a0751ddab91851e01ee4fd6268a14db6
Forwardport:yes
RTC:156618
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/27795
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Reviewed-by: Martin Gloff <mgloff@us.ibm.com>
Reviewed-by: Daniel M. Crowell <dcrowell@us.ibm.com>
---
 src/HBconfig                                       |   4 +-
 src/build/mkrules/dist.targets.mk                  |   5 +-
 src/include/math.h                                 |  15 +-
 src/include/usr/vpd/pvpdenums.H                    |   3 +-
 src/lib/math.C                                     |  17 +-
 src/usr/hwas/common/hwas.C                         |  28 +-
 src/usr/hwpf/hwp/load_payload/load_payload.C       |  46 +-
 src/usr/hwpf/hwp/tod_init/TodControls.C            | 416 ++---------
 src/usr/hwpf/hwp/tod_init/TodControls.H            | 181 +----
 src/usr/hwpf/hwp/tod_init/TodSvc.C                 |   7 +-
 src/usr/hwpf/hwp/tod_init/TodTypes.H               |   8 +-
 src/usr/targeting/common/entitypath.C              |  16 +
 .../targeting/common/xmltohb/attribute_types.xml   |  88 ++-
 .../common/xmltohb/attribute_types_openpower.xml   |  36 -
 .../common/xmltohb/attribute_types_oppowervm.xml   | 798 +++++++++++++++++++++
 src/usr/targeting/common/xmltohb/target_types.xml  | 127 ++++
 .../common/xmltohb/target_types_openpower.xml      |  36 -
 .../common/xmltohb/target_types_oppowervm.xml      | 193 +++++
 src/usr/targeting/xmltohb/makefile                 |  10 +-
 src/usr/vpd/pvpd.H                                 |   3 +-
 20 files changed, 1394 insertions(+), 643 deletions(-)
 delete mode 100644 src/usr/targeting/common/xmltohb/attribute_types_openpower.xml
 create mode 100644 src/usr/targeting/common/xmltohb/attribute_types_oppowervm.xml
 delete mode 100644 src/usr/targeting/common/xmltohb/target_types_openpower.xml
 create mode 100644 src/usr/targeting/common/xmltohb/target_types_oppowervm.xml

diff --git a/src/HBconfig b/src/HBconfig
index e1e19b0..703e95e 100644
--- a/src/HBconfig
+++ b/src/HBconfig
@@ -18,5 +18,5 @@ config INCLUDE_XML_OPENPOWER
     default n
     help
         Indicates that a build should include the contents
-        of attribute_types_openpower.xml and
-        target_types_openpower.xml
+        of attribute_types_oppowervm.xml and
+        target_types_oppowervm.xml
diff --git a/src/build/mkrules/dist.targets.mk b/src/build/mkrules/dist.targets.mk
index 71db11e..9378b0a 100644
--- a/src/build/mkrules/dist.targets.mk
+++ b/src/build/mkrules/dist.targets.mk
@@ -93,9 +93,8 @@ COPY_FILES = \
     $(foreach file, $(call ROOTPATH_WILDCARD,releaseNotes.html), $(file):fsp)\
 
 include ${ROOTPATH}/config.mk
-COPY_FILES += $(if $(CONFIG_INCLUDE_XML_OPENPOWER),obj/genfiles/target_types_placeholder.xml:openpower) \
-    $(if $(CONFIG_INCLUDE_XML_OPENPOWER),src/usr/targeting/common/xmltohb/target_types_openpower.xml:openpower) \
-    $(if $(CONFIG_INCLUDE_XML_OPENPOWER),src/usr/targeting/common/xmltohb/attribute_types_openpower.xml:openpower) \
+COPY_FILES += $(if $(CONFIG_INCLUDE_XML_OPENPOWER),src/usr/targeting/common/xmltohb/target_types_oppowervm.xml:openpower) \
+    $(if $(CONFIG_INCLUDE_XML_OPENPOWER),src/usr/targeting/common/xmltohb/attribute_types_oppowervm.xml:openpower) \
 
 #
 # Files which are copied and renamed for targets.
diff --git a/src/include/math.h b/src/include/math.h
index ebe3421..5d70337 100644
--- a/src/include/math.h
+++ b/src/include/math.h
@@ -5,7 +5,9 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* COPYRIGHT International Business Machines Corp. 2011,2014              */
+/* Contributors Listed Below - COPYRIGHT 2011,2016                        */
+/* [+] International Business Machines Corp.                              */
+/*                                                                        */
 /*                                                                        */
 /* Licensed under the Apache License, Version 2.0 (the "License");        */
 /* you may not use this file except in compliance with the License.       */
@@ -40,6 +42,17 @@ static inline int64_t log2(uint64_t s)
 
 double sqrt(double) __attribute__((const));
 
+/**
+ * @brief  power function
+ *
+ * @param[in] base - value of base
+ * @param[in] exp  - value of exponential
+ *
+ * @return value of the value of base raised to the power of exp.
+ *
+ */
+uint64_t pow(const uint32_t base, const uint32_t exp);
+
 #ifdef __cplusplus
 };
 #endif
diff --git a/src/include/usr/vpd/pvpdenums.H b/src/include/usr/vpd/pvpdenums.H
index acf3bbd..6bf0041 100644
--- a/src/include/usr/vpd/pvpdenums.H
+++ b/src/include/usr/vpd/pvpdenums.H
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2013,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2013,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -81,6 +81,7 @@ namespace PVPD
         VP         = 0x15,
         VS         = 0x16,
         VZ         = 0x17,
+        LX         = 0x18,
 
         // Last Keyword
         PVPD_LAST_KEYWORD,
diff --git a/src/lib/math.C b/src/lib/math.C
index c6319aa..e590745 100644
--- a/src/lib/math.C
+++ b/src/lib/math.C
@@ -5,7 +5,9 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* COPYRIGHT International Business Machines Corp. 2011,2014              */
+/* Contributors Listed Below - COPYRIGHT 2011,2016                        */
+/* [+] International Business Machines Corp.                              */
+/*                                                                        */
 /*                                                                        */
 /* Licensed under the Apache License, Version 2.0 (the "License");        */
 /* you may not use this file except in compliance with the License.       */
@@ -29,3 +31,16 @@ double sqrt(double x)
     return _x;
 }
 
+/*****************************************************************************
+ *  pow
+ *****************************************************************************/
+uint64_t pow(const uint32_t base, const uint32_t exp)
+{
+    uint64_t result = 1;
+    for (uint32_t i=1; i <= exp; i++)
+    {
+        result = result * base;
+    }
+    return result;
+}
+
diff --git a/src/usr/hwas/common/hwas.C b/src/usr/hwas/common/hwas.C
index 3eae199..31b4226 100644
--- a/src/usr/hwas/common/hwas.C
+++ b/src/usr/hwas/common/hwas.C
@@ -127,13 +127,27 @@ errlHndl_t discoverTargets()
             target != targetService().end();
             ++target)
     {
-        HwasState hwasState             = target->getAttr<ATTR_HWAS_STATE>();
-        hwasState.deconfiguredByEid     = 0;
-        hwasState.poweredOn             = false;
-        hwasState.present               = false;
-        hwasState.functional            = false;
-        hwasState.dumpfunctional        = false;
-        target->setAttr<ATTR_HWAS_STATE>(hwasState);
+        // TODO:RTC:151617 Need to find a better way
+        // to initialize the target
+        if(target->getAttr<ATTR_TYPE>() == TYPE_SP)
+        {
+            HwasState hwasState          = target->getAttr<ATTR_HWAS_STATE>();
+            hwasState.deconfiguredByEid  = 0;
+            hwasState.poweredOn          = true;
+            hwasState.present            = true;
+            hwasState.functional         = true;
+            hwasState.dumpfunctional     = false;
+            target->setAttr<ATTR_HWAS_STATE>(hwasState);
+        }else
+        {
+            HwasState hwasState          = target->getAttr<ATTR_HWAS_STATE>();
+            hwasState.deconfiguredByEid  = 0;
+            hwasState.poweredOn          = false;
+            hwasState.present            = false;
+            hwasState.functional         = false;
+            hwasState.dumpfunctional     = false;
+            target->setAttr<ATTR_HWAS_STATE>(hwasState);
+        }
     }
 
     // Assumptions and actions:
diff --git a/src/usr/hwpf/hwp/load_payload/load_payload.C b/src/usr/hwpf/hwp/load_payload/load_payload.C
index 4b6c681..286e12a 100644
--- a/src/usr/hwpf/hwp/load_payload/load_payload.C
+++ b/src/usr/hwpf/hwp/load_payload/load_payload.C
@@ -113,9 +113,11 @@ void*   call_host_load_payload( void *io_pArgs )
         // Get Payload base/entry from attributes
         uint64_t payloadBase = sys->getAttr<TARGETING::ATTR_PAYLOAD_BASE>();
         TRACFCOMP( ISTEPS_TRACE::g_trac_isteps_trace,INFO_MRK
-                   "call_load_payload: Payload Base: 0x%08x, Base:0x%08x",
+                   "call_load_payload: Payload Base: 0x%08x MB, Base:0x%08x",
                    payloadBase, (payloadBase * MEGABYTE) );
 
+        payloadBase = payloadBase * MEGABYTE;
+
         // Load payload data in PHYP mode or in Sapphire mode
         if( is_sapphire_load() || is_phyp_load())
         {
@@ -199,7 +201,7 @@ static errlHndl_t load_pnor_section(PNOR::SectionId i_section,
             originalPayloadSize,
             i_physAddr );
 
-    uint64_t loadAddr = NULL;
+    void * loadAddr = NULL;
 
     // Use simics optimization if we are running under simics which has very
     // slow PNOR access.
@@ -219,9 +221,8 @@ static errlHndl_t load_pnor_section(PNOR::SectionId i_section,
         // Map in the physical memory we are loading into.
         // If we are not xz compressed, the uncompressedSize
         // is equal to the original size.
-        loadAddr = reinterpret_cast<uint64_t>(
-        mm_block_map( reinterpret_cast<void*>( i_physAddr ),
-                      uncompressedPayloadSize ) );
+        loadAddr = mm_block_map( reinterpret_cast<void*>( i_physAddr ),
+                      uncompressedPayloadSize );
 
         // Print out inital progress bar.
 #ifdef CONFIG_CONSOLE
@@ -240,8 +241,9 @@ static errlHndl_t load_pnor_section(PNOR::SectionId i_section,
             const uint32_t BLOCK_SIZE = 4096;
             for ( uint32_t i = 0; i < originalPayloadSize; i += BLOCK_SIZE )
             {
-                memcpy( reinterpret_cast<void*>( loadAddr + i ),
-                        reinterpret_cast<void*>( l_vaddr + i ),
+                memcpy( reinterpret_cast<void*>(
+                              reinterpret_cast<uint64_t>(loadAddr) + i ),
+                        reinterpret_cast<void*>( pnorSectionInfo.vaddr + i ),
                         std::min( originalPayloadSize - i, BLOCK_SIZE ) );
  #ifdef CONFIG_CONSOLE
                 for ( int new_progress = (i * progressSteps) /
@@ -258,7 +260,6 @@ static errlHndl_t load_pnor_section(PNOR::SectionId i_section,
         }
     }
 
-
     if(l_pnor_is_XZ_compressed)
     {
         struct xz_buf b;
@@ -312,21 +313,40 @@ static errlHndl_t load_pnor_section(PNOR::SectionId i_section,
              * @userdata2[0:31]  Original Payload Size
              * @userdata2[32:63] Uncompressed Payload Size
              */
-             err = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
+            err = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                              fapi::MOD_START_XZ_PAYLOAD,
                              fapi::RC_INVALID_RETURN_XZ_CODE,
                              ret,TWO_UINT32_TO_UINT64(
                                      originalPayloadSize,
                                      uncompressedPayloadSize));
-             err->addProcedureCallout(HWAS::EPUB_PRC_PHYP_CODE,
+            err->addProcedureCallout(HWAS::EPUB_PRC_PHYP_CODE,
                              HWAS::SRCI_PRIORITY_HIGH);
         }
         //Clean up memory
         xz_dec_end(s);
+    }
 
-     }
-
-     return err;
+    int rc = mm_block_unmap(reinterpret_cast<void *>(loadAddr));
+    if(rc)
+    {
+        TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,ERR_MRK
+                 "load_pnor_section: mm_block_unmap returned 0");
+
+        /*@
+         * @errortype
+         * @reasoncode      fapi::RC_MM_UNMAP_ERR
+         * @severity        ERRORLOG::ERRL_SEV_UNRECOVERABLE
+         * @moduleid        fapi::MOD_START_XZ_PAYLOAD
+         * @devdesc         mm_block_unmap returned incorrectly with non-0
+         * @custdesc        Error unmapping memory section
+         * @usrdata1        Return code from mm_block_map
+         */
+        err = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
+                                      fapi::MOD_START_XZ_PAYLOAD,
+                                      fapi::RC_MM_UNMAP_ERR,
+                                      rc,0,HWAS::SRCI_PRIORITY_HIGH);
+    }
+    return err;
 }
 
 }; // end namespace
diff --git a/src/usr/hwpf/hwp/tod_init/TodControls.C b/src/usr/hwpf/hwp/tod_init/TodControls.C
index d3cb2e7..a000f19 100755
--- a/src/usr/hwpf/hwp/tod_init/TodControls.C
+++ b/src/usr/hwpf/hwp/tod_init/TodControls.C
@@ -5,7 +5,9 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* COPYRIGHT International Business Machines Corp. 2013,2014              */
+/* Contributors Listed Below - COPYRIGHT 2013,2016                        */
+/* [+] International Business Machines Corp.                              */
+/*                                                                        */
 /*                                                                        */
 /* Licensed under the Apache License, Version 2.0 (the "License");        */
 /* you may not use this file except in compliance with the License.       */
@@ -535,164 +537,6 @@ errlHndl_t  TodControls::buildTodDrawers(
 }
 
 //******************************************************************************
-//TodControls::getTodConfigState
-//******************************************************************************
-errlHndl_t TodControls::getTodConfigState(
-        TOD_CONFIG_STATE& o_configState,
-        proc_tod_setup_tod_sel& o_activeConfig,
-        bool& o_isTodRunning)const
-{
-    TOD_ENTER("getTodConfigState");
-    errlHndl_t l_errHdl = NULL;
-    o_configState = TOD_UNCHANGED;
-    o_activeConfig = TOD_PRIMARY;
-    o_isTodRunning = false;
-
-    do
-    {
-        //Get the currently active TOD configuration
-        l_errHdl = queryActiveConfig (o_activeConfig,o_isTodRunning);
-        if ( l_errHdl )
-        {
-            TOD_ERR("Call to queryActiveConfig failed ");
-            break;
-        }
-        //Need to read the TodSystemFile to decide if HW configuration has
-        //changed since the last time TOD was configured
-        std::vector<TodChipData> l_todChipDataVector;
-        l_errHdl = TodControls::readTodProcDataFromFile(l_todChipDataVector);
-        if ( l_errHdl ) //Indicates hard failure not limited to failure of tod
-            //logic only, we cannot continue with flow
-        {
-            TOD_ERR("Failed loading TodChipData from TodSystemFile");
-            break;
-        }
-
-        //Determine if the TOD HW has changed since the last time topology was
-        //created
-        //1) File data is valid but HW has changed => Report TOD_MODIFIED
-        //2) File data is valid and HW has not changed => Report TOD_UNCHANGED
-        //3) Authenticity of file data is in question => Report
-        //TOD_UNKNOWN
-
-        //Check if TodSystemFile has topology data for atleast one node
-        if ( hasNoValidData ( l_todChipDataVector ))
-        {
-            TOD_INF("No valid data found in the file TodSystemFile");
-            o_configState = TOD_UNKNOWN;
-            break;
-        }
-
-        //For each functional processor present in the system, if we
-        //have, old  configuration data in the TodSystemConfig file then
-        //validate it.
-
-        //Get the processors present in the system
-        TARGETING::PredicateCTM
-            l_procFilter(TARGETING::CLASS_CHIP,TARGETING::TYPE_PROC,
-                    TARGETING::MODEL_NA);
-
-        TARGETING::PredicateHwas l_presencePredicate;
-        l_presencePredicate.present(true);
-
-        TARGETING::PredicatePostfixExpr l_presenceAndProcChipFilter;
-        l_presenceAndProcChipFilter.push(&l_procFilter).
-            push(&l_presencePredicate).And();
-
-        TARGETING::TargetRangeFilter l_filter(
-                TARGETING::targetService().begin(),
-                TARGETING::targetService().end(),
-                &l_presenceAndProcChipFilter);
-
-        bool l_state = false;  //Variable for keeping functional state of
-        //the processor
-        uint32_t l_ordinalId = TOD_INVALID_UNITID;
-        //Initializing to some value not expected to be ordinal id
-
-        ecmdDataBufferBase l_chipCtrlRegBuf(64);
-
-        //Initialize l_chipCtrlRegBuf it will be used later
-
-        FAPI_INVOKE_HWP(l_errHdl, init_chip_ctrl_reg, l_chipCtrlRegBuf);
-        if ( l_errHdl )
-        {
-            TOD_ERR("init_chip_ctrl_reg returned error ");
-            break;
-        }
-
-        for ( ; l_filter ; ++l_filter )
-        {
-            l_state = false;
-            if ((*l_filter)->getAttr<ATTR_HWAS_STATE>().functional)
-            {
-                l_state = true;
-            }
-
-            // use position attribute on one drawer only machine
-            l_ordinalId=(*l_filter)->getAttr<ATTR_POSITION>();
-
-            if ( l_state ) //Functional processor
-            {
-                //Check if TodSystemData file also indicates the processor as
-                //functional
-
-                //Indexing into l_todChipDataVector is safe as size of vector is
-                //always determined by the maximum possible processors for this
-                //system type
-                if(((l_todChipDataVector[l_ordinalId].header.flags) &
-                            TOD_FUNC) != 0 )
-                {
-
-                    //File data says that the chip is functional do some more
-                    //validation on the data
-
-                    //Check if the chip control register (0x40010) data is valid
-                    //This data does not depend on topology, so it should tally
-                    if ( (l_todChipDataVector[l_ordinalId].regs.ccr) !=
-                            l_chipCtrlRegBuf.getWord(0)  )
-                    {
-                        TOD_INF("Chip control register read from TodSystemData"
-                                "is not valid for the processor 0x%08X",
-                                (*l_filter)->getAttr<TARGETING::ATTR_HUID>());
-                        //We do not have a valid data no need to continue
-                        //further
-                        o_configState = TOD_UNKNOWN;
-                        break;
-                    }
-                }
-                else
-                {
-                    //New hardware has been added
-                    TOD_INF("New processor detected 0x%08X",
-                            (*l_filter)->getAttr<ATTR_HUID>());
-                    o_configState = TOD_MODIFIED;
-                }
-
-            }
-            else
-            {
-                //Check if this chip was functional earlier
-                if ( ((l_todChipDataVector[l_ordinalId].header.flags) &
-                            TOD_FUNC) != 0 )
-                {
-                    //HW has been removed
-                    o_configState = TOD_MODIFIED;
-                    TOD_INF("Processor 0x%08X is no more available ",
-                            (*l_filter)->getAttr<ATTR_HUID>());
-                }
-            }
-        }
-
-    }while(0);
-
-    TOD_EXIT(" config state = %d, active config = %d, TOD HW State = "
-            "%d errHdl = %p",
-            o_configState, o_activeConfig , o_isTodRunning, l_errHdl);
-
-    return l_errHdl;
-}
-
-//******************************************************************************
 //TodControls::isTodRunning
 //******************************************************************************
 errlHndl_t TodControls::isTodRunning(bool& o_isTodRunning)const
@@ -1036,6 +880,11 @@ errlHndl_t TodControls::writeTodProcData(
 
         TodChipData blank;
         uint32_t l_maxProcCount = getMaxProcsOnSystem();
+        Target* l_target = NULL;
+
+        //the size of the attribute needs to accommodate the size of the struct
+        TOD_ASSERT(sizeof(TodChipData) == sizeof(ATTR_TOD_CPU_DATA_type),
+                "sizeof TodChipData and attribute different");
 
         TOD_INF("Max possible processor chips for this system when configured "
                 "completely is %d",l_maxProcCount);
@@ -1117,19 +966,17 @@ errlHndl_t TodControls::writeTodProcData(
 
                 }
 
-            }
-        }
+                ATTR_TOD_CPU_DATA_type l_tod_array;
+                memcpy(l_tod_array,
+                        &iv_todChipDataVector[l_ordId],sizeof(TodChipData));
 
-        //Done with setting the data write it to the file
-        l_errHdl = writeTodProcDataToFile();
-        if ( l_errHdl )
-        {
-            TOD_ERR( "Failed writing TOD chip data to the file ");
-            break;
+                l_target = const_cast<Target*>((*l_procItr)->getTarget());
+                l_target->setAttr<ATTR_TOD_CPU_DATA>(l_tod_array);
+
+            }
         }
 
     }while(0);
-
     TOD_EXIT("writeTodProcData. errHdl = %p", l_errHdl);
     return l_errHdl;
 
@@ -1137,233 +984,76 @@ errlHndl_t TodControls::writeTodProcData(
 
 
 //******************************************************************************
-//TodControls::writeTodProcDataToFile()
+//HwsvTodControls::hasNoValidData()
 //******************************************************************************
-errlHndl_t TodControls::writeTodProcDataToFile()
+bool TodControls::hasNoValidData(const std::vector<TodChipData>&
+        i_todChipDataVector)const
 {
-    TOD_ENTER("writeTodProcDataToFile");
-    errlHndl_t l_errHdl = NULL;
-#ifndef __HOSTBOOT_MODULE
-    do
+    TOD_ENTER("hasNoValidData");
+    bool result = true;
+    for(std::vector<TodChipData>::const_iterator l_iter =
+            i_todChipDataVector.begin();
+            l_iter != i_todChipDataVector.end(); ++l_iter)
     {
-        std::string l_fileOpenMode(FILE_WRITE_MODE);
-        char l_fileName[128];
-        l_errHdl = getTodProcDataFilePath(l_fileName);
-        if(l_errHdl)
-        {
-            TOD_ERR("Failed getting the file path for sharing TOD data with "
-                    "   HDAT ");
-            break;
-        }
-
-        //Create the parent directory in which file has to be written
-        std::string l_dirPath = l_fileName.substr
-            (0,l_fileName.find_last_of(DIR_PATH_SERERATOR));
-        int rc = mkdir(l_dirPath.c_str(),DIR_CREATION_MODE);
-
-        if ( rc != 0 )
-        {
-            //EEXIST just means it already exists, which is fine
-            if (errno != EEXIST)
-            {
-                TOD_ERR("Error creating the directory %s "
-                        "system returned error code %d",
-                        l_dirPath.c_str(),errno);
-                break;
-            }
-        }
-
-        UtilFile file;
-        l_errHdl = file.open(l_fileName.c_str(), l_fileOpenMode.c_str());
-        if ( l_errHdl )
-        {
-            TOD_ERR("Failed opening the file %s, with mode %s" ,
-                    l_fileName.c_str(),l_fileOpenMode.c_str());
-            break;
-        }
-
-        TodChipDataContainer::iterator l_chipDataItr =
-            iv_todChipDataVector.begin();
-        file.write(reinterpret_cast<void *>((&(*l_chipDataItr))),
-                (iv_todChipDataVector.size()* sizeof(TodChipData)));
-
-        l_errHdl = file.getLastError();
-        if ( l_errHdl )
-        {
-            TOD_ERR("Failed writing the tod chip data to file ");
-            break;
-        }
-
-        l_errHdl = file.close();
-        if ( l_errHdl )
+        if(((*l_iter).header.flags & TOD_FUNC) != 0)
         {
-            TOD_ERR("Failed closing the file %s",  l_fileName.c_str());
+            result = false;
             break;
         }
-
-    }while(0);
-#endif
-    TOD_EXIT("writeTodProcDataToFile. errHdl = %p", l_errHdl);
-    return l_errHdl;
-
+    }
+    TOD_EXIT("hasNoValidData");
+    return result;
 }
 
 //*****************************************************************************
-//TodControls::readTodProcDataFromFile
+//TodControls::getTodProcDataFromAttribute()
 //******************************************************************************
-errlHndl_t TodControls::readTodProcDataFromFile(
+errlHndl_t TodControls::getTodProcDataFromAttribute(
         std::vector<TodChipData>& o_todChipDataVector )const
 {
-    TOD_ENTER("readTodProcDataFromFile");
+    TOD_ENTER("getTodProcDataFromAttribute()");
     errlHndl_t l_errHdl = NULL;
-#ifndef __HOSTBOOT_MODULE
+
     do
     {
-        std::string l_todProcDataFile;
-        UtilFile l_file;
-
-        l_errHdl = getTodProcDataFilePath(l_todProcDataFile);
-        if(l_errHdl)
-        {
-            TOD_ERR("Failed getting the path of TodSystemFile ");
-            break;
-        }
+        TodChipData l_todData;
+        memset(&l_todData,0,sizeof(TodChipData));
+        ATTR_TOD_CPU_DATA_type l_arrayVal;
 
-        if ( !UtilFile::exists(l_todProcDataFile.c_str()))
-        {
-            TOD_INF("File %s , does not exist",l_todProcDataFile.c_str());
-            break;
-        }
-
-        //Open the file for reading
-        l_errHdl = l_file.open(l_todProcDataFile.c_str(),FILE_READ_MODE);
-        if ( l_errHdl )
-        {
-            TOD_ERR("Failed opening the file %s, with mode %s" ,
-                    l_todProcDataFile.c_str(),FILE_READ_MODE);
-            break;
-        }
+        //the size of the attribute needs to accommodate the size of the struct
+        TOD_ASSERT(sizeof(TodChipData) == sizeof(ATTR_TOD_CPU_DATA_type),
+                "sizeof TodChipData and attribute different");
 
         //The amount of data stored on TodSystemFile always depend on the
         //maximum processor possible for the given system type
         uint32_t l_maxProcCount = getMaxProcsOnSystem();
 
-        uint32_t l_bytesToRead = l_file.size();
-
-        if ( (l_bytesToRead == 0)  || (l_bytesToRead > (l_maxProcCount *
-            sizeof(TodChipData))))  //Check for further safeguards
-        {
-            TOD_ERR("Error, File %s is corrupted"
-                    ,l_todProcDataFile.c_str());
-
-            //Commit this locally, because system can still proceed if TOD HW is
-            //not running
-            l_errHdl->commit(HWSV_COMP_ID, ERRL_ACTION_REPORT,
-                    ERRL_SEV_INFORMATIONAL);
-            delete l_errHdl;
-            l_errHdl = 0;
-            break;
-        }
-
         TodChipData blank;
-        o_todChipDataVector.assign(l_maxProcCount,blank); //Allocate memory with
-        //default values
 
-        //Read the data from file
-        l_file.read(reinterpret_cast<void *>(&(*(o_todChipDataVector.begin()))),
-                l_bytesToRead);
+        //Allocate memory
+        o_todChipDataVector.assign(l_maxProcCount,blank);
 
+        TARGETING::TargetHandleList l_procListA;
+        getAllChips(l_procListA, TYPE_PROC);
 
-        l_errHdl = l_file.getLastError();
-        if ( l_errHdl )
+        bool l_read=0;
+        for(TargetHandleList::const_iterator proc = l_procListA.begin();
+                 proc != l_procListA.end(); ++proc)
         {
-            TOD_ERR("Failed reading tod chip data from file ");
-            break;
-
+            l_read =
+               (*proc)->tryGetAttr<TARGETING::ATTR_TOD_CPU_DATA>(l_arrayVal);
+            TOD_ASSERT(l_read==true, "ATTR_TOD_CPU_DATA not found");
+            memcpy(&l_todData, l_arrayVal, sizeof(TodChipData));
+            o_todChipDataVector
+            [(*proc)->getAttr<TARGETING::ATTR_POSITION>()]= l_todData;
         }
 
-        l_errHdl = l_file.close();
-        if ( l_errHdl )
-        {
-            TOD_ERR("Failed closing the file %s", l_todProcDataFile.c_str());
-            break;
-        }
-        //Not going to close the file in error path , UtilFile will close it.
-
-    }while(0);
-#endif
-     TOD_EXIT("readTodProcDataFromFile. errHdl = %p", l_errHdl);
-     return l_errHdl;
-}
-
-//******************************************************************************
-//TodControls::getTodProcDataFilePath()
-//******************************************************************************
-errlHndl_t TodControls::getTodProcDataFilePath(char * o_fileName)
-    const
-{
-    TOD_ENTER("getTodProcDataFilePath");
-    errlHndl_t l_errHdl = NULL;
-#ifndef __HOSTBOOT_MODULE
-    char *l_buf = NULL;
-    do
-    {
-        uint32_t     l_fileSize = 0;
-        const char* l_stringToAppend = NULL;
-        const char* l_filePathKey[2] =
-        {   P1_ROOT_PATH,
-            CINI_SYSTODFILE_PATH
-        };
-
-
-        l_errHdl = UtilReg::path(l_filePathKey,(sizeof(l_filePathKey) /
-        sizeof(l_filePathKey[0])),
-        l_stringToAppend,l_buf,l_fileSize);
-
-        if ( l_errHdl )
-        {
-            TOD_ERR("Failed getting file path from the registry using keys"
-            "P1_ROOT_PATH and CINI_SYSTODFILE_PATH " );
-            break;
-        }
-
-        o_fileName = std::string(l_buf);
-        TOD_INF("Found file path %s",o_fileName.c_str());
-
-
     }while(0);
+    TOD_EXIT("getTodProcDataFromAttribute(). errHdl = %p", l_errHdl);
 
-    if ( l_buf )
-    {
-        delete l_buf;
-    }
-#endif
-    TOD_EXIT("getTodProcDataFilePath. errHdl = %p", l_errHdl);
     return l_errHdl;
 }
 
 
-//******************************************************************************
-//HwsvTodControls::hasNoValidData()
-//******************************************************************************
-bool TodControls::hasNoValidData(const std::vector<TodChipData>&
-        i_todChipDataVector)const
-{
-    TOD_ENTER("hasNoValidData");
-    bool result = true;
-    for(std::vector<TodChipData>::const_iterator l_iter =
-            i_todChipDataVector.begin();
-            l_iter != i_todChipDataVector.end(); ++l_iter)
-    {
-        if(((*l_iter).header.flags & TOD_FUNC) != 0)
-        {
-            result = false;
-            break;
-        }
-    }
-    TOD_EXIT("hasNoValidData");
-    return result;
-}
-
-
 }//end of namespace
+
diff --git a/src/usr/hwpf/hwp/tod_init/TodControls.H b/src/usr/hwpf/hwp/tod_init/TodControls.H
index 922a58f..1e799b2 100755
--- a/src/usr/hwpf/hwp/tod_init/TodControls.H
+++ b/src/usr/hwpf/hwp/tod_init/TodControls.H
@@ -5,7 +5,9 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* COPYRIGHT International Business Machines Corp. 2013,2014              */
+/* Contributors Listed Below - COPYRIGHT 2013,2016                        */
+/* [+] International Business Machines Corp.                              */
+/*                                                                        */
 /*                                                                        */
 /* Licensed under the Apache License, Version 2.0 (the "License");        */
 /* you may not use this file except in compliance with the License.       */
@@ -39,7 +41,6 @@
 #include <util/singleton.H>
 #include "proc_tod_utils.H"
 #include "TodDrawer.H"
-#include <map>
 
 namespace TOD
 {
@@ -271,66 +272,6 @@ public:
         return iv_todConfig[i_config].iv_isConfigured;
     }
 
-    /**
-     *
-     * @brief getTodConfigState will enable other methods to make a decision
-     *     regarding valid action to be performed to modify the
-     *     topology.
-     *
-     * @par Detailed Description:
-     *     On getting a topology creation/modification request, TOD service
-     *     methods need to determine next course of action based on the ChipTOD
-     *     HW state and the state of the data that is available in the
-     *     TodSystemData file.(TodSystemData file contains the previously
-     *     created TOD topology's information). This method will provide all
-     *     the information that is required to determine next course of action.
-     *
-     *     Following algorithm is used
-     *     1) Check TOD status register to determine TOD HW state and the active
-     *     configuration
-     *     2) Read the TodSystemData to find, if HW has changed i.e. new
-     *     functional processors became available or one of the processor that
-     *     was functional when topology was created last time became
-     *     non-functional.
-     *
-     *     Method can report TOD config state as one of the following
-     *        a)TOD_UNCHANGED ==> No change in the HW
-     *        b)TOD_MODIFIED ==> HW has changed
-     *        c)TOD_UNKNOWN ==> It is not possible to determine the state
-     *
-     * @param[out] o_configState
-     *     This parameter will indicate to caller if the HW as seen by
-     *     getTodConfigState is same as indicated by the TodSystemData or not.
-     *     One of the enums listed in TOD_CONFIG_STATE will be returned.
-     *
-     * @param[out] o_isTodRunning
-     *     It will be true if the ChipTOD HW is running.
-     *
-     * @param[out] o_activeConfig
-     *     This parameter will carry back the information regarding the topology
-     *     that has been currently selected by PHYP, if ChipTOD HW is running.
-     *     In case TOD HW is not running then it will report TOD_PRIMARY, as
-     *     that is the configuration to be picked by PHYP once the TOD logic
-     *     starts running.
-     *
-     * @return Error log handle that will determine if method was successful in
-     *      determining various parameters or not
-     * @retval  NULL , Indicates success
-     * @retval !NULL , Failed getting the output parameters,in this case
-     *      value of o_configState,o_isTodRunning and o_activeConfig should
-     *      not be considered for any further action.
-     *
-     *      This API may return one of the following "special" reason codes:
-     *      NA
-     *
-     * @note It is up to the caller to change the severity of the
-     *     returned error based on what it decides to do with it. By default
-     *     any returned error created by this function will be a non-reported
-     *     tracing event error log.
-     */
-     errlHndl_t getTodConfigState ( TOD_CONFIG_STATE& o_configState,
-                                   proc_tod_setup_tod_sel& o_activeConfig,
-                                   bool& o_isTodRunning)const;
      /**
      * @brief isTodRunning returns the current state of  ChipTOD HW i.e.
      *    whether it is running or not
@@ -364,20 +305,17 @@ public:
      */
      errlHndl_t isTodRunning ( bool& o_isTodRunning)const;
 
-
-
      /**
-      * @brief This method will provide TOD topology register data to HDAT
+      * @brief This method will save TOD topology register data for HDAT
       *
       * @par Detailed Description:
       *     HWSV needs to share TOD topology data with HDAT.
       *     HWSV also needs to persist with TOD topology data across non-memory
       *     preserving IPL's.
       *     Both the above requirements will be fulfilled by writing data
-      *     to a file.
+      *     to an attribute per proc.
       *     This method will take the TOD register data and put it in the format
-      *     required by HDAT, and then call helper method to write the same to a
-      *     file
+      *     required by HDAT
       *
       * @param[in] i_config
       *     Indicates the primary/secondary topology. When both Primary and
@@ -387,78 +325,24 @@ public:
       *     building one of the topologies i.e. primary could be built but not
       *     the secondary then primary should be passed as i_config.
       *
-      * @return Error log handle indicating the status of the request.
-      * @retval NULL if successful
-      * @retval !NULL if failed to write TOD configuration data
-      *
-      *      Error log handle points to a valid error log object whose primary
-      *      SRC reason code (pError->getSRC()->reasonCode()) indicates the type
-      *      of error.
-      *
-      * @note It is up to the caller to change the severity of the returned
-      *     error based on what it decides to do with it. By default any
-      *     returned error created by this function will be a non-reported
-      *     tracing event error log.
+      * @return NULL if successful
+      *         !NULL otherwise
       */
+
      errlHndl_t writeTodProcData(const proc_tod_setup_tod_sel i_config);
 
- 
      /**
+      * @brief This method will be used to return Tod Data for all procs
+      *     by reading the TOD data from chip attribute
+      * @param[in]: o_todChipDataVector
+      *         is populated with TOD data
+      * @return if it cannot read from attribute TOD_ASSERT() will be invoked
       *
-      * @brief This is a helper method for writeTodProcDataToFile, it will
-      *     determine file path where array of hwsvTodChipData structure has to
-      *     be written by HWSV , HDAT will read this file.
-      *
-      * @par Detailed Description:
-      *     The file to which data has to be written will be determined by the
-      *     following registry keys
-      *     1. fstp/P1_Root (To determine the root directory of P1)
-      *     2. CINI_SYSTODFILE_PATH (To determine the directory and file name
-      *     within P1_Root where the data is to be written)
-      *
-      * @param[in] o_fileName
-      *     Output parameter to carry back the file name qualified by full path
-      *     where the data has has to be written.
-      *
-      * @return Error log handle indicating the status of the request.
-      * @retval NULL if file path could be determined successfully
-      * @retval !NULL if file path could not be found
-      *
-      *      Error log handle points to a valid error log object whose primary
-      *      SRC reason code (pError->getSRC()->reasonCode()) indicates the type
-      *      of error.
-      *
-      * @note It is up to the caller to change the severity of the returned error
-      *     based on what it decides to do with it. By default any returned
-      *     error created by this function will be a non-reported tracing event
-      *     error log.
       */
-     errlHndl_t getTodProcDataFilePath(char * o_fileName) const;
 
-     /**
-      * @brief This is a helper method for writeTodProcData, it will write the
-      *     array of hwsvTodChipData structures created by writeTodProcData to a
-      *     file with P1 persistancy
-      *
-      * @par Detailed Description:
-      *     The method will work on iv_todChipData and take help of
-      *     getTodProcDataFilePath to detrmine the file path where
-      *     iv_todChipData has to be written.
-      *
-      * @return Error log handle indicating the status of the request
-      * @retval NULL if the data could not be written  successfully
-      * @retval !NULL if the data was written successfully
-      *
-      *     Error log handle points to a valid error log object whose primary
-      *     SRC reason code (pError->getSRC()->reasonCode()) indicates the type
-      *     of error.
-      *
-      * @note It is up to the caller to change the severity of the returned
-      *     error based on what it decides to do with it. By default any
-      *     returned error created by this function will be a non-reported
-      *     tracing event error log.
-      */
-     errlHndl_t writeTodProcDataToFile();
+     errlHndl_t getTodProcDataFromAttribute(
+             std::vector<TodChipData>& o_todChipDataVector )const;
+
 
      /**
       *
@@ -561,37 +445,6 @@ private:
                          TARGETING::Target*& o_secondaryMdmt)const;
 
      /**
-      * @brief This method will read the TOD topology register data from
-      *     TodSystemData file
-      *
-      * @par Detailed Description:
-      *     TodSystemData file is a P1 persistent file that will retain the TOD
-      *     topology data from previous configuration. Any request to recofigure
-      *     backup topology should consider the previous topology data. This
-      *     method will read the TodSystemData file and put the data in
-      *     hwsvTodChipData structures.
-      *
-      * @param[out ] o_todChipDataVector , Array of hwsvTodChipData structures
-      *     that will be populated with the data from TodSystemData file.
-      *
-      * @return Error log handle indicating the status of the request.
-      * @retval NULL if TodSystemData was successfully read.
-      * @retval !NULL if TodSystemData could not be read. This will happen if
-      *     the file does not exist, one of the file operation failed or file
-      *     does not have expected data.
-      *
-      *     This API may return one of the following "special" reason codes:
-      *     NA
-      *
-      * @note It is up to the caller to change the severity of the
-      *     returned error based on what it decides to do with it. By default
-      *     any returned error created by this function will be a non-reported
-      *     tracing event error log.
-      */
-     errlHndl_t readTodProcDataFromFile(std::vector<TodChipData>&
-             o_todChipDataVector )const;
- 
-     /**
       * @brief This method will be used to determine if the data read from
       *     TodSystemData file indicates at least one functional processor
       *
diff --git a/src/usr/hwpf/hwp/tod_init/TodSvc.C b/src/usr/hwpf/hwp/tod_init/TodSvc.C
index f76efe8..69190a3 100755
--- a/src/usr/hwpf/hwp/tod_init/TodSvc.C
+++ b/src/usr/hwpf/hwp/tod_init/TodSvc.C
@@ -5,7 +5,9 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* COPYRIGHT International Business Machines Corp. 2013,2014              */
+/* Contributors Listed Below - COPYRIGHT 2013,2016                        */
+/* [+] International Business Machines Corp.                              */
+/*                                                                        */
 /*                                                                        */
 /* Licensed under the Apache License, Version 2.0 (the "License");        */
 /* you may not use this file except in compliance with the License.       */
@@ -197,8 +199,7 @@ errlHndl_t TodSvc::todSetup()
         l_errHdl = l_Tod.writeTodProcData(TOD_PRIMARY);
         if(l_errHdl)
         {
-            TOD_ERR("TOD setup failure:Failed to write topology register data"
-            " to the file.");
+          TOD_ERR("TOD setup failure:Failed to write topology register data");
         }
     }
 
diff --git a/src/usr/hwpf/hwp/tod_init/TodTypes.H b/src/usr/hwpf/hwp/tod_init/TodTypes.H
index aacb21b..52865aa 100755
--- a/src/usr/hwpf/hwp/tod_init/TodTypes.H
+++ b/src/usr/hwpf/hwp/tod_init/TodTypes.H
@@ -5,7 +5,9 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* COPYRIGHT International Business Machines Corp. 2013,2014              */
+/* Contributors Listed Below - COPYRIGHT 2013,2016                        */
+/* [+] International Business Machines Corp.                              */
+/*                                                                        */
 /*                                                                        */
 /* Licensed under the Apache License, Version 2.0 (the "License");        */
 /* you may not use this file except in compliance with the License.       */
@@ -62,7 +64,7 @@ namespace TOD
         uint32_t chipID; //Chip ID
         uint32_t flags;  //Flags
         TodChipHeader(void) : chipID(0),flags(TOD_NONFUNC) {}
-    };
+    }__attribute__ ((packed));
 
     /**
      * Sub structure of TodChipData, That will contain the first 32 bits of
@@ -88,7 +90,7 @@ namespace TOD
             mpcr(0),pcrp0(0),pcrp1(0),scrp0(0),scrp1(0),
             spcr(0),ipcr(0),psmscr(0),ccr(0)
         {}
-    };
+    }__attribute__ ((packed));
 
     /**
      * TOD Data for each chip that HDAT will communicate
diff --git a/src/usr/targeting/common/entitypath.C b/src/usr/targeting/common/entitypath.C
index c03d409..6ab857e 100644
--- a/src/usr/targeting/common/entitypath.C
+++ b/src/usr/targeting/common/entitypath.C
@@ -403,6 +403,22 @@ const char* EntityPath::pathElementTypeAsString(
             return "FSI";
         case TYPE_TPM:
             return "TPM";
+        case TYPE_SP:
+            return "SP";
+        case TYPE_UART:
+            return "UART";
+        case TYPE_PS:
+            return "PS";
+        case TYPE_FAN:
+            return "FAN";
+        case TYPE_VRM:
+            return "VRM";
+        case TYPE_USB:
+            return "USB";
+        case TYPE_ETH:
+            return "ETH";
+        case TYPE_PANEL:
+            return "PANEL";
 //        case TYPE_FSI_LINK:
 //            return "FSI-link";
 //        case TYPE_CFAM:
diff --git a/src/usr/targeting/common/xmltohb/attribute_types.xml b/src/usr/targeting/common/xmltohb/attribute_types.xml
index 9238a53..9e1fe29 100644
--- a/src/usr/targeting/common/xmltohb/attribute_types.xml
+++ b/src/usr/targeting/common/xmltohb/attribute_types.xml
@@ -220,14 +220,46 @@
         <name>TPM</name>
         <value>35</value>
     </enumerator>
+    <enumerator>
+        <name>SP</name>
+        <value>36</value>
+    </enumerator>
+    <enumerator>
+        <name>UART</name>
+        <value>37</value>
+    </enumerator>
+    <enumerator>
+        <name>PS</name>
+        <value>38</value>
+    </enumerator>
+    <enumerator>
+        <name>FAN</name>
+        <value>39</value>
+    </enumerator>
+    <enumerator>
+        <name>VRM</name>
+        <value>40</value>
+    </enumerator>
+    <enumerator>
+        <name>USB</name>
+        <value>41</value>
+    </enumerator>
+    <enumerator>
+        <name>ETH</name>
+        <value>42</value>
+    </enumerator>
+    <enumerator>
+        <name>PANEL</name>
+        <value>43</value>
+    </enumerator>
     <!-- add any new types here, and increment TEST_FAIL and LAST_IN_RANGE -->
     <enumerator>
         <name>TEST_FAIL</name>
-        <value>36</value>
+        <value>44</value>
     </enumerator>
     <enumerator>
         <name>LAST_IN_RANGE</name>
-        <value>37</value>
+        <value>45</value>
     </enumerator>
     <default>NA</default>
 </enumerationType>
@@ -2209,8 +2241,8 @@
             <default>0</default>
         </field>
         <field>
-            <name>reserved</name>
-            <description>Reserved for future use</description>
+            <name>MinorIPLType</name>
+            <description>Minor IPL Type</description>
             <type>uint8_t</type>
             <bits>7</bits>
             <default>0</default>
@@ -16748,4 +16780,52 @@ firmware notes: Platforms should initialize this attribute to AUTO (0)</descript
     </hwpfToHbAttrMap>
 </attribute>
 
+<attribute>
+    <id>HDAT_HBRT_NUM_SECTIONS</id>
+    <description>
+        Number of internal data pointers we have in
+        the hostboot runtime data section.
+    </description>
+    <simpleType>
+        <uint32_t>
+        </uint32_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>HDAT_HBRT_SECTION_SIZE</id>
+    <description>
+        Biggest size for any of the hostboot
+        runtime data sections.
+    </description>
+    <simpleType>
+        <uint64_t>
+        </uint64_t>
+    <array>9</array>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>TOD_CPU_DATA</id>
+    <description>TOD CHIP DATA for each CHIP
+        The size of the TOD CHIP DATA must be equal to the sizeof(TodChipData)
+    </description>
+    <simpleType>
+        <uint8_t>
+        </uint8_t>
+    <!-- the size of the array must be equal to the sizeof(TodChipData)
+    defined in TodTypes.H  -->
+        <array>44</array>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
 </attributes>
diff --git a/src/usr/targeting/common/xmltohb/attribute_types_openpower.xml b/src/usr/targeting/common/xmltohb/attribute_types_openpower.xml
deleted file mode 100644
index 086a68a..0000000
--- a/src/usr/targeting/common/xmltohb/attribute_types_openpower.xml
+++ /dev/null
@@ -1,36 +0,0 @@
-<!-- IBM_PROLOG_BEGIN_TAG                                                   -->
-<!-- This is an automatically generated prolog.                             -->
-<!--                                                                        -->
-<!-- $Source: src/usr/targeting/common/xmltohb/attribute_types_openpower.xml $ -->
-<!--                                                                        -->
-<!-- OpenPOWER HostBoot Project                                             -->
-<!--                                                                        -->
-<!-- Contributors Listed Below - COPYRIGHT 2016                             -->
-<!-- [+] International Business Machines Corp.                              -->
-<!--                                                                        -->
-<!--                                                                        -->
-<!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
-<!-- you may not use this file except in compliance with the License.       -->
-<!-- You may obtain a copy of the License at                                -->
-<!--                                                                        -->
-<!--     http://www.apache.org/licenses/LICENSE-2.0                         -->
-<!--                                                                        -->
-<!-- Unless required by applicable law or agreed to in writing, software    -->
-<!-- distributed under the License is distributed on an "AS IS" BASIS,      -->
-<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        -->
-<!-- implied. See the License for the specific language governing           -->
-<!-- permissions and limitations under the License.                         -->
-<!--                                                                        -->
-<!-- IBM_PROLOG_END_TAG                                                     -->
-<attributes>
-
-<!-- =====================================================================
-     Contains the definition of attributes that are only available on
-     openpower systems.  This file is only compiled when
-     CONFIG_XML_INCLUDE_OPENPOWER is set to true and is always false on
-     FSP based systems.
-     =====================================================================
--->
-
-
-</attributes>
diff --git a/src/usr/targeting/common/xmltohb/attribute_types_oppowervm.xml b/src/usr/targeting/common/xmltohb/attribute_types_oppowervm.xml
new file mode 100644
index 0000000..cce48d2
--- /dev/null
+++ b/src/usr/targeting/common/xmltohb/attribute_types_oppowervm.xml
@@ -0,0 +1,798 @@
+<!-- IBM_PROLOG_BEGIN_TAG                                                   -->
+<!-- This is an automatically generated prolog.                             -->
+<!--                                                                        -->
+<!-- $Source: src/usr/targeting/common/xmltohb/attribute_types_oppowervm.xml $ -->
+<!--                                                                        -->
+<!-- OpenPOWER HostBoot Project                                             -->
+<!--                                                                        -->
+<!-- Contributors Listed Below - COPYRIGHT 2016                             -->
+<!-- [+] International Business Machines Corp.                              -->
+<!--                                                                        -->
+<!--                                                                        -->
+<!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
+<!-- you may not use this file except in compliance with the License.       -->
+<!-- You may obtain a copy of the License at                                -->
+<!--                                                                        -->
+<!--     http://www.apache.org/licenses/LICENSE-2.0                         -->
+<!--                                                                        -->
+<!-- Unless required by applicable law or agreed to in writing, software    -->
+<!-- distributed under the License is distributed on an "AS IS" BASIS,      -->
+<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        -->
+<!-- implied. See the License for the specific language governing           -->
+<!-- permissions and limitations under the License.                         -->
+<!--                                                                        -->
+<!-- IBM_PROLOG_END_TAG                                                     -->
+<attributes>
+
+<!-- =====================================================================
+     Contains the definition of attributes that are only available on
+     openpower systems.  This file is only compiled when
+     CONFIG_XML_INCLUDE_OPENPOWER is set to true and is always false on
+     FSP based systems.
+     =====================================================================
+-->
+
+<attribute>
+    <id>ICACHE_LINE_SIZE</id>
+    <description>Icache Line Size in bytes</description>
+    <simpleType>
+        <uint32_t>
+            <default>128</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>ICACHE_BLOCK_SIZE</id>
+    <description>ICache Block Size in bytes</description>
+    <simpleType>
+        <uint32_t>
+            <default>128</default>
+       </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>ICACHE_SIZE</id>
+    <description>ICache Size in KB</description>
+    <simpleType>
+        <uint32_t>
+            <default>32</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>ICACHE_ASSOC_SETS</id>
+    <description>ICache Assoc Sets</description>
+    <simpleType>
+        <uint32_t>
+            <default>4</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>DCACHE_LINE_SIZE</id>
+    <description>DCache Line Size in bytes</description>
+    <simpleType>
+        <uint32_t>
+            <default>128</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>DCACHE_ASSOC_SETS</id>
+    <description>DCache Associative Sets</description>
+    <simpleType>
+        <uint32_t>
+            <default>8</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>L2_CACHE_LINE_SIZE</id>
+    <description>L2 Cache Line Size in bytes</description>
+    <simpleType>
+        <uint32_t>
+            <default>128</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>L2_CACHE_SIZE</id>
+    <description>L2 Cache Size in KB</description>
+    <simpleType>
+        <uint32_t>
+            <default>512</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>L2_CACHE_ASSOC_SETS</id>
+    <description>L2 Cache Assoc Sets</description>
+    <simpleType>
+        <uint32_t>
+            <default>8</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>L3_CACHE_LINE_SIZE</id>
+    <description>L3 Cache Line Size in bytes</description>
+    <simpleType>
+        <uint32_t>
+            <default>128</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>L3_CACHE_SIZE</id>
+    <description>L3 Cache Size in KB</description>
+    <simpleType>
+        <uint32_t>
+            <default>8192</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+ </attribute>
+
+ <attribute>
+     <id>TIME_BASE</id>
+     <description>Time Base frequency in MHZ</description>
+     <simpleType>
+         <uint32_t>
+            <default>0x800000</default>
+        </uint32_t>
+     </simpleType>
+     <persistency>non-volatile</persistency>
+     <readable/>
+</attribute>
+
+<attribute>
+    <id>TLB_DATA_ENTRIES</id>
+    <description>TLB Data Entries</description>
+    <simpleType>
+        <uint32_t>
+            <default>2048</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>TLB_DATA_ASSOC_SETS</id>
+    <description>TLB Data Associative Sets</description>
+    <simpleType>
+        <uint32_t>
+            <default>4</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>TLB_INSTR_ENTRIES</id>
+    <description>TLB Instruction Entries</description>
+    <simpleType>
+        <uint32_t>
+            <default>0</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>TLB_INSTR_ASSOC_SETS</id>
+    <description>TLB Instruction Associative Sets</description>
+    <simpleType>
+        <uint32_t>
+            <default>0</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>TLB_RESERVE_SIZE</id>
+    <description>Reserve Size in bytes</description>
+    <simpleType>
+        <uint32_t>
+            <default>128</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>DATA_CACHE_SIZE</id>
+    <description>Data Cache Size in KB</description>
+    <simpleType>
+        <uint32_t>
+            <default>64</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>DATA_CACHE_LINE_SIZE</id>
+    <description>Data Cache Line Size in bytes</description>
+    <simpleType>
+        <uint32_t>
+            <default>128</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>THREAD_COUNT</id>
+    <description>Thread Count</description>
+    <simpleType>
+        <uint32_t>
+            <default>0x8</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>PROC_HW_TOPOLOGY</id>
+    <description>Hardware topology for HDAT
+        creator:MRW
+        consumer:HDAT
+        firmware notes:
+        Hardware Topology 2 Bytes
+        Byte 1:
+            bit 0-3: Node Id
+            bit 4-7: Socket id inside the node
+            bit 8-11: Proc id inside socket
+            bit 12-15:Hub Id inside proc
+    </description>
+    <simpleType>
+        <uint16_t>
+        </uint16_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
+    <id>ORDINAL_ID</id>
+    <description>Ordinal ID of a target</description>
+    <simpleType>
+        <uint32_t>
+            <default>0xFFFFFFFF</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>CPU_ATTR</id>
+    <description>CPU Attribute</description>
+    <simpleType>
+        <uint32_t>
+            <default>0x0000001D</default>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<enumerationType>
+    <id>CHIP_VER</id>
+    <description>Enumeration indicating the chip version</description>
+    <enumerator>
+        <name>DD10</name>
+        <value>0x10</value>
+    </enumerator>
+    <enumerator>
+        <name>DD11</name>
+        <value>0x11</value>
+    </enumerator>
+    <enumerator>
+        <name>DD20</name>
+        <value>0x20</value>
+    </enumerator>
+    <enumerator>
+        <name>DD21</name>
+        <value>0x21</value>
+    </enumerator>
+    <default>DD10</default>
+</enumerationType>
+
+<enumerationType>
+    <id>HW_VER</id>
+    <description>Enumeration indicating the chip HW version</description>
+    <enumerator>
+        <name>FSP_HW_VER</name>
+        <value>0x2</value>
+    </enumerator>
+    <enumerator>
+        <name>BMC_HW_VER</name>
+        <value>0x3</value>
+    </enumerator>
+    <default>BMC_HW_VER</default>
+</enumerationType>
+
+<enumerationType>
+    <id>SW_VER</id>
+    <description>Enumeration indicating the SW version</description>
+    <enumerator>
+        <name>FSP_SW_VER</name>
+        <value>0x1</value>
+    </enumerator>
+    <enumerator>
+        <name>BMC_SW_VER</name>
+        <value>0x2</value>
+    </enumerator>
+    <default>BMC_SW_VER</default>
+</enumerationType>
+
+<enumerationType>
+    <id>ROLE</id>
+    <description>Enumeration indicating the master's FSI type</description>
+    <enumerator>
+        <name>PRIMARY</name>
+        <value>1</value>
+    </enumerator>
+    <enumerator>
+        <name>BACKUP</name>
+        <value>0</value>
+    </enumerator>
+    <default>PRIMARY</default>
+</enumerationType>
+
+<attribute>
+    <id>CHIP_VER</id>
+    <description>Attribute indicating the target's chip version</description>
+    <simpleType>
+        <enumeration>
+            <id>CHIP_VER</id>
+        </enumeration>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+    <hasStringConversion/>
+</attribute>
+
+<attribute>
+    <id>HW_VER</id>
+    <description>Attribute indicating the target's hw version</description>
+    <simpleType>
+        <enumeration>
+            <id>HW_VER</id>
+        </enumeration>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+    <hasStringConversion/>
+</attribute>
+
+<attribute>
+    <id>SW_VER</id>
+    <description>Attribute indicating the target's software version</description>
+    <simpleType>
+        <enumeration>
+            <id>SW_VER</id>
+        </enumeration>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+    <hasStringConversion/>
+</attribute>
+
+<attribute>
+    <id>ROLE</id>
+    <description>Attribute indicating the target's role</description>
+    <simpleType>
+        <enumeration>
+            <id>ROLE</id>
+        </enumeration>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+    <hasStringConversion/>
+</attribute>
+
+<attribute>
+    <id>PHYP_SYSTEM_TYPE</id>
+    <description>PHYP system type value for habanero
+            and barreleye (0x3015 and 0x3016 respectively).
+            The value is updated in the system xml.
+    </description>
+    <simpleType>
+        <uint32_t>
+        </uint32_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>ASCII_VPD_LX_KEYWORD</id>
+    <description>LX keyword VPD data for HDAT module
+    </description>
+    <simpleType>
+        <uint64_t>
+        </uint64_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>ENLARGED_IO_SLOT_COUNT</id>
+    <description>
+        User configuration for Enlarged IO SLot Count
+    </description>
+    <simpleType>
+        <uint8_t>
+        </uint8_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>CREATE_DEF_PARTITION</id>
+    <description>
+        User configuration for creating default partition
+    </description>
+    <simpleType>
+        <uint8_t>
+        </uint8_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+   <id>IPL_ATTRIBUTES</id>
+   <description>
+       Assorted list of differnt IPL attributes passed via HDAT
+   </description>
+   <complexType>
+        <description>struct - 8 booleans </description>
+        <field>
+            <name>createDefaultPartition</name>
+            <description>
+             0b0: Dont create default partition;
+             0b1: Create default partition;
+            </description>
+            <type>uint8_t</type>
+            <bits>1</bits>
+            <default>0</default>
+        </field>
+        <field>
+            <name>clickToAcceptState</name>
+            <description>
+             0b0: Customer has not accepted license agreement;
+             0b1: Customer has accepted license agreement;
+            </description>
+            <type>uint8_t</type>
+            <bits>1</bits>
+            <default>0</default>
+        </field>
+        <field>
+            <name>disableVirtIO</name>
+            <description>
+             0b0: Enable Virtual IO Connections between partitions;
+             0b1: Disable Virtual IO Connections between partitions;
+            </description>
+            <type>uint8_t</type>
+            <bits>1</bits>
+            <default>0</default>
+        </field>
+        <field>
+            <name>resetPCINumbers</name>
+            <description>
+             0b0: Do not reset PCI Numbers;
+             0b1: Reset PCI Numbers;
+            </description>
+            <type>uint8_t</type>
+            <bits>1</bits>
+            <default>0</default>
+        </field>
+        <field>
+            <name>clearHypNVRAM</name>
+            <description>
+             0b0: Do not clear HYP NVRAM;
+             0b1: Clear HYP NVRAM;
+            </description>
+            <type>uint8_t</type>
+            <bits>1</bits>
+            <default>0</default>
+        </field>
+        <field>
+            <name>deleteHYPSELs</name>
+            <description>
+             0b0: Do not delete SELs originating from HYP;
+             0b1: Delete SELs originating from HYP;
+            </description>
+            <type>uint8_t</type>
+            <bits>1</bits>
+            <default>0</default>
+        </field>
+        <field>
+            <name>deleteHBSELs</name>
+            <description>
+             0b0: Do not delete SELs originating from Hostboot;
+             0b1: Delete SELs originating from Hostboot;
+            </description>
+            <type>uint8_t</type>
+            <bits>1</bits>
+            <default>0</default>
+        </field>
+        <field>
+            <name>deleteBMCSELs</name>
+            <description>
+             0b0: Do not delete SELs originating from BMC;
+             0b1: Delete SELs originating from BMC;
+            </description>
+            <type>uint8_t</type>
+            <bits>1</bits>
+            <default>0</default>
+        </field>
+   </complexType>
+   <persistency>volatile-zeroed</persistency>
+   <readable/>
+   <writeable/>
+</attribute>
+
+<attribute>
+    <id>PRESERVE_MDC_PARTITION_VPD</id>
+    <description>
+        MFG setting to preserve MDC partition vpd
+    </description>
+    <simpleType>
+        <uint8_t>
+        </uint8_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>HYPERVISOR_IPL_SIDE</id>
+    <description>
+       Platform IPL Side
+    </description>
+    <simpleType>
+        <uint8_t>
+        </uint8_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>OS_IPL_MODE</id>
+    <description>
+       Operating System IPL Mode
+    </description>
+    <simpleType>
+        <uint8_t>
+        </uint8_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>LMB_SIZE</id>
+    <description>
+       Logical Memory Block Size
+    </description>
+    <simpleType>
+        <uint8_t>
+        </uint8_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>MAX_HSL_OPTICONNECT_CONNECTIONS</id>
+    <description>
+        User configuration for max HSL Opticonnect connections
+    </description>
+    <simpleType>
+        <uint8_t>
+        </uint8_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>HUGE_PAGE_COUNT</id>
+    <description>
+       Huge Memory Page Count
+    </description>
+    <simpleType>
+        <uint16_t>
+        </uint16_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>HUGE_PAGE_SIZE</id>
+    <description>
+       Huge Memory Page Size
+    </description>
+    <simpleType>
+        <uint8_t>
+        </uint8_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>VLAN_SWITCHES</id>
+    <description>
+       Number of VLAN Switches
+    </description>
+    <simpleType>
+        <uint8_t>
+        </uint8_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>VTPM_ENABLED</id>
+    <description>
+       Virtual TPM Enabled
+    </description>
+    <simpleType>
+        <uint8_t>
+        </uint8_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>HYPERVISOR_IPL_DESTINATION</id>
+    <description>
+      Hypervisor IPL Destination
+    </description>
+    <simpleType>
+    <uint8_t>
+    </uint8_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>RAW_MTM</id>
+    <description>
+       Raw value of system MTM
+    </description>
+    <simpleType>
+    <string>
+      <sizeInclNull>64</sizeInclNull>
+    </string>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>HYP_DISPATCH_WHEEL</id>
+    <description>
+       Hypervisor Dispatch Wheel
+    </description>
+    <simpleType>
+        <uint8_t>
+        </uint8_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>SYSTEM_BRAND_NAME</id>
+    <description>
+       Brand Name of OEM systems
+    </description>
+    <simpleType>
+     <string>
+        <sizeInclNull>64</sizeInclNull>
+     </string>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>SLCA_INDEX</id>
+    <description>
+       SLCA index for this FRU
+    </description>
+    <simpleType>
+        <uint32_t>
+        </uint32_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+<attribute>
+    <id>SLCA_RID</id>
+    <description>
+       SLCA RID for this FRU
+    </description>
+    <simpleType>
+        <uint32_t>
+        </uint32_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+</attribute>
+
+</attributes>
diff --git a/src/usr/targeting/common/xmltohb/target_types.xml b/src/usr/targeting/common/xmltohb/target_types.xml
index 388b078..6dcf4a4 100644
--- a/src/usr/targeting/common/xmltohb/target_types.xml
+++ b/src/usr/targeting/common/xmltohb/target_types.xml
@@ -318,6 +318,8 @@
     <attribute><id>SBE_MASTER_INTR_SERVICE_DELAY_US</id></attribute>
     <attribute><id>CLEAR_DIMM_SPD_ENABLE</id></attribute>
     <attribute><id>MRW_MCS_PREFETCH_RETRY_THRESHOLD</id></attribute>
+    <attribute><id>HDAT_HBRT_NUM_SECTIONS</id></attribute>
+    <attribute><id>HDAT_HBRT_SECTION_SIZE</id></attribute>
 </targetType>
 
 <targetType>
@@ -545,6 +547,7 @@
     <attribute><id>PROC_R_LOADLINE_VCS</id></attribute>
     <attribute><id>PROC_R_DISTLOSS_VCS</id></attribute>
     <attribute><id>PROC_VRM_VOFFSET_VCS</id></attribute>
+    <attribute><id>TOD_CPU_DATA</id></attribute>
 </targetType>
 
 <targetType>
@@ -1845,4 +1848,128 @@
     </attribute>
 </targetType>
 
+<targetType>
+    <id>uart</id>
+    <parent>unit</parent>
+    <attribute>
+        <id>CLASS</id>
+        <default>UNIT</default>
+    </attribute>
+    <attribute>
+        <id>TYPE</id>
+        <default>UART</default>
+    </attribute>
+</targetType>
+
+<targetType>
+    <id>sp</id>
+    <parent>chip</parent>
+    <attribute>
+        <id>CLASS</id>
+        <default>CHIP</default>
+    </attribute>
+    <attribute>
+        <id>TYPE</id>
+        <default>SP</default>
+    </attribute>
+</targetType>
+
+<targetType>
+    <id>bmc</id>
+    <parent>sp</parent>
+    <attribute>
+        <id>TYPE</id>
+        <default>SP</default>
+    </attribute>
+    <attribute>
+        <id>MODEL</id>
+        <default>BMC</default>
+    </attribute>
+    <attribute>
+        <id>HWAS_STATE</id>
+        <default>
+            <field><id>deconfiguredByEid</id><value>0</value></field>
+            <field><id>poweredOn</id><value>1</value></field>
+            <field><id>present</id><value>1</value></field>
+            <field><id>functional</id><value>1</value></field>
+            <field><id>dumpfunctional</id><value>0</value></field>
+            <field><id>specdeconfig</id><value>0</value></field>
+        </default>
+    </attribute>
+</targetType>
+
+<targetType>
+    <id>power-supply</id>
+    <parent>unit</parent>
+    <attribute>
+        <id>CLASS</id>
+        <default>UNIT</default>
+    </attribute>
+    <attribute>
+        <id>TYPE</id>
+        <default>PS</default>
+    </attribute>
+</targetType>
+
+<targetType>
+    <id>fan</id>
+    <parent>unit</parent>
+    <attribute>
+        <id>CLASS</id>
+        <default>UNIT</default>
+    </attribute>
+    <attribute>
+        <id>TYPE</id>
+        <default>FAN</default>
+    </attribute>
+</targetType>
+
+<targetType>
+    <id>vrm</id>
+    <parent>unit</parent>
+    <attribute>
+        <id>CLASS</id>
+        <default>UNIT</default>
+    </attribute>
+    <attribute>
+        <id>TYPE</id>
+        <default>VRM</default>
+    </attribute>
+</targetType>
+
+<targetType>
+    <id>usb</id>
+    <parent>unit</parent>
+    <attribute>
+        <id>CLASS</id>
+        <default>UNIT</default>
+    </attribute>
+    <attribute>
+        <id>TYPE</id>
+        <default>USB</default>
+    </attribute>
+</targetType>
+
+<targetType>
+    <id>eth</id>
+    <parent>unit</parent>
+    <attribute>
+        <id>CLASS</id>
+        <default>UNIT</default>
+    </attribute>
+    <attribute>
+        <id>TYPE</id>
+        <default>ETH</default>
+    </attribute>
+</targetType>
+
+<targetType>
+    <id>panel</id>
+    <parent>unit</parent>
+    <attribute>
+        <id>TYPE</id>
+        <default>PANEL</default>
+    </attribute>
+</targetType>
+
 </attributes>
diff --git a/src/usr/targeting/common/xmltohb/target_types_openpower.xml b/src/usr/targeting/common/xmltohb/target_types_openpower.xml
deleted file mode 100644
index ebe3964..0000000
--- a/src/usr/targeting/common/xmltohb/target_types_openpower.xml
+++ /dev/null
@@ -1,36 +0,0 @@
-<!-- IBM_PROLOG_BEGIN_TAG                                                   -->
-<!-- This is an automatically generated prolog.                             -->
-<!--                                                                        -->
-<!-- $Source: src/usr/targeting/common/xmltohb/target_types_openpower.xml $ -->
-<!--                                                                        -->
-<!-- OpenPOWER HostBoot Project                                             -->
-<!--                                                                        -->
-<!-- Contributors Listed Below - COPYRIGHT 2016                             -->
-<!-- [+] International Business Machines Corp.                              -->
-<!--                                                                        -->
-<!--                                                                        -->
-<!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
-<!-- you may not use this file except in compliance with the License.       -->
-<!-- You may obtain a copy of the License at                                -->
-<!--                                                                        -->
-<!--     http://www.apache.org/licenses/LICENSE-2.0                         -->
-<!--                                                                        -->
-<!-- Unless required by applicable law or agreed to in writing, software    -->
-<!-- distributed under the License is distributed on an "AS IS" BASIS,      -->
-<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        -->
-<!-- implied. See the License for the specific language governing           -->
-<!-- permissions and limitations under the License.                         -->
-<!--                                                                        -->
-<!-- IBM_PROLOG_END_TAG                                                     -->
-<attributes>
-
-<!-- =====================================================================
-     Contains the target definition of attributes that are only available
-     on openpower systems.  This file is only compiled when
-     CONFIG_XML_INCLUDE_OPENPOWER is set to true and is always false on
-     FSP based systems.
-     =====================================================================
- -->
-
-
-</attributes>
diff --git a/src/usr/targeting/common/xmltohb/target_types_oppowervm.xml b/src/usr/targeting/common/xmltohb/target_types_oppowervm.xml
new file mode 100644
index 0000000..9274ac9
--- /dev/null
+++ b/src/usr/targeting/common/xmltohb/target_types_oppowervm.xml
@@ -0,0 +1,193 @@
+<!-- IBM_PROLOG_BEGIN_TAG                                                   -->
+<!-- This is an automatically generated prolog.                             -->
+<!--                                                                        -->
+<!-- $Source: src/usr/targeting/common/xmltohb/target_types_oppowervm.xml $ -->
+<!--                                                                        -->
+<!-- OpenPOWER HostBoot Project                                             -->
+<!--                                                                        -->
+<!-- Contributors Listed Below - COPYRIGHT 2016                             -->
+<!-- [+] International Business Machines Corp.                              -->
+<!--                                                                        -->
+<!--                                                                        -->
+<!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
+<!-- you may not use this file except in compliance with the License.       -->
+<!-- You may obtain a copy of the License at                                -->
+<!--                                                                        -->
+<!--     http://www.apache.org/licenses/LICENSE-2.0                         -->
+<!--                                                                        -->
+<!-- Unless required by applicable law or agreed to in writing, software    -->
+<!-- distributed under the License is distributed on an "AS IS" BASIS,      -->
+<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        -->
+<!-- implied. See the License for the specific language governing           -->
+<!-- permissions and limitations under the License.                         -->
+<!--                                                                        -->
+<!-- IBM_PROLOG_END_TAG                                                     -->
+<attributes>
+
+<!-- =====================================================================
+     Contains the target definition of attributes that are only available
+     on openpower systems.  This file is only compiled when
+     CONFIG_XML_INCLUDE_OPENPOWER is set to true and is always false on
+     FSP based systems.
+     =====================================================================
+ -->
+
+<targetTypeExtension>
+    <id>base</id>
+    <attribute><id>ORDINAL_ID</id></attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
+    <id>sys-sys-power8</id>
+    <attribute><id>THREAD_COUNT</id></attribute>
+    <attribute><id>SERIAL_NUMBER</id></attribute>
+    <attribute><id>PHYP_SYSTEM_TYPE</id></attribute>
+    <attribute><id>ASCII_VPD_LX_KEYWORD</id></attribute>
+    <attribute><id>IPL_ATTRIBUTES</id></attribute>
+    <attribute><id>PRESERVE_MDC_PARTITION_VPD</id></attribute>
+    <attribute><id>HYPERVISOR_IPL_SIDE</id><default>0</default></attribute>
+    <attribute><id>OS_IPL_MODE</id></attribute>
+    <attribute><id>LMB_SIZE</id></attribute>
+    <attribute><id>MAX_HSL_OPTICONNECT_CONNECTIONS</id></attribute>
+    <attribute><id>HUGE_PAGE_COUNT</id></attribute>
+    <attribute><id>HUGE_PAGE_SIZE</id></attribute>
+    <attribute><id>VLAN_SWITCHES</id></attribute>
+    <attribute><id>VTPM_ENABLED</id></attribute>
+    <attribute><id>HYP_DISPATCH_WHEEL</id></attribute>
+    <attribute><id>SYSTEM_BRAND_NAME</id></attribute>
+    <attribute><id>HYPERVISOR_IPL_DESTINATION</id></attribute>
+    <attribute><id>RAW_MTM</id></attribute>
+    <attribute><id>SLCA_INDEX</id></attribute>
+    <attribute><id>SLCA_RID</id></attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
+    <id>chip-processor</id>
+    <attribute><id>ICACHE_LINE_SIZE</id></attribute>
+    <attribute><id>ICACHE_BLOCK_SIZE</id></attribute>
+    <attribute><id>ICACHE_SIZE</id></attribute>
+    <attribute><id>ICACHE_ASSOC_SETS</id></attribute>
+    <attribute><id>DCACHE_LINE_SIZE</id></attribute>
+    <attribute><id>DCACHE_ASSOC_SETS</id></attribute>
+    <attribute><id>DATA_CACHE_SIZE</id></attribute>
+    <attribute><id>DATA_CACHE_LINE_SIZE</id></attribute>
+    <attribute><id>L2_CACHE_LINE_SIZE</id></attribute>
+    <attribute><id>L2_CACHE_SIZE</id></attribute>
+    <attribute><id>L2_CACHE_ASSOC_SETS</id></attribute>
+    <attribute><id>L3_CACHE_LINE_SIZE</id></attribute>
+    <attribute><id>L3_CACHE_SIZE</id></attribute>
+    <attribute><id>TIME_BASE</id></attribute>
+    <attribute><id>TLB_DATA_ENTRIES</id></attribute>
+    <attribute><id>TLB_INSTR_ENTRIES</id></attribute>
+    <attribute><id>TLB_DATA_ASSOC_SETS</id></attribute>
+    <attribute><id>TLB_INSTR_ASSOC_SETS</id></attribute>
+    <attribute><id>TLB_RESERVE_SIZE</id></attribute>
+    <attribute><id>CPU_ATTR</id></attribute>
+    <attribute>
+        <id>PROC_HW_TOPOLOGY</id>
+        <default>0x00000000</default>
+    </attribute>
+    <attribute>
+        <id>SLCA_INDEX</id>
+        <default>0x00000000</default>
+    </attribute>
+    <attribute>
+        <id>SLCA_RID</id>
+        <default>0x00001000</default>
+    </attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
+    <id>sp</id>
+    <attribute><id>CHIP_VER</id></attribute>
+    <attribute><id>CHIP_ID</id></attribute>
+    <attribute><id>HW_VER</id></attribute>
+    <attribute><id>SW_VER</id></attribute>
+    <attribute><id>ROLE</id></attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
+    <id>bmc</id>
+    <attribute><id>CHIP_VER</id></attribute>
+    <attribute><id>CHIP_ID</id><default>0</default></attribute>
+    <attribute><id>SLCA_INDEX</id></attribute>
+    <attribute><id>SLCA_RID</id></attribute>
+    <attribute><id>HW_VER</id></attribute>
+    <attribute><id>SW_VER</id></attribute>
+    <attribute><id>ROLE</id></attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
+    <id>lcard-dimm</id>
+    <attribute><id>SLCA_INDEX</id></attribute>
+    <attribute><id>SLCA_RID</id></attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
+    <id>unit-pci-power8</id>
+    <attribute><id>SLCA_INDEX</id></attribute>
+    <attribute><id>SLCA_RID</id></attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
+    <id>enc-node-power8</id>
+    <attribute><id>ENLARGED_IO_SLOT_COUNT</id></attribute>
+    <attribute><id>SLCA_INDEX</id></attribute>
+    <attribute><id>SLCA_RID</id></attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
+    <id>chip-membuf-centaur</id>
+    <attribute><id>SLCA_INDEX</id></attribute>
+    <attribute><id>SLCA_RID</id></attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
+    <id>uart</id>
+    <attribute><id>SLCA_INDEX</id></attribute>
+    <attribute><id>SLCA_RID</id></attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
+    <id>sp</id>
+    <attribute><id>SLCA_INDEX</id></attribute>
+    <attribute><id>SLCA_RID</id></attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
+    <id>power-supply</id>
+    <attribute><id>SLCA_INDEX</id></attribute>
+    <attribute><id>SLCA_RID</id></attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
+    <id>fan</id>
+    <attribute><id>SLCA_INDEX</id></attribute>
+    <attribute><id>SLCA_RID</id></attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
+    <id>vrm</id>
+    <attribute><id>SLCA_INDEX</id></attribute>
+    <attribute><id>SLCA_RID</id></attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
+    <id>usb</id>
+    <attribute><id>SLCA_INDEX</id></attribute>
+    <attribute><id>SLCA_RID</id></attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
+    <id>eth</id>
+    <attribute><id>SLCA_INDEX</id></attribute>
+    <attribute><id>SLCA_RID</id></attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
+    <id>panel</id>
+    <attribute><id>SLCA_INDEX</id></attribute>
+    <attribute><id>SLCA_RID</id></attribute>
+</targetTypeExtension>
+
+</attributes>
diff --git a/src/usr/targeting/xmltohb/makefile b/src/usr/targeting/xmltohb/makefile
index 0885044..019e2ac 100644
--- a/src/usr/targeting/xmltohb/makefile
+++ b/src/usr/targeting/xmltohb/makefile
@@ -57,8 +57,8 @@ XMLTOHB_HB_ATTRIBUTE_SOURCES            = attribute_types_hb.xml
 XMLTOHB_HB_TARGET_SOURCES               = target_types_hb.xml
 
 # attribute files that are only included in openpower build.
-XMLTOHB_OPENPOWER_ATTRIBUTE_SOURCES     = attribute_types_openpower.xml
-XMLTOHB_OPENPOWER_TARGET_SOURCES        = target_types_openpower.xml
+XMLTOHB_OPENPOWER_ATTRIBUTE_SOURCES     = attribute_types_oppowervm.xml
+XMLTOHB_OPENPOWER_TARGET_SOURCES        = target_types_oppowervm.xml
 
 XMLTOHB_MERGED_COMMON_TARGET_SOURCES    = target_types_merged.xml
 
@@ -68,15 +68,15 @@ XMLTOHB_MERGED_COMMON_TARGET_SOURCES    = target_types_merged.xml
 XMLTOHB_CUSTOMIZE_TARGET_SOURCES        = target_types_customize.xml
 
 XMLTOHB_TARGET_SOURCES += target_types_hb.xml
-XMLTOHB_TARGET_SOURCES += $(if $(CONFIG_INCLUDE_OPENPOWER_XML), target_types_openpower.xml)
+XMLTOHB_TARGET_SOURCES += $(if $(CONFIG_INCLUDE_XML_OPENPOWER), target_types_oppowervm.xml)
 
 #Define XMLTOHB_GENERIC_SOURCES
 XMLTOHB_GENERIC_SOURCES += ${XMLTOHB_COMMON_ATTRIBUTE_SOURCES}
 XMLTOHB_GENERIC_SOURCES += ${XMLTOHB_HB_ATTRIBUTE_SOURCES}
-XMLTOHB_GENERIC_SOURCES += $(if $(CONFIG_INCLUDE_OPENPOWER_XML),${XMLTOHB_OPENPOWER_ATTRIBUTE_SOURCES})
+XMLTOHB_GENERIC_SOURCES += $(if $(CONFIG_INCLUDE_XML_OPENPOWER),${XMLTOHB_OPENPOWER_ATTRIBUTE_SOURCES})
 XMLTOHB_GENERIC_SOURCES += ${GENDIR}/${XMLTOHB_MERGED_COMMON_TARGET_SOURCES}
 XMLTOHB_GENERIC_SOURCES += ${XMLTOHB_HB_TARGET_SOURCES}
-XMLTOHB_GENERIC_SOURCES += $(if $(CONFIG_INCLUDE_OPENPOWER_XML),${XMLTOHB_OPENPOWER_TARGET_SOURCES})
+XMLTOHB_GENERIC_SOURCES += $(if $(CONFIG_INCLUDE_XML_OPENPOWER),${XMLTOHB_OPENPOWER_TARGET_SOURCES})
 
 #XML target types merge script
 XMLTOHB_TARGET_MERGE_SCRIPT = updatetargetxml.pl
diff --git a/src/usr/vpd/pvpd.H b/src/usr/vpd/pvpd.H
index 092dd45..3267950 100644
--- a/src/usr/vpd/pvpd.H
+++ b/src/usr/vpd/pvpd.H
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2013,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2013,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -103,6 +103,7 @@ namespace PVPD
         { VP,  "VP" },
         { VS,  "VS" },
         { VZ,  "VZ" },
+        { LX,  "LX" },
 
         // -------------------------------------------------------------------
         // DO NOT USE!!  This is for test purposes ONLY!
-- 
2.9.2


From 8289a039f7d1454614787564c49c3fd8cfcf110a Mon Sep 17 00:00:00 2001
From: Elizabeth Liner <eliner@us.ibm.com>
Date: Fri, 9 Sep 2016 11:12:06 -0500
Subject: [PATCH 04/20] Adding support for an openpower only attribute file

Change-Id: If2a902012349fc36502aaa5779383ebf925cf2ab
Forwardport:yes
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/29427
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Reviewed-by: Martin Gloff <mgloff@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Reviewed-by: Daniel M. Crowell <dcrowell@us.ibm.com>
---
 src/HBconfig                                       |  9 +++++-
 src/build/mkrules/dist.targets.mk                  |  6 ++--
 .../common/xmltohb/attribute_types_openpower.xml   | 35 ++++++++++++++++++++++
 .../common/xmltohb/attribute_types_oppowervm.xml   |  4 +--
 .../common/xmltohb/target_types_openpower.xml      | 35 ++++++++++++++++++++++
 .../common/xmltohb/target_types_oppowervm.xml      |  4 +--
 src/usr/targeting/xmltohb/makefile                 | 19 ++++++++----
 7 files changed, 99 insertions(+), 13 deletions(-)
 create mode 100644 src/usr/targeting/common/xmltohb/attribute_types_openpower.xml
 create mode 100644 src/usr/targeting/common/xmltohb/target_types_openpower.xml

diff --git a/src/HBconfig b/src/HBconfig
index 703e95e..0f9000d 100644
--- a/src/HBconfig
+++ b/src/HBconfig
@@ -14,9 +14,16 @@ config ROM_CODE_PRESENT
     help
         Indicates that ROM code is available to call
 
-config INCLUDE_XML_OPENPOWER
+config INCLUDE_XML_OPPOWERVM
     default n
     help
         Indicates that a build should include the contents
         of attribute_types_oppowervm.xml and
         target_types_oppowervm.xml
+
+config INCLUDE_XML_OPENPOWER
+    default n
+    help
+        Indicates that a build should include the contents
+        of attribute_types_openpower.xml and
+        target_types_openpower.xml
diff --git a/src/build/mkrules/dist.targets.mk b/src/build/mkrules/dist.targets.mk
index 9378b0a..700685c 100644
--- a/src/build/mkrules/dist.targets.mk
+++ b/src/build/mkrules/dist.targets.mk
@@ -93,8 +93,10 @@ COPY_FILES = \
     $(foreach file, $(call ROOTPATH_WILDCARD,releaseNotes.html), $(file):fsp)\
 
 include ${ROOTPATH}/config.mk
-COPY_FILES += $(if $(CONFIG_INCLUDE_XML_OPENPOWER),src/usr/targeting/common/xmltohb/target_types_oppowervm.xml:openpower) \
-    $(if $(CONFIG_INCLUDE_XML_OPENPOWER),src/usr/targeting/common/xmltohb/attribute_types_oppowervm.xml:openpower) \
+COPY_FILES += $(if $(CONFIG_INCLUDE_XML_OPPOWERVM),src/usr/targeting/common/xmltohb/target_types_oppowervm.xml:openpower) \
+    $(if $(CONFIG_INCLUDE_XML_OPPOWERVM),src/usr/targeting/common/xmltohb/attribute_types_oppowervm.xml:openpower) \
+    $(if $(CONFIG_INCLUDE_XML_OPENPOWER),src/usr/targeting/common/xmltohb/target_types_openpower.xml:openpower) \
+    $(if $(CONFIG_INCLUDE_XML_OPENPOWER),src/usr/targeting/common/xmltohb/attribute_types_openpower.xml:openpower) \
 
 #
 # Files which are copied and renamed for targets.
diff --git a/src/usr/targeting/common/xmltohb/attribute_types_openpower.xml b/src/usr/targeting/common/xmltohb/attribute_types_openpower.xml
new file mode 100644
index 0000000..e27aa1d
--- /dev/null
+++ b/src/usr/targeting/common/xmltohb/attribute_types_openpower.xml
@@ -0,0 +1,35 @@
+<!-- IBM_PROLOG_BEGIN_TAG                                                   -->
+<!-- This is an automatically generated prolog.                             -->
+<!--                                                                        -->
+<!-- $Source: src/usr/targeting/common/xmltohb/attribute_types_openpower.xml $ -->
+<!--                                                                        -->
+<!-- OpenPOWER HostBoot Project                                             -->
+<!--                                                                        -->
+<!-- Contributors Listed Below - COPYRIGHT 2016                             -->
+<!-- [+] International Business Machines Corp.                              -->
+<!--                                                                        -->
+<!--                                                                        -->
+<!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
+<!-- you may not use this file except in compliance with the License.       -->
+<!-- You may obtain a copy of the License at                                -->
+<!--                                                                        -->
+<!--     http://www.apache.org/licenses/LICENSE-2.0                         -->
+<!--                                                                        -->
+<!-- Unless required by applicable law or agreed to in writing, software    -->
+<!-- distributed under the License is distributed on an "AS IS" BASIS,      -->
+<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        -->
+<!-- implied. See the License for the specific language governing           -->
+<!-- permissions and limitations under the License.                         -->
+<!--                                                                        -->
+<!-- IBM_PROLOG_END_TAG                                                     -->
+<attributes>
+
+<!-- =====================================================================
+     Contains the definition of attributes that are only available on
+     openpower systems.  This file is only compiled when
+     CONFIG_XML_INCLUDE_OPENPOWER is set to true and is always false on
+     FSP based systems.
+     =====================================================================
+-->
+
+</attributes>
diff --git a/src/usr/targeting/common/xmltohb/attribute_types_oppowervm.xml b/src/usr/targeting/common/xmltohb/attribute_types_oppowervm.xml
index cce48d2..f54c2d2 100644
--- a/src/usr/targeting/common/xmltohb/attribute_types_oppowervm.xml
+++ b/src/usr/targeting/common/xmltohb/attribute_types_oppowervm.xml
@@ -26,8 +26,8 @@
 
 <!-- =====================================================================
      Contains the definition of attributes that are only available on
-     openpower systems.  This file is only compiled when
-     CONFIG_XML_INCLUDE_OPENPOWER is set to true and is always false on
+     openpower systems for a PowerVM build.  This file is only compiled when
+     CONFIG_XML_INCLUDE_OPPOWERVM is set to true and is always false on
      FSP based systems.
      =====================================================================
 -->
diff --git a/src/usr/targeting/common/xmltohb/target_types_openpower.xml b/src/usr/targeting/common/xmltohb/target_types_openpower.xml
new file mode 100644
index 0000000..625be4d
--- /dev/null
+++ b/src/usr/targeting/common/xmltohb/target_types_openpower.xml
@@ -0,0 +1,35 @@
+<!-- IBM_PROLOG_BEGIN_TAG                                                   -->
+<!-- This is an automatically generated prolog.                             -->
+<!--                                                                        -->
+<!-- $Source: src/usr/targeting/common/xmltohb/target_types_openpower.xml $ -->
+<!--                                                                        -->
+<!-- OpenPOWER HostBoot Project                                             -->
+<!--                                                                        -->
+<!-- Contributors Listed Below - COPYRIGHT 2016                             -->
+<!-- [+] International Business Machines Corp.                              -->
+<!--                                                                        -->
+<!--                                                                        -->
+<!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
+<!-- you may not use this file except in compliance with the License.       -->
+<!-- You may obtain a copy of the License at                                -->
+<!--                                                                        -->
+<!--     http://www.apache.org/licenses/LICENSE-2.0                         -->
+<!--                                                                        -->
+<!-- Unless required by applicable law or agreed to in writing, software    -->
+<!-- distributed under the License is distributed on an "AS IS" BASIS,      -->
+<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        -->
+<!-- implied. See the License for the specific language governing           -->
+<!-- permissions and limitations under the License.                         -->
+<!--                                                                        -->
+<!-- IBM_PROLOG_END_TAG                                                     -->
+<attributes>
+
+<!-- =====================================================================
+     Contains the target definition of attributes that are only available
+     on openpower systems.  This file is only compiled when
+     CONFIG_XML_INCLUDE_OPENPOWER is set to true and is always false on
+     FSP based systems.
+     =====================================================================
+ -->
+
+</attributes>
diff --git a/src/usr/targeting/common/xmltohb/target_types_oppowervm.xml b/src/usr/targeting/common/xmltohb/target_types_oppowervm.xml
index 9274ac9..33f5b85 100644
--- a/src/usr/targeting/common/xmltohb/target_types_oppowervm.xml
+++ b/src/usr/targeting/common/xmltohb/target_types_oppowervm.xml
@@ -26,8 +26,8 @@
 
 <!-- =====================================================================
      Contains the target definition of attributes that are only available
-     on openpower systems.  This file is only compiled when
-     CONFIG_XML_INCLUDE_OPENPOWER is set to true and is always false on
+     on openpower systems for a PowerVM build.  This file is only compiled when
+     CONFIG_XML_INCLUDE_OPPOWERVM is set to true and is always false on
      FSP based systems.
      =====================================================================
  -->
diff --git a/src/usr/targeting/xmltohb/makefile b/src/usr/targeting/xmltohb/makefile
index 019e2ac..1356e7b 100644
--- a/src/usr/targeting/xmltohb/makefile
+++ b/src/usr/targeting/xmltohb/makefile
@@ -56,26 +56,33 @@ XMLTOHB_COMMON_TARGET_SOURCES           = target_types.xml
 XMLTOHB_HB_ATTRIBUTE_SOURCES            = attribute_types_hb.xml
 XMLTOHB_HB_TARGET_SOURCES               = target_types_hb.xml
 
+# attribute files that are only included in power vm build.
+XMLTOHB_OPPOWERVM_ATTRIBUTE_SOURCES     = attribute_types_oppowervm.xml
+XMLTOHB_OPPOWERVM_TARGET_SOURCES        = target_types_oppowervm.xml
+
 # attribute files that are only included in openpower build.
-XMLTOHB_OPENPOWER_ATTRIBUTE_SOURCES     = attribute_types_oppowervm.xml
-XMLTOHB_OPENPOWER_TARGET_SOURCES        = target_types_oppowervm.xml
+XMLTOHB_OPENPOWER_ATTRIBUTE_SOURCES     = attribute_types_openpower.xml
+XMLTOHB_OPENPOWER_TARGET_SOURCES        = target_types_openpower.xml
 
 XMLTOHB_MERGED_COMMON_TARGET_SOURCES    = target_types_merged.xml
 
-# the customize target file combines all targetTypeExtension files before
+# The customize target file combines all targetTypeExtension files before
 # combining them with the common target_types.xml file. To include a new file,
-# just add it to XMLTOHB_TARGET_SOURCES.
+# just add it to the XMLTOHB_TARGET_SOURCES.
 XMLTOHB_CUSTOMIZE_TARGET_SOURCES        = target_types_customize.xml
 
-XMLTOHB_TARGET_SOURCES += target_types_hb.xml
-XMLTOHB_TARGET_SOURCES += $(if $(CONFIG_INCLUDE_XML_OPENPOWER), target_types_oppowervm.xml)
+XMLTOHB_TARGET_SOURCES += ${XMLTOHB_HB_TARGET_SOURCES}
+XMLTOHB_TARGET_SOURCES += $(if $(CONFIG_INCLUDE_XML_OPPOWERVM),${XMLTOHB_OPPOWERVM_TARGET_SOURCES})
+XMLTOHB_TARGET_SOURCES += $(if $(CONFIG_INCLUDE_XML_OPENPOWER),${XMLTOHB_OPENPOWER_TARGET_SOURCES})
 
 #Define XMLTOHB_GENERIC_SOURCES
 XMLTOHB_GENERIC_SOURCES += ${XMLTOHB_COMMON_ATTRIBUTE_SOURCES}
 XMLTOHB_GENERIC_SOURCES += ${XMLTOHB_HB_ATTRIBUTE_SOURCES}
+XMLTOHB_GENERIC_SOURCES += $(if $(CONFIG_INCLUDE_XML_OPPOWERVM),${XMLTOHB_OPPOWERVM_ATTRIBUTE_SOURCES})
 XMLTOHB_GENERIC_SOURCES += $(if $(CONFIG_INCLUDE_XML_OPENPOWER),${XMLTOHB_OPENPOWER_ATTRIBUTE_SOURCES})
 XMLTOHB_GENERIC_SOURCES += ${GENDIR}/${XMLTOHB_MERGED_COMMON_TARGET_SOURCES}
 XMLTOHB_GENERIC_SOURCES += ${XMLTOHB_HB_TARGET_SOURCES}
+XMLTOHB_GENERIC_SOURCES += $(if $(CONFIG_INCLUDE_XML_OPPOWERVM),${XMLTOHB_OPPOWERVM_TARGET_SOURCES})
 XMLTOHB_GENERIC_SOURCES += $(if $(CONFIG_INCLUDE_XML_OPENPOWER),${XMLTOHB_OPENPOWER_TARGET_SOURCES})
 
 #XML target types merge script
-- 
2.9.2


From 3ed4df70acbcf3927071ebd626d11e37f3656c38 Mon Sep 17 00:00:00 2001
From: Dan Crowell <dcrowell@us.ibm.com>
Date: Tue, 13 Sep 2016 10:28:21 -0500
Subject: [PATCH 05/20] Look for DEADBEEF response to handle missing scom
 return codes

The opal-prd application has a bug where a bad rc was not being
returned for scom errors.  This is a workaround to look for a
special data packet to indicate a failure.  This is needed until
the opal-prd package is updated across all distros.

Change-Id: I53fe20b0d2f14e606b9b16f1d9e9c1bf4c331840
CQ: SW366105
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/29598
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Reviewed-by: Daniel M. Crowell <dcrowell@us.ibm.com>
---
 src/include/runtime/interface.h           |  34 +++++-
 src/include/usr/xscom/xscomreasoncodes.H  |   5 +-
 src/usr/testcore/rtloader/loader.H        |  10 ++
 src/usr/xscom/runtime/rt_xscom.C          |  75 ++++++++++++-
 src/usr/xscom/runtime/test/testxscom_rt.H | 174 +++++++++++++++++-------------
 5 files changed, 221 insertions(+), 77 deletions(-)

diff --git a/src/include/runtime/interface.h b/src/include/runtime/interface.h
index e88a642..70f9e0d 100644
--- a/src/include/runtime/interface.h
+++ b/src/include/runtime/interface.h
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2013,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2013,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -80,6 +80,21 @@ enum MemoryError_t
 #define HBRT_I2C_MASTER_PORT_MASK         (0xfful)
 
 
+/**
+ * Specifiers for get_interface_capabilities
+ */
+
+/* Common Features */
+#define HBRT_CAPS_SET0_COMMON  0
+
+/* OPAL fixes */
+#define HBRT_CAPS_SET1_OPAL    1
+#define HBRT_CAPS_OPAL_HAS_XSCOM_RC     (1ul << 0)
+
+/* PHYP fixes */
+#define HBRT_CAPS_SET2_PHYP    2
+
+
 /** @typedef hostInterfaces_t
  *  @brief Interfaces provided by the underlying environment (ex. Sapphire).
  *
@@ -305,6 +320,23 @@ typedef struct hostInterfaces
                              MemoryError_t i_errorType );
 
 
+    /**
+     * @brief Query the HBRT host for a list of fixes/features
+     *
+     * There are times when workarounds need to be put into place to handle
+     * issues with the hosting layer (e.g. opal-prd) while fixes are not yet
+     * released.  This is especially true because of the disconnected release
+     * streams for the firmware and the hosting environment.
+     *
+     * @param  i_set Indicates which set of fixes/features we're checking
+     *               see HBRT_CAPS_SET...
+     *
+     * @return a bitmask containing the relevant flags for the current
+     *         implementation, see HBRT_CAPS_FLAGS_...
+     */
+    uint64_t (*get_interface_capabilities)( uint64_t i_set );
+
+
     // Reserve some space for future growth.
     // do NOT ever change this number, even if you add functions.
     //
diff --git a/src/include/usr/xscom/xscomreasoncodes.H b/src/include/usr/xscom/xscomreasoncodes.H
index 33fe9a7..db88bba 100644
--- a/src/include/usr/xscom/xscomreasoncodes.H
+++ b/src/include/usr/xscom/xscomreasoncodes.H
@@ -5,7 +5,9 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* COPYRIGHT International Business Machines Corp. 2011,2014              */
+/* Contributors Listed Below - COPYRIGHT 2011,2016                        */
+/* [+] International Business Machines Corp.                              */
+/*                                                                        */
 /*                                                                        */
 /* Licensed under the Apache License, Version 2.0 (the "License");        */
 /* you may not use this file except in compliance with the License.       */
@@ -50,6 +52,7 @@ namespace XSCOM
         XSCOM_MMIO_UNMAP_ERR       = XSCOM_COMP_ID | 0x05,
         XSCOM_RUNTIME_ERR          = XSCOM_COMP_ID | 0x06,
         XSCOM_RUNTIME_INTERFACE_ERR = XSCOM_COMP_ID | 0x07,
+        XSCOM_RUNTIME_ERR2         = XSCOM_COMP_ID | 0x08,
     };
 };
 
diff --git a/src/usr/testcore/rtloader/loader.H b/src/usr/testcore/rtloader/loader.H
index 1225d66..4b3e140 100644
--- a/src/usr/testcore/rtloader/loader.H
+++ b/src/usr/testcore/rtloader/loader.H
@@ -124,6 +124,7 @@ class RuntimeLoaderTest : public CxxTest::TestSuite
                 intf->pnor_read = rt_pnor_read;
                 intf->pnor_write= rt_pnor_write;
                 intf->ipmi_msg= rt_ipmi_msg;
+                intf->get_interface_capabilities=rt_get_interface_capabilities;
 
                 // Call init.
                 runtimeInterfaces_t* rtInterface =
@@ -207,6 +208,11 @@ class RuntimeLoaderTest : public CxxTest::TestSuite
             {
                 *data64 = it->second;
             }
+            else if( addr == 0x1234567887654321 )
+            {
+                // force special hack value for opal-prd bug
+                *data64 = 0xDEADBEEFDEADBEEF;
+            }
             else if( (addr & 0x00FFFFFF) == 0x0F0100)
             {
                 // force special wakeup done bit
@@ -555,6 +561,10 @@ class RuntimeLoaderTest : public CxxTest::TestSuite
             return l_plid;
         }
 
+        static uint64_t rt_get_interface_capabilities( uint64_t i_set )
+        {
+            return 0;
+        }
 
         static uint64_t cv_vpd_addr;
         static uint64_t cv_vpd_phys_addr;
diff --git a/src/usr/xscom/runtime/rt_xscom.C b/src/usr/xscom/runtime/rt_xscom.C
index 58d49ee..4edb69a 100644
--- a/src/usr/xscom/runtime/rt_xscom.C
+++ b/src/usr/xscom/runtime/rt_xscom.C
@@ -5,7 +5,9 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* COPYRIGHT International Business Machines Corp. 2013,2014              */
+/* Contributors Listed Below - COPYRIGHT 2013,2016                        */
+/* [+] International Business Machines Corp.                              */
+/*                                                                        */
 /*                                                                        */
 /* Licensed under the Apache License, Version 2.0 (the "License");        */
 /* you may not use this file except in compliance with the License.       */
@@ -38,6 +40,8 @@
 trace_desc_t* g_trac_xscom = NULL;
 TRAC_INIT(&g_trac_xscom, "XSCOM", 2*KILOBYTE, TRACE::BUFFER_SLOW);
 
+const uint64_t OPAL_SCOM_ERROR = 0xDEADBEEFDEADBEEF;
+
 namespace XSCOM
 {
 
@@ -155,6 +159,8 @@ errlHndl_t  xScomDoOp(DeviceFW::OperationType i_ioType,
     errlHndl_t l_err = NULL;
     int rc = 0;
     RT_TARG::rtChipId_t proc_id = 0;
+    uint64_t* l_scomdata = static_cast<uint64_t*>(io_buffer);
+    bool l_skipcheck = false;
 
     // Convert target to something  Sapphire understands
     l_err = RT_TARG::getRtTarget(i_target,
@@ -172,6 +178,7 @@ errlHndl_t  xScomDoOp(DeviceFW::OperationType i_ioType,
 
         if(i_ioType == DeviceFW::READ)
         {
+            *l_scomdata = 0;
             rc =
                 g_hostInterfaces->scom_read(proc_id,
                                             i_scomAddr,
@@ -180,6 +187,13 @@ errlHndl_t  xScomDoOp(DeviceFW::OperationType i_ioType,
         }
         else if (i_ioType == DeviceFW::WRITE)
         {
+            // handle the improbable, but possible, case where we wrote
+            //  the magic pattern in ourselves
+            if( *l_scomdata == OPAL_SCOM_ERROR )
+            {
+                l_skipcheck = true;
+            }
+
             rc =
                 g_hostInterfaces->scom_write(proc_id,
                                              i_scomAddr,
@@ -194,14 +208,16 @@ errlHndl_t  xScomDoOp(DeviceFW::OperationType i_ioType,
              * @errortype
              * @moduleid     XSCOM_RT_DO_OP
              * @reasoncode   XSCOM_RUNTIME_ERR
-             * @userdata1    Hypervisor return code
+             * @userdata1[00:31]    Hypervisor return code
+             * @userdata1[32:63]    Runtime Target
              * @userdata2    SCOM address
              * @devdesc      XSCOM access error
+             * @custdesc     Error accessing hardware registers
              */
             l_err = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_INFORMATIONAL,
                                             XSCOM_RT_DO_OP,
                                             XSCOM_RUNTIME_ERR,
-                                            rc,
+                                            TWO_UINT32_TO_UINT64(rc,proc_id),
                                             i_scomAddr);
 
             // TODO - RTC 86782 need to know what kind of errors Sapphire can
@@ -213,6 +229,59 @@ errlHndl_t  xScomDoOp(DeviceFW::OperationType i_ioType,
 
             // Note: no trace buffer available at runtime
         }
+        else
+        {
+            // Look for special pattern inside response to indicate an error,
+            //  needed to handle case where interface is not returning a bad rc
+            // Check is only valid if:
+            //   - we didn't attempt to use this same pattern ourselves
+            //   - the data we have matches the pattern
+            //   - the get_fix_list interface is not defined
+            //     OR it returns that the fix is not present
+            if( !l_skipcheck
+                && (*l_scomdata == OPAL_SCOM_ERROR)
+                && ((g_hostInterfaces->get_interface_capabilities
+                     &&
+                     !(g_hostInterfaces->
+                          get_interface_capabilities(HBRT_CAPS_SET1_OPAL)
+                       & HBRT_CAPS_OPAL_HAS_XSCOM_RC))
+                    ||
+                    !(g_hostInterfaces->get_interface_capabilities))
+                )
+            {
+                TRACFCOMP(g_trac_xscom,ERR_MRK
+                          "Hypervisor scom read/write failed with DEADBEEF. "
+                          "rc 0x%X target 0x%llX proc_id 0x%llX addr 0x%llX r/w %d",
+                          rc, get_huid(i_target), proc_id, i_scomAddr, i_ioType);
+
+                /*@
+                 * @errortype
+                 * @moduleid     XSCOM_RT_DO_OP
+                 * @reasoncode   XSCOM_RUNTIME_ERR2
+                 * @userdata1[00:31]    Runtime Target
+                 * @userdata1[32:63]    Target HUID
+                 * @userdata2    SCOM address
+                 * @devdesc      XSCOM access error indicated with bad
+                 *               buffer data
+                 * @custdesc     Error accessing hardware registers
+                 */
+                l_err = new ERRORLOG::ErrlEntry(
+                             ERRORLOG::ERRL_SEV_INFORMATIONAL,
+                             XSCOM_RT_DO_OP,
+                             XSCOM_RUNTIME_ERR2,
+                             TWO_UINT32_TO_UINT64(
+                                proc_id,
+                                TARGETING::get_huid(i_target)),
+                             i_scomAddr);
+
+                l_err->addHwCallout(i_target,
+                                    HWAS::SRCI_PRIORITY_LOW,
+                                    HWAS::NO_DECONFIG,
+                                    HWAS::GARD_NULL);
+
+                // Note: no trace buffer available at runtime
+            }
+        }
     }
     else // Hypervisor interface not initialized
     {
diff --git a/src/usr/xscom/runtime/test/testxscom_rt.H b/src/usr/xscom/runtime/test/testxscom_rt.H
index 0b17fd0..965f6cb 100644
--- a/src/usr/xscom/runtime/test/testxscom_rt.H
+++ b/src/usr/xscom/runtime/test/testxscom_rt.H
@@ -5,7 +5,9 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* COPYRIGHT International Business Machines Corp. 2013,2014              */
+/* Contributors Listed Below - COPYRIGHT 2013,2016                        */
+/* [+] International Business Machines Corp.                              */
+/*                                                                        */
 /*                                                                        */
 /* Licensed under the Apache License, Version 2.0 (the "License");        */
 /* you may not use this file except in compliance with the License.       */
@@ -51,7 +53,7 @@ const uint32_t g_xscomAddrTableSz =
 
 class XscomTestSuite : public CxxTest::TestSuite
 {
-    public:
+  public:
     /**
      * @brief XSCOM test #1
      *        Write value and read back to verify
@@ -70,79 +72,79 @@ class XscomTestSuite : public CxxTest::TestSuite
         errlHndl_t l_err = NULL;
         for( uint32_t l_num=0; l_num < g_xscomAddrTableSz; l_num++)
         {
-             testXscomAddrData l_testEntry = g_xscomAddrTable[l_num];
-
-             // Perform XSComOM read
-             uint64_t l_readData = 0;
-             uint64_t l_writeData = 0;
-             uint64_t l_savedData = 0;
-             l_err = deviceRead(l_testTarget,
-                                &l_readData,
+            testXscomAddrData l_testEntry = g_xscomAddrTable[l_num];
+
+            // Perform XSComOM read
+            uint64_t l_readData = 0;
+            uint64_t l_writeData = 0;
+            uint64_t l_savedData = 0;
+            l_err = deviceRead(l_testTarget,
+                               &l_readData,
+                               l_size,
+                               DEVICE_SCOM_ADDRESS(l_testEntry.addr));
+            if (l_err)
+            {
+                TS_FAIL("testXscom1: XSCom read: deviceRead() fails! Error committed.");
+                break;
+            }
+            else
+            {
+                TS_TRACE("testXscom1: XSCom read, Address 0x%.8X, Data %llx",
+                         l_testEntry.addr,
+                         (long long unsigned)l_readData);
+            }
+
+            // Perform an XSCom write
+            l_savedData = l_readData;
+            l_writeData = (l_readData | l_testEntry.data);
+            l_err = deviceWrite(l_testTarget,
+                                &l_writeData,
                                 l_size,
-                                DEVICE_SCOM_ADDRESS(l_testEntry.addr));
-             if (l_err)
-             {
-                 TS_FAIL("testXscom1: XSCom read: deviceRead() fails! Error committed.");
-                 break;
-             }
-             else
-             {
-                 TS_TRACE("testXscom1: XSCom read, Address 0x%.8X, Data %llx",
-                                                      l_testEntry.addr,
-                                                      (long long unsigned)l_readData);
-             }
-
-             // Perform an XSCom write
-             l_savedData = l_readData;
-             l_writeData = (l_readData | l_testEntry.data);
-             l_err = deviceWrite(l_testTarget,
-                     &l_writeData,
-                     l_size,
-                     DeviceFW::SCOM,
-                     l_testEntry.addr);
-
-             if (l_err)
-             {
-                 TS_FAIL("testXscom1: XSCom write: deviceWrite() fails!");
-                 break;
-             }
-             else
-             {
-                 TS_TRACE("testXscom1: XSCom write, Address 0x%.8X, Data %llx",
+                                DeviceFW::SCOM,
+                                l_testEntry.addr);
+
+            if (l_err)
+            {
+                TS_FAIL("testXscom1: XSCom write: deviceWrite() fails!");
+                break;
+            }
+            else
+            {
+                TS_TRACE("testXscom1: XSCom write, Address 0x%.8X, Data %llx",
                          l_testEntry.addr,
                          (long long unsigned)l_writeData);
-             }
-
-             // Read back
-             l_readData = 0;
-             l_err = deviceRead(l_testTarget,
-                                &l_readData,
+            }
+
+            // Read back
+            l_readData = 0;
+            l_err = deviceRead(l_testTarget,
+                               &l_readData,
+                               l_size,
+                               DEVICE_SCOM_ADDRESS(l_testEntry.addr));
+            if (l_err)
+            {
+                TS_FAIL("testXscom1: XSCom read back: deviceRead() fails!");
+                break;
+            }
+
+            if( l_readData != l_writeData )
+            {
+                TS_FAIL("testXscom1: XSCom read back doesn't match write!");
+                break;
+            }
+
+            // Write back original value
+            l_err = deviceWrite(l_testTarget,
+                                &l_savedData,
                                 l_size,
-                                DEVICE_SCOM_ADDRESS(l_testEntry.addr));
-             if (l_err)
-             {
-                 TS_FAIL("testXscom1: XSCom read back: deviceRead() fails!");
-                 break;
-             }
-
-             if( l_readData != l_writeData )
-             {
-                 TS_FAIL("testXscom1: XSCom read back doesn't match write!");
-                 break;
-             }
-
-             // Write back original value
-             l_err = deviceWrite(l_testTarget,
-                      &l_savedData,
-                      l_size,
-                      DeviceFW::SCOM,
-                      l_testEntry.addr);
-
-              if (l_err)
-              {
-                  TS_FAIL("testXscom1: XSCom write back original fails!");
-                  break;
-              }
+                                DeviceFW::SCOM,
+                                l_testEntry.addr);
+
+            if (l_err)
+            {
+                TS_FAIL("testXscom1: XSCom write back original fails!");
+                break;
+            }
         }
 
         if (l_err)
@@ -155,5 +157,33 @@ class XscomTestSuite : public CxxTest::TestSuite
             TS_TRACE("testXscom1 runs successfully!");
         }
         return;
-  }
+    }
+
+    void testXscom_opalprdbug(void)
+    {
+        TARGETING::TargetService& l_targetService = TARGETING::targetService();
+        TARGETING::Target* l_testTarget = NULL;
+        l_targetService.masterProcChipTargetHandle( l_testTarget );
+        assert(l_testTarget != NULL);
+
+        size_t l_size = sizeof(uint64_t);
+
+        // Read a special address to trigger workaround
+        errlHndl_t l_err = NULL;
+        uint64_t l_readData = 0;
+        l_err = deviceRead(l_testTarget,
+                           &l_readData,
+                           l_size,
+                           DEVICE_SCOM_ADDRESS(0x1234567887654321));
+        if (!l_err)
+        {
+            TS_FAIL("testXscom_opalprdbug: XSCom read didn't return an error. l_readData=%.16X", l_readData);
+        }
+        else
+        {
+            TS_TRACE("testXscom_opalprdbug: XSCom read failed with RC=%.8X",
+                     ERRL_GETRC_SAFE(l_err));
+            delete l_err;
+        }
+    }
 };
-- 
2.9.2


From 950c94453ea427e1002de7fe6774d3673da419aa Mon Sep 17 00:00:00 2001
From: Stephen Cprek <smcprek@us.ibm.com>
Date: Fri, 2 Sep 2016 12:29:49 -0500
Subject: [PATCH 06/20] Create new secureboot key transition pnor partition
 (SBKT)

Generate a test SBKT section for hb standalone

Change-Id: If9f3d945767d5280dde47d138914ba0327e0940b
RTC: 145687
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/29202
Reviewed-by: Nicholas E. Bofferding <bofferdn@us.ibm.com>
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Reviewed-by: Marshall J. Wilks <mjwilks@us.ibm.com>
Reviewed-by: William G. Hoffa <wghoffa@us.ibm.com>
---
 src/build/buildpnor/defaultPnorLayout.xml |  10 +-
 src/build/buildpnor/genPnorImages.pl      | 218 ++++++++++++++++++++++--------
 src/build/mkrules/hbfw/img/makefile       |   9 +-
 src/build/tools/hbDistribute              |   5 +
 src/include/usr/pnor/pnorif.H             |   3 +-
 src/usr/pnor/pnor_common.C                |   1 +
 6 files changed, 180 insertions(+), 66 deletions(-)

diff --git a/src/build/buildpnor/defaultPnorLayout.xml b/src/build/buildpnor/defaultPnorLayout.xml
index adb04fd..56b8d8a 100644
--- a/src/build/buildpnor/defaultPnorLayout.xml
+++ b/src/build/buildpnor/defaultPnorLayout.xml
@@ -5,7 +5,7 @@
 <!--                                                                        -->
 <!-- OpenPOWER HostBoot Project                                             -->
 <!--                                                                        -->
-<!-- Contributors Listed Below - COPYRIGHT 2012,2015                        -->
+<!-- Contributors Listed Below - COPYRIGHT 2012,2016                        -->
 <!-- [+] International Business Machines Corp.                              -->
 <!--                                                                        -->
 <!--                                                                        -->
@@ -202,6 +202,14 @@ Layout Description
         <ecc/>
     </section>
     <section>
+        <description>SecureBoot Key Transition Partition (12K)</description>
+        <eyeCatch>SBKT</eyeCatch>
+        <physicalOffset>0x2427000</physicalOffset>
+        <physicalRegionSize>0x4000</physicalRegionSize>
+        <side>sideless</side>
+        <ecc/>
+    </section>
+    <section>
         <description>Hostboot Base (576K)</description>
         <!--NOTE: MUST update standalone.simics if offset changes -->
         <!--NOTE: HBB must be at pnorSize-0x99000 for a new proc
diff --git a/src/build/buildpnor/genPnorImages.pl b/src/build/buildpnor/genPnorImages.pl
index 629d7a1..9b18903 100755
--- a/src/build/buildpnor/genPnorImages.pl
+++ b/src/build/buildpnor/genPnorImages.pl
@@ -73,9 +73,10 @@ use constant VFS_MODULE_TABLE_MAX_SIZE => VFS_EXTENDED_MODULE_MAX
 use constant LOCAL_SIGNING_FLAG => " -flag ";
 use constant OP_SIGNING_FLAG => " -flags ";
 # Security bits HW flag strings
-use constant HB_FW_FLAG => "0x80000000";
-use constant OPAL_FLAG => "0x40000000";
-use constant PHYP_FLAG => "0x20000000";
+use constant HB_FW_FLAG => 0x80000000;
+use constant OPAL_FLAG => 0x40000000;
+use constant PHYP_FLAG => 0x20000000;
+use constant KEY_TRANSITION_FLAG => 0x00000001;
 
 ################################################################################
 # I/O parsing
@@ -88,6 +89,7 @@ my $pnorLayoutFile = "";
 my $system_target = "";
 my $build_all = 0;
 my $install_all = 0;
+my $key_transition = 0;
 my $help = 0;
 
 GetOptions("binDir:s" => \$bin_dir,
@@ -97,8 +99,12 @@ GetOptions("binDir:s" => \$bin_dir,
            "systemBinFiles:s" => \@systemBinFiles,
            "build-all" => \$build_all,
            "install-all" => \$install_all,
+           "key-transition" => \$key_transition,
            "help" => \$help);
 
+# If in test mode, set key transition
+$key_transition = 1 if($testRun);
+
 if ($help)
 {
     usage();
@@ -154,11 +160,44 @@ if($SIGNING_TOOL_EDITION eq COMMUNITY)
 # Requires naming convention of hw/sw keys in DEV_KEY_DIR
 
 my $SIGN_BUILD_PARAMS = "-skp ${DEV_KEY_DIR}/sw_key_a";
-# Secureboot header file
+
+
+# Key prefix used for current key siging of partitions (N/A for open edition)
+my $SIGN_PREFIX_PARAMS = "-hka ${DEV_KEY_DIR}/hw_key_a -hkb "
+            . "${DEV_KEY_DIR}/hw_key_b -hkc ${DEV_KEY_DIR}/hw_key_c "
+            . "-skp ${DEV_KEY_DIR}/sw_key_a";
+
+# Key prefix used for secureboot key transition partition.
+# Note: simply reordered the keys to create a psuedo production key.
+my $SIGN_SBKT_PREFIX_PARAMS =  "-hka ${DEV_KEY_DIR}/hw_key_c -hkb "
+            . "${DEV_KEY_DIR}/hw_key_b -hkc ${DEV_KEY_DIR}/hw_key_a "
+            . "-skp ${DEV_KEY_DIR}/sw_key_a";
+
+# Secureboot headers
+# Contains the appropriate flags, prefix, and file names.
 my $randPrefix = "rand-".POSIX::ceil(rand(0xFFFFFFFF));
-my $HB_FW_SECUREBOOT_HDR = "$bin_dir/$randPrefix.hb.fw.secureboot.hdr.bin";
-my $OPAL_SECUREBOOT_HDR = "$bin_dir/$randPrefix.opal.secureboot.hdr.bin";
-my $PHYP_SECUREBOOT_HDR = "$bin_dir/$randPrefix.phyp.secureboot.hdr.bin";
+my %sb_hdrs = (
+    HB_FW => {
+        flags =>  sprintf("0x%08X",HB_FW_FLAG),
+        prefix => $SIGN_PREFIX_PARAMS,
+        file => "$bin_dir/$randPrefix.hb.fw.secureboot.hdr.bin"
+    },
+    OPAL => {
+        flags =>  sprintf("0x%08X",OPAL_FLAG),
+        prefix => $SIGN_PREFIX_PARAMS,
+        file => "$bin_dir/$randPrefix.opal.secureboot.hdr.bin"
+    },
+    PHYP => {
+        flags => sprintf("0x%08X", PHYP_FLAG),
+        prefix => $SIGN_PREFIX_PARAMS,
+        file => "$bin_dir/$randPrefix.phyp.secureboot.hdr.bin"
+    },
+    SBKT => {
+        flags => sprintf("0x%08X", HB_FW_FLAG | KEY_TRANSITION_FLAG),
+        prefix => $SIGN_SBKT_PREFIX_PARAMS,
+        file => "$bin_dir/$randPrefix.sbkt.secureboot.hdr.bin"
+    }
+);
 
 my $OPEN_SIGN_REQUEST="$SIGNING_DIR/crtSignedContainer.pl -v "
     . "-hwPrivKeyA $DEV_KEY_DIR/hw_key_a.key "
@@ -178,16 +217,16 @@ if ($secureboot)
 
     if(!$openSigningTool)
     {
-        # Key prefix used for all partitions (N/A for open edition)
-        my $SIGN_PREFIX_PARAMS = "-hka ${DEV_KEY_DIR}/hw_key_a -hkb "
-                    . "${DEV_KEY_DIR}/hw_key_b -hkc ${DEV_KEY_DIR}/hw_key_c "
-                    . "-skp ${DEV_KEY_DIR}/sw_key_a";
-        run_command("$SIGNING_DIR/prefix -good -of $HB_FW_SECUREBOOT_HDR".
-                    LOCAL_SIGNING_FLAG.HB_FW_FLAG." $SIGN_PREFIX_PARAMS");
-        run_command("$SIGNING_DIR/prefix -good -of $OPAL_SECUREBOOT_HDR ".
-                    LOCAL_SIGNING_FLAG.OPAL_FLAG." $SIGN_PREFIX_PARAMS");
-        run_command("$SIGNING_DIR/prefix -good -of $PHYP_SECUREBOOT_HDR ".
-                    LOCAL_SIGNING_FLAG.PHYP_FLAG." $SIGN_PREFIX_PARAMS");
+        # Generate each secureboot header file
+        foreach my $header (keys %sb_hdrs)
+        {
+            next if($header eq "SBKT" && !$key_transition);
+            run_command("$SIGNING_DIR/prefix -good -of $sb_hdrs{$header}{file}".
+                        LOCAL_SIGNING_FLAG."$sb_hdrs{$header}{flags}".
+                        " $sb_hdrs{$header}{prefix}");
+        }
+
+        # Generate test containers once and limit to build phase
         if ($build_all)
         {
             gen_test_containers();
@@ -222,12 +261,13 @@ foreach my $binFilesCSV (@systemBinFiles)
     checkSpaceConstraints(\%pnorLayout, \%binFiles, $testRun);
 }
 
-system("rm -f $HB_FW_SECUREBOOT_HDR");
-die "Could not delete $HB_FW_SECUREBOOT_HDR" if $?;
-system("rm -f $OPAL_SECUREBOOT_HDR");
-die "Could not delete $OPAL_SECUREBOOT_HDR" if $?;
-system("rm -f $PHYP_SECUREBOOT_HDR");
-die "Could not delete $PHYP_SECUREBOOT_HDR" if $?;
+
+# Clean up temp header files
+foreach my $header (keys %sb_hdrs)
+{
+    system("rm -f $sb_hdrs{$header}{file}");
+    die "Could not delete $sb_hdrs{$header}{file}" if $?;
+}
 
 ################################################################################
 # manipulateImages - Perform any ECC/padding/sha/signing manipulations
@@ -289,18 +329,19 @@ sub manipulateImages
         # enabled for secureboot actions on these partitions to occur.
         my $isNormalSecure =    ($eyeCatch eq "SBE")
                              || ($eyeCatch eq "SBEC")
-                             || ($eyeCatch eq "PAYLOAD");
+                             || ($eyeCatch eq "PAYLOAD")
+                             || ($eyeCatch eq "SBKT");
 
         my $isSpecialSecure =    ($eyeCatch eq "HBB")
                               || ($eyeCatch eq "HBI")
                               || ($eyeCatch eq "HBD");
 
-        my $openSigningFlags = OP_SIGNING_FLAG.HB_FW_FLAG;
-        my $secureboot_hdr =  $HB_FW_SECUREBOOT_HDR;
+        my $openSigningFlags = OP_SIGNING_FLAG.$sb_hdrs{HB_FW}{flag};
+        my $secureboot_hdr =  $sb_hdrs{HB_FW}{file};
         if ($eyeCatch eq "PAYLOAD")
         {
-            $secureboot_hdr = $OPAL_SECUREBOOT_HDR;
-            $openSigningFlags = OP_SIGNING_FLAG.OPAL_FLAG;
+            $secureboot_hdr = $sb_hdrs{OPAL}{file};
+            $openSigningFlags = OP_SIGNING_FLAG.$sb_hdrs{OPAL}{flag};
         }
 
         # Handle partitions that have an input binary.
@@ -465,24 +506,7 @@ sub manipulateImages
                 run_command("cp $bin_file $tempImages{HDR_PHASE}");
             }
 
-            if($callerHwHdrFields{configure})
-            {
-                # If not already explicitly set, compute total container size
-                if(!$callerHwHdrFields{totalContainerSize})
-                {
-                    $callerHwHdrFields{totalContainerSize}
-                        = -s $tempImages{HDR_PHASE};
-                    die  "Could not determine size of file "
-                        ."$tempImages{HDR_PHASE}; errno = $!" unless
-                            defined($callerHwHdrFields{totalContainerSize});
-                }
-                my $callerHwHdr = sprintf("%016llX%016llX%016llX",
-                    $callerHwHdrFields{totalContainerSize},
-                    $callerHwHdrFields{targetHrmor},
-                    $callerHwHdrFields{instructionStartStackPointer});
-                run_command( "echo \"$callerHwHdr\" | xxd -r -ps -seek 6 - "
-                            ."$tempImages{HDR_PHASE}");
-            }
+            setCallerHwHdrFields(\%callerHwHdrFields, $tempImages{HDR_PHASE});
 
             # Prefix phase
             # Add SBE header to HBB
@@ -549,21 +573,29 @@ sub manipulateImages
             {
                 run_command("dd if=/dev/urandom of=$tempImages{PAD_PHASE} count=1 bs=$size");
             }
+            elsif ($eyeCatch eq "SBKT" && $secureboot && $key_transition)
+            {
+                $callerHwHdrFields{configure} = 1;
+                create_sb_key_transition_container($tempImages{PAD_PHASE});
+                setCallerHwHdrFields(\%callerHwHdrFields, $tempImages{PAD_PHASE});
+            }
             # Other partitions fill with FF's if no empty bin file provided
             else
             {
                 run_command("dd if=/dev/zero bs=$size count=1 | tr \"\\000\" \"\\377\" > $tempImages{PAD_PHASE}");
-            }
 
-            # Add secure container header
-            if ($secureboot && $isNormalSecure)
-            {
-                # Remove PAGE_SIZE bytes from generated dummy content of file
-                # to make room for the secure header
-                my $fileSize = (-s $tempImages{PAD_PHASE}) - PAGE_SIZE;
-                run_command("dd if=$tempImages{PAD_PHASE} of=$tempImages{TEMP_BIN} count=1 bs=$fileSize");
-                # @TODO RTC:155374 Remove when official signing supported
-                run_command("$SIGNING_DIR/build -good -if $secureboot_hdr -of $tempImages{PAD_PHASE} -bin $tempImages{TEMP_BIN} $SIGN_BUILD_PARAMS");
+                # Add secure container header
+                if ($secureboot && $isNormalSecure && $eyeCatch ne "SBKT")
+                {
+                    $callerHwHdrFields{configure} = 1;
+                    # Remove PAGE_SIZE bytes from generated dummy content of file
+                    # to make room for the secure header
+                    my $fileSize = (-s $tempImages{PAD_PHASE}) - PAGE_SIZE;
+                    run_command("dd if=$tempImages{PAD_PHASE} of=$tempImages{TEMP_BIN} count=1 bs=$fileSize");
+                    # @TODO RTC:155374 Remove when official signing supported
+                    run_command("$SIGNING_DIR/build -good -if $secureboot_hdr -of $tempImages{PAD_PHASE} -bin $tempImages{TEMP_BIN} $SIGN_BUILD_PARAMS");
+                    setCallerHwHdrFields(\%callerHwHdrFields, $tempImages{PAD_PHASE});
+                }
             }
         }
 
@@ -713,23 +745,24 @@ sub genHashPageTable
 ################################################################################
 sub gen_test_containers
 {
+    my $randPrefix = "rand-".POSIX::ceil(rand(0xFFFFFFFF));
     my %tempImages = (
-        TEST_CONTAINER_DATA => "$bin_dir/test.cont.bin",
-        PROTECTED_PAYLOAD => "$bin_dir/test.protected_payload.bin"
+        TEST_CONTAINER_DATA => "$bin_dir/$randPrefix.test.cont.bin",
+        PROTECTED_PAYLOAD => "$bin_dir/$randPrefix.test.protected_payload.bin"
     );
 
     # Create a signed test container
     # name = secureboot_signed_container (no prefix in hb cacheadd)
     my $test_container = "$bin_dir/secureboot_signed_container";
     run_command("dd if=/dev/zero count=1 | tr \"\\000\" \"\\377\" > $tempImages{TEST_CONTAINER_DATA}");
-    run_command("$SIGNING_DIR/build -good -if $HB_FW_SECUREBOOT_HDR -of $test_container -bin $tempImages{TEST_CONTAINER_DATA} $SIGN_BUILD_PARAMS");
+    run_command("$SIGNING_DIR/build -good -if $sb_hdrs{HB_FW}{file} -of $test_container -bin $tempImages{TEST_CONTAINER_DATA} $SIGN_BUILD_PARAMS");
 
     # Create a signed test container with a hash page table
     # name = secureboot_hash_page_table_container (no prefix in hb cacheadd)
     $test_container = "$bin_dir/secureboot_hash_page_table_container";
     run_command("dd if=/dev/urandom count=5 ibs=4096 | tr \"\\000\" \"\\377\" > $tempImages{TEST_CONTAINER_DATA}");
     $tempImages{hashPageTable} = genHashPageTable($tempImages{TEST_CONTAINER_DATA}, "secureboot_test");
-    run_command("$SIGNING_DIR/build -good -if $HB_FW_SECUREBOOT_HDR -of $tempImages{PROTECTED_PAYLOAD} -bin $tempImages{hashPageTable} $SIGN_BUILD_PARAMS");
+    run_command("$SIGNING_DIR/build -good -if $sb_hdrs{HB_FW}{file} -of $tempImages{PROTECTED_PAYLOAD} -bin $tempImages{hashPageTable} $SIGN_BUILD_PARAMS");
     run_command("cat $tempImages{PROTECTED_PAYLOAD} $tempImages{TEST_CONTAINER_DATA} > $test_container ");
 
     # Clean up temp images
@@ -741,6 +774,71 @@ sub gen_test_containers
 }
 
 ################################################################################
+# create_sb_key_transition_container
+#       Generate sb key transition container used for transitioning from an
+#       imprint to production key.
+#       Format:
+#           SB_HDR_IMPRINT_KEY[SB_HDR_PRD_KEY[4K rand blob]]
+#       Steps:
+#           1. Generate 4K blob of random data
+#           2. Sign #1 with production keys
+#           3. Sign #2 with the imprint keys
+################################################################################
+sub create_sb_key_transition_container
+{
+    my ($o_file) = @_;
+
+    my $randPrefix = "rand-".POSIX::ceil(rand(0xFFFFFFFF));
+    my %tempImages = (
+        RAND_BLOB => "$bin_dir/$randPrefix.rand_blob.bin",
+        PRD_KEY_FILE => "$bin_dir/$randPrefix.sbkt_prod_key.bin"
+    );
+
+    # Gen 4K blob of random data
+    run_command("dd if=/dev/urandom of=$tempImages{RAND_BLOB} count=1 bs=4k");
+
+    # Create a signed container with new production keys
+    run_command("$SIGNING_DIR/build -good -if $sb_hdrs{SBKT}{file} -of $tempImages{PRD_KEY_FILE} -bin $tempImages{RAND_BLOB} $SIGN_BUILD_PARAMS");
+
+    # Sign new production key container with imprint keys
+    run_command("$SIGNING_DIR/build -good -if $sb_hdrs{HB_FW}{file} -of $o_file -bin $tempImages{PRD_KEY_FILE} $SIGN_BUILD_PARAMS");
+
+    # Clean up temp images
+    foreach my $image (keys %tempImages)
+    {
+        system("rm -f $tempImages{$image}");
+        die "Failed deleting $tempImages{$image}" if ($?);
+    }
+}
+
+################################################################################
+# setCallerHwHdrFields
+#       Sets the caller hardware header fields in the passed in file based on
+#       the input hash passed in.
+################################################################################
+sub setCallerHwHdrFields
+{
+    my ($i_callerHwHdrFields, $i_file) = @_;
+
+    if($i_callerHwHdrFields->{configure})
+    {
+        # If not already explicitly set, compute total container size
+        if(!$i_callerHwHdrFields->{totalContainerSize})
+        {
+            $i_callerHwHdrFields->{totalContainerSize}
+                = -s $i_file;
+            die  "Could not determine size of file $i_file; errno = $!" unless
+                    defined($i_callerHwHdrFields->{totalContainerSize});
+        }
+        my $callerHwHdr = sprintf("%016llX%016llX%016llX",
+            $i_callerHwHdrFields->{totalContainerSize},
+            $i_callerHwHdrFields->{targetHrmor},
+            $i_callerHwHdrFields->{instructionStartStackPointer});
+        run_command( "echo \"$callerHwHdr\" | xxd -r -ps -seek 6 - $i_file");
+    }
+}
+
+################################################################################
 # print usage instructions
 ################################################################################
 sub usage
diff --git a/src/build/mkrules/hbfw/img/makefile b/src/build/mkrules/hbfw/img/makefile
index 4055247..aacb7a6 100755
--- a/src/build/mkrules/hbfw/img/makefile
+++ b/src/build/mkrules/hbfw/img/makefile
@@ -75,9 +75,10 @@ DJVPD_IMAGE = DJVPD.bin
 MVPD_IMAGE = MVPD.bin
 CVPD_IMAGE = CVPD.bin
 PAYLOAD_IMAGE = PAYLOAD.bin
+SBKT_IMAGE = SBKT.bin
 ZERO_FILL_IMAGES = ${TEST_IMAGE} ${TESTRO_IMAGE} ${HBEL_IMAGE} ${GUARD_IMAGE} \
                    ${GLOBAL_IMAGE} ${DJVPD_IMAGE} ${MVPD_IMAGE} ${CVPD_IMAGE} \
-                   ${PAYLOAD_IMAGE}
+                   ${PAYLOAD_IMAGE} ${SBKT_IMAGE}
 ALL_HB_IMAGES = ${BASE_IMAGES} ${BASE_W_HEADER_IMAGE} ${BASE_ECC_IMAGE}\
                 ${BASE_W_HEADER_ECC_IMAGE} ${BASE_SHA_IMAGE} ${HBRT_SHA_IMAGE} \
                 ${HBRT_HEADER_IMAGE} ${HBRT_ECC_HEADER_IMAGE} \
@@ -90,7 +91,7 @@ GEN_PNOR_IMAGE_SCRIPT = ${genPnorImages.pl:P}
 # them, rather than use an input.
 # Note: HBI depends on HBB for sw signatures. Ensure that both are passed into
 #       the same --systemBinFiles parameter for genPnorImages
-GEN_DEFAULT_BIN_FILES = HBB=${BASE_IMAGE},HBI=${EXT_IMAGE},TEST=EMPTY,TESTRO=EMPTY,HBEL=EMPTY,GUARD=EMPTY,GLOBAL=EMPTY,PAYLOAD=EMPTY,CVPD=EMPTY,MVPD=EMPTY,DJVPD=EMPTY
+GEN_DEFAULT_BIN_FILES = HBB=${BASE_IMAGE},HBI=${EXT_IMAGE},TEST=EMPTY,TESTRO=EMPTY,HBEL=EMPTY,GUARD=EMPTY,GLOBAL=EMPTY,PAYLOAD=EMPTY,CVPD=EMPTY,MVPD=EMPTY,DJVPD=EMPTY,SBKT=EMPTY
 DEFAULT_PNOR_LAYOUT = ${defaultPnorLayout.xml:P}
 
 ################################################################################
@@ -115,7 +116,7 @@ gen_default_images: cp_hbfiles
 	# HBI + HBB partitions and ZERO_FILL_IMAGES
 	${GEN_PNOR_IMAGE_SCRIPT} --build-all ${TARGET_TEST:b--test} \
 		${CONFIG_SECUREBOOT:b--secureboot} --systemBinFiles ${GEN_DEFAULT_BIN_FILES} \
-		--pnorLayout ${DEFAULT_PNOR_LAYOUT}
+		--pnorLayout ${DEFAULT_PNOR_LAYOUT} ${KEY_TRANSITION:b--key-transition}
 	rm ${TEMP_IMAGE}
 
 clobber_gen_default_images:
@@ -197,7 +198,7 @@ GEN_FAKE_HEADER_SCRIPT = ${genfakeheader.pl:P}
 #so need to use tryinclude for now.
 .tryinclude <${.PATH:Ffips_pnor.mk}>
 
-ZERO_FILL_SECTIONS = TEST=${TEST_IMAGE},TESTRO=${TESTRO_IMAGE},HBEL=${HBEL_IMAGE},GUARD=${GUARD_IMAGE},GLOBAL=${GLOBAL_IMAGE},PAYLOAD=${PAYLOAD_IMAGE},CVPD=${CVPD_IMAGE},MVPD=${MVPD_IMAGE},DJVPD=${DJVPD_IMAGE}
+ZERO_FILL_SECTIONS = TEST=${TEST_IMAGE},TESTRO=${TESTRO_IMAGE},HBEL=${HBEL_IMAGE},GUARD=${GUARD_IMAGE},GLOBAL=${GLOBAL_IMAGE},PAYLOAD=${PAYLOAD_IMAGE},CVPD=${CVPD_IMAGE},MVPD=${MVPD_IMAGE},DJVPD=${DJVPD_IMAGE},SBKT=${SBKT_IMAGE}
 HOSTBOOT_DEFAULT_SECTIONS = HBB=${BASE_FINAL_IMAGE},HBI=${EXT_FINAL_IMAGE},HBRT=${HBRT_ECC_HEADER_IMAGE},${ZERO_FILL_SECTIONS}
 
 HBFW_OBJPATH = ${.PATH:M*obj*}
diff --git a/src/build/tools/hbDistribute b/src/build/tools/hbDistribute
index 0ae6bb5..3e7d18d 100755
--- a/src/build/tools/hbDistribute
+++ b/src/build/tools/hbDistribute
@@ -86,6 +86,10 @@ do
             HB_STANDALONE=1
         ;;
 
+        "--key-transition")
+            KEY_TRANSITION=1
+        ;;
+
         --*)
             echo "ERROR: Unknown option: $ARG"
             exit
@@ -142,5 +146,6 @@ mkdir -p $TARGET_DIR
 export TARGET_TEST
 export TARGET_DIR
 export HB_STANDALONE
+export KEY_TRANSITION
 cd $REPO_ROOT/src/build/mkrules
 make -rR ${DEBUG:=} -f dist.targets.mk $TARGET
diff --git a/src/include/usr/pnor/pnorif.H b/src/include/usr/pnor/pnorif.H
index c32b5ce..faff332 100644
--- a/src/include/usr/pnor/pnorif.H
+++ b/src/include/usr/pnor/pnorif.H
@@ -66,11 +66,12 @@ enum SectionId
     TEST,           /**< Scratch space for PNOR test cases */
     TESTRO,         /**< Scratch space for PNOR ReadOnly test cases */
     BMC_INV,        /**< BMC Inventory */
+    SBKT,           /**< SecureBoot Key Transition */
 
     NUM_SECTIONS,   /**< Number of defined sections */
 
     FIRST_SECTION = TOC,  /**< First section (for looping) */
-    LAST_SECTION = BMC_INV,  /**< Last section (for looping) */
+    LAST_SECTION = SBKT,  /**< Last section (for looping) */
     INVALID_SECTION = NUM_SECTIONS,  /**< Used for error cases, initialization */
 };
 
diff --git a/src/usr/pnor/pnor_common.C b/src/usr/pnor/pnor_common.C
index 27a1ed4..318b8c6 100644
--- a/src/usr/pnor/pnor_common.C
+++ b/src/usr/pnor/pnor_common.C
@@ -74,6 +74,7 @@ const char* cv_EYECATCHER[] = {
     "TEST",      /**< PNOR::TEST           : Test space for PNOR*/
     "TESTRO",    /**< PNOR::TESTRO         : ReadOnly Test space for PNOR */
     "BMC_INV",   /**< PNOR::BMC_INV        : BMC Inventory */
+    "SBKT",      /**< PNOR::SBKT           : SecureBoot Key Transition */
     //Not currently used
 //    "XXX",    /**< NUM_SECTIONS       : Used as invalid entry */
 };
-- 
2.9.2


From dcde835aa2883ae1f2b5f79e5b8ec7c75d3f5cf7 Mon Sep 17 00:00:00 2001
From: Norm James <njames@us.ibm.com>
Date: Mon, 12 Sep 2016 18:47:13 -0700
Subject: [PATCH 07/20] Add ability to read old and new Serverwiz xml outputs.

The new Serverwiz format added outer tags for performance
reasons.  It also added attribute groups for accessing
like attributes with one API call.

Change-Id: I6b6c6de8defbc5c0f0c8c7d191836e69ac7bfc98
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/29550
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Reviewed-by: Matt Spinler <spinler@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Reviewed-by: William G. Hoffa <wghoffa@us.ibm.com>
Reviewed-by: Prachi Gupta <pragupta@us.ibm.com>
Reviewed-by: Matthew A. Ploetz <maploetz@us.ibm.com>
---
 src/usr/targeting/common/Targets.pm | 157 +++++++++++++++++++++++++++++-------
 1 file changed, 126 insertions(+), 31 deletions(-)

diff --git a/src/usr/targeting/common/Targets.pm b/src/usr/targeting/common/Targets.pm
index 096db10..35f0842 100644
--- a/src/usr/targeting/common/Targets.pm
+++ b/src/usr/targeting/common/Targets.pm
@@ -26,6 +26,7 @@ package Targets;
 
 use strict;
 use XML::Simple;
+use XML::Parser;
 use Data::Dumper;
 
 sub new
@@ -43,9 +44,10 @@ sub new
         force        => 0,
         debug        => 0,
         version      => "",
+        xml_version  => 0,
         errorsExist  => 0,
         NUM_PROCS    => 0,
-        TOP_LEVEL    => "sys-0",
+        TOP_LEVEL    => "",
         TOPOLOGY     => undef,
         report_log   => "",
         vpd_num      => 0,
@@ -87,9 +89,16 @@ sub loadXML
     print "Loading MRW XML: $filename\n";
     $self->{xml} =
       XMLin($filename,forcearray => [ 'child_id', 'hidden_child_id', 'bus',
-                                      'property' ]);
+                                      'property', 'field', 'attribute' ]);
+
+    if (defined($self->{xml}->{'enumerationTypes'}))
+    {
+          $self->{xml_version} = 1;
+    }
+
     $self->storeEnumerations();
-    $self->buildHierarchy($self->{TOP_LEVEL});
+    $self->storeGroups();
+    $self->buildHierarchy();
     $self->buildAffinity();
     $self->{report_filename}=$filename.".rpt";
     $self->{report_filename}=~s/\.xml//g;
@@ -230,15 +239,31 @@ sub printAttribute
 sub storeEnumerations
 {
     my $self = shift;
-
-    foreach my $enumType (keys(%{ $self->{xml}->{enumerationType} }))
+    my $baseptr = $self->{xml}->{enumerationType};
+    if ($self->{xml_version} == 1)
+    {
+        $baseptr = $self->{xml}->{enumerationTypes}->{enumerationType};
+    }
+    foreach my $enumType (keys(%{ $baseptr }))
     {
         foreach my $enum (
-            keys(%{$self->{xml}->{enumerationType}->{$enumType}->{enumerator}}))
+            keys(%{$baseptr->{$enumType}->{enumerator}}))
         {
             $self->{enumeration}->{$enumType}->{$enum} =
-              $self->{xml}->{enumerationType}->{$enumType}->{enumerator}
-              ->{$enum}->{value};
+              $baseptr->{$enumType}->{enumerator}->{$enum}->{value};
+        }
+    }
+}
+sub storeGroups
+{
+    my $self = shift;
+    foreach my $grp (keys(%{ $self->{xml}->{attributeGroups}
+        ->{attributeGroup} }))
+    {
+        foreach my $attr (@{$self->{xml}->{attributeGroups}
+            ->{attributeGroup}->{$grp}->{'attribute'}})
+        {
+            $self->{groups}->{$grp}->{$attr} = 1;
         }
     }
 }
@@ -277,13 +302,45 @@ sub buildHierarchy
     my $self   = shift;
     my $target = shift;
 
-    my $old_path        = $self->{data}->{INSTANCE_PATH};
-    my $target_xml      = $self->{xml}->{'targetInstance'}{$target};
+    my $instance_path = $self->{data}->{INSTANCE_PATH};
+    if (!defined $instance_path)
+    {
+        $instance_path = "";
+    }
+    my $baseptr = $self->{xml}->{'targetInstance'};
+    if ($self->{xml_version} == 1)
+    {
+        $baseptr = $self->{xml}->{'targetInstances'}->{'targetInstance'};
+    }
+    if ($target eq "")
+    {
+        ## find system target
+        foreach my $t (keys(%{$baseptr}))
+        {
+            if ($baseptr->{$t}->{attribute}->{TYPE}->{default} eq "SYS")
+            {
+                $self->{TOP_LEVEL} = $t;
+                $target = $t;
+            }
+        }
+    }
+    if ($target eq "")
+    {
+        die "Unable to find system top level target\n";
+    }
+    my $old_path        = $instance_path;
+    my $target_xml      = $baseptr->{$target};
     my $affinity_target = $target;
-    my $key             = $self->{data}->{INSTANCE_PATH} . "/" . $target;
+    my $key             = $instance_path . "/" . $target;
 
-    my $instance_path = $self->{data}->{INSTANCE_PATH};
-    $instance_path = "instance:" . substr($instance_path, 1);
+    if ($instance_path ne "")
+    {
+        $instance_path = "instance:" . substr($instance_path, 1);
+    }
+    else
+    {
+        $instance_path = "instance:";
+    }
     $self->setAttribute($key, "INSTANCE_PATH", $instance_path);
     $self->{data}->{TARGETS}->{$key}->{TARGET} = $target_xml;
     $self->{data}->{INSTANCE_PATH} = $old_path . "/" . $target;
@@ -321,9 +378,15 @@ sub buildHierarchy
         }
     }
     ## global attributes overwrite local
-    foreach my $prop (keys %{$self->{xml}->{globalSetting}->{$key}->{property}})
+    my $settingptr = $self->{xml}->{globalSetting};
+    if ($self->{xml_version} == 1)
     {
-        my $val=$self->{xml}->{globalSetting}->{$key}->{property}->
+        $settingptr = $self->{xml}->{globalSettings}->{globalSetting};
+    }
+
+    foreach my $prop (keys %{$settingptr->{$key}->{property}})
+    {
+        my $val=$settingptr->{$key}->{property}->
                        {$prop}->{value};
         $self->setAttribute($key, $prop, $val);
     }
@@ -413,8 +476,10 @@ sub buildAffinity
             $node = -1;
 
             $self->{targeting}{SYS}[0]{KEY} = $target;
-            $self->setAttribute($target, "AFFINITY_PATH", "affinity:sys-0");
-            $self->setAttribute($target, "PHYS_PATH",     "physical:sys-0");
+            $self->setAttribute($target, "AFFINITY_PATH",
+                                         "affinity:".$self->{TOP_LEVEL});
+            $self->setAttribute($target, "PHYS_PATH",
+                                         "physical:".$self->{TOP_LEVEL});
             $self->setAttribute($target, "ENTITY_INSTANCE","0");
         }
         elsif ($type eq "NODE")
@@ -424,13 +489,13 @@ sub buildAffinity
             $self->{dimm_tpos} = 0;
             $self->{membuf_inst_num}=0;
             $node++;
-            $node_phys = "physical:sys-0/node-$node";
-            $node_aff  = "affinity:sys-0/node-$node";
+            $node_phys = "physical:".$self->{TOP_LEVEL}."/node-$node";
+            $node_aff  = "affinity:".$self->{TOP_LEVEL}."/node-$node";
             $self->{targeting}{SYS}[0]{NODES}[$node]{KEY} = $target;
             $self->setAttribute($target, "AFFINITY_PATH",
-                "affinity:sys-0/node-$node");
+                "affinity:".$self->{TOP_LEVEL}."/node-$node");
             $self->setAttribute($target, "PHYS_PATH",
-                "physical:sys-0/node-$node");
+                "physical:".$self->{TOP_LEVEL}."/node-$node");
             $self->setHuid($target, 0, $node);
             $self->setAttribute($target, "ENTITY_INSTANCE",$node);
         }
@@ -439,9 +504,11 @@ sub buildAffinity
             $tpm++;
             $self->{targeting}{SYS}[0]{NODES}[$node]{TPMS}[$tpm]{KEY} = $target;
             $self->setAttribute($target, "AFFINITY_PATH",
-                                "affinity:sys-0/node-$node/tpm-$tpm");
+                                "affinity:".$self->{TOP_LEVEL}.
+                                "/node-$node/tpm-$tpm");
             $self->setAttribute($target, "PHYS_PATH",
-                                "physical:sys-0/node-$node/tpm-$tpm");
+                                "physical:".$self->{TOP_LEVEL}.
+                                "/node-$node/tpm-$tpm");
             $self->setHuid($target, 0, $tpm);
             $self->setAttribute($target, "ENTITY_INSTANCE",$tpm);
         }
@@ -469,8 +536,10 @@ sub buildAffinity
             $self->setHuid($target, 0, $node);
             my $socket = $self->getTargetParent(
                          $self->getTargetParent($target));
-            my $parent_affinity = "affinity:sys-0/node-$node/proc-$proc";
-            my $parent_physical = "physical:sys-0/node-$node/proc-$proc";
+            my $parent_affinity = "affinity:".$self->{TOP_LEVEL}
+                                  ."/node-$node/proc-$proc";
+            my $parent_physical = "physical:".$self->{TOP_LEVEL}
+                                  ."/node-$node/proc-$proc";
             $self->setAttribute($target, "AFFINITY_PATH",  $parent_affinity);
             $self->setAttribute($target, "PHYS_PATH",      $parent_physical);
             $self->setAttribute($target, "POSITION",       $proc);
@@ -619,8 +688,6 @@ sub processMcs
         $self->setFsiAttributes($membuf,"FSICM",0,$proc_path,$fsi_port,0);
         $self->setAttribute($unit, "DMI_REFCLOCK_SWIZZLE",$fsi_port);
         my $dmi_swizzle =
-             $dmi_bus->{bus_attribute}->{DMI_REFCLOCK_SWIZZLE}->{default};
-        my $dmi_swizzle =
              $self->getBusAttribute($unit,0,"DMI_REFCLOCK_SWIZZLE");
         if ($dmi_swizzle ne "")
         {
@@ -974,7 +1041,8 @@ sub isBadAttribute
     {
         return 1;
     }
-    if ($target_ptr->{ATTRIBUTES}->{$attribute}->{default} eq $badvalue)
+    if (defined $badvalue &&
+        $target_ptr->{ATTRIBUTES}->{$attribute}->{default} eq $badvalue)
     {
         return 1;
     }
@@ -1029,7 +1097,6 @@ sub getAttribute
         printf("ERROR: getAttribute(%s,%s) | Attribute not defined\n",
             $target, $attribute);
 
-        #print Dumper($target_ptr);
         $self->myExit(4);
     }
     if (ref($target_ptr->{ATTRIBUTES}->{$attribute}->{default}) eq "HASH")
@@ -1038,6 +1105,30 @@ sub getAttribute
     }
     return $target_ptr->{ATTRIBUTES}->{$attribute}->{default};
 }
+
+sub getAttributeGroup
+{
+    my $self       = shift;
+    my $target     = shift;
+    my $group      = shift;
+    my $target_ptr = $self->getTarget($target);
+    if (!defined($self->{groups}->{$group})) {
+        printf("ERROR: getAttributeGroup(%s,%s) | Group not defined\n",
+            $target, $group);
+        $self->myExit(4);
+    }
+    my %attr;
+    foreach my $attribute (keys(%{$self->{groups}->{$group}}))
+    {
+        if (defined($target_ptr->{ATTRIBUTES}->{$attribute}->{default}))
+        {
+            $attr{$attribute} = $target_ptr->{ATTRIBUTES}->{$attribute};
+        }
+    }
+    return \%attr;
+}
+
+
 ## renames a target attribute
 sub renameAttribute
 {
@@ -1141,6 +1232,8 @@ sub getBusAttribute
     return $target_ptr->{CONNECTION}->{BUS}->[$busnum]->{bus_attribute}->{$attr}
       ->{default};
 }
+
+
 ## returns a pointer to an array of children target names
 sub getTargetChildren
 {
@@ -1216,7 +1309,10 @@ sub setMruid
 
     my $type          = $self->getType($target);
     my $mru_prefix_id = $self->{enumeration}->{MRU_PREFIX}->{$type};
-    if ($mru_prefix_id eq "") { $mru_prefix_id = "0xFFFF"; }
+    if (!defined $mru_prefix_id || $mru_prefix_id eq "")
+    {
+         $mru_prefix_id = "0xFFFF";
+    }
     if ($mru_prefix_id eq "0xFFFF") { return; }
     my $index = 0;
     if (defined($self->{mru_idx}->{$node}->{$type}))
@@ -1486,4 +1582,3 @@ Prints to stdout log message is debug mode is turned on.
 Norman James <njames@us.ibm.com>
 
 =cut
-
-- 
2.9.2


From 1911759624ee70fab535787669cff48ed316cdcc Mon Sep 17 00:00:00 2001
From: Stephen Cprek <smcprek@us.ibm.com>
Date: Tue, 30 Aug 2016 09:52:06 -0500
Subject: [PATCH 08/20] Add ability to corrupt a PNOR partition for secureboot
 testing

The ability is triggered via '--corrupt' parameter into hb prime script
which is then is passed along to genPnorImages.pl
e.g. hb prime --corrupt HBI

Change-Id: I56e13b0b1b0eb0978d8ab44ff23a0943ca828d7d
RTC: 125309
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/28959
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Reviewed-by: Nicholas E. Bofferding <bofferdn@us.ibm.com>
Reviewed-by: Michael Baiocchi <mbaiocch@us.ibm.com>
Reviewed-by: Daniel M. Crowell <dcrowell@us.ibm.com>
---
 src/build/buildpnor/genPnorImages.pl | 183 +++++++++++++++++++++++++++--------
 src/build/mkrules/hbfw/img/makefile  |  20 ++--
 src/build/tools/hbDistribute         |  44 +++++++--
 src/usr/vfs/vfsrp.C                  |  10 +-
 src/usr/vfs/vfsrp.H                  |   4 +-
 5 files changed, 199 insertions(+), 62 deletions(-)

diff --git a/src/build/buildpnor/genPnorImages.pl b/src/build/buildpnor/genPnorImages.pl
index 9b18903..333c35a 100755
--- a/src/build/buildpnor/genPnorImages.pl
+++ b/src/build/buildpnor/genPnorImages.pl
@@ -68,6 +68,7 @@ use constant VFS_MODULE_TABLE_ENTRY_SIZE => 112;
 # VFS Module table max size
 use constant VFS_MODULE_TABLE_MAX_SIZE => VFS_EXTENDED_MODULE_MAX
                                           * VFS_MODULE_TABLE_ENTRY_SIZE;
+
 # Flag parameter string passed into signing tools
 # Note spaces before/after are critical.
 use constant LOCAL_SIGNING_FLAG => " -flag ";
@@ -78,6 +79,13 @@ use constant OPAL_FLAG => 0x40000000;
 use constant PHYP_FLAG => 0x20000000;
 use constant KEY_TRANSITION_FLAG => 0x00000001;
 
+# Corrupt parameter strings
+use constant CORRUPT_PROTECTED => "pro";
+use constant CORRUPT_UNPROTECTED => "unpro";
+use constant MAX_PAGES_TO_CORRUPT => 10;
+# rand file prefix string. Note hbDistribute cleans up files with this prefix
+use constant RAND_PREFIX => "rand-";
+
 ################################################################################
 # I/O parsing
 ################################################################################
@@ -91,6 +99,7 @@ my $build_all = 0;
 my $install_all = 0;
 my $key_transition = 0;
 my $help = 0;
+my %partitionsToCorrupt = ();
 
 GetOptions("binDir:s" => \$bin_dir,
            "secureboot" => \$secureboot,
@@ -100,6 +109,7 @@ GetOptions("binDir:s" => \$bin_dir,
            "build-all" => \$build_all,
            "install-all" => \$install_all,
            "key-transition" => \$key_transition,
+           "corrupt:s" => \%partitionsToCorrupt,
            "help" => \$help);
 
 # If in test mode, set key transition
@@ -156,12 +166,11 @@ if($SIGNING_TOOL_EDITION eq COMMUNITY)
     $openSigningTool = 1;
 }
 
+
 # Secureboot command strings
 # Requires naming convention of hw/sw keys in DEV_KEY_DIR
-
 my $SIGN_BUILD_PARAMS = "-skp ${DEV_KEY_DIR}/sw_key_a";
 
-
 # Key prefix used for current key siging of partitions (N/A for open edition)
 my $SIGN_PREFIX_PARAMS = "-hka ${DEV_KEY_DIR}/hw_key_a -hkb "
             . "${DEV_KEY_DIR}/hw_key_b -hkc ${DEV_KEY_DIR}/hw_key_c "
@@ -215,6 +224,28 @@ if ($secureboot)
     die "hw_key_c DNE in $DEV_KEY_DIR" if(!glob("$DEV_KEY_DIR/hw_key_c*"));
     die "sw_key_a DNE in $DEV_KEY_DIR" if(!glob("$DEV_KEY_DIR/sw_key_a*"));
 
+    # Ensure all values of partitionsToCorrupt hash are valid.
+    # Allow some flexibiliy for the user and do a regex, case insensitive check
+    # to properly clean up the corrupt partition hash.
+    foreach my $key (keys %partitionsToCorrupt)
+    {
+        my $value = $partitionsToCorrupt{$key};
+        # ${\(CONST)} is the syntax to allow mixing other regex options like '^'
+        # and '/i' with a perl constant
+        if ($value eq "" || $value =~ m/^${\(CORRUPT_PROTECTED)}/i)
+        {
+            $partitionsToCorrupt{$key} = CORRUPT_PROTECTED
+        }
+        elsif ($value =~ m/^${\(CORRUPT_UNPROTECTED)}/i)
+        {
+            $partitionsToCorrupt{$key} = CORRUPT_UNPROTECTED;
+        }
+        else
+        {
+            die "Error> Unsupported option for --corrupt, value \"$key=$value\"";
+        }
+    }
+
     if(!$openSigningTool)
     {
         # Generate each secureboot header file
@@ -281,7 +312,7 @@ sub manipulateImages
     trace(1, "manipulateImages");
 
     # Prefix for temporary files for parallel builds
-    my $parallelPrefix = "rand-".POSIX::ceil(rand(0xFFFFFFFF)).$system_target;
+    my $parallelPrefix = RAND_PREFIX.POSIX::ceil(rand(0xFFFFFFFF)).$system_target;
 
     # Partitions that have a hash page table at the beginning of the section
     # for secureboot purposes.
@@ -319,7 +350,7 @@ sub manipulateImages
         my $final_bin_file = ($system_target eq "")? "$bin_dir/$eyeCatch.bin":
                                         "$bin_dir/$system_target.$eyeCatch.bin";
 
-        # Get size of parition without ecc
+        # Get size of partition without ecc
         if ($sectionHash{$layoutKey}{ecc} eq "yes")
         {
             $size = page_aligned_size_wo_ecc($size);
@@ -344,6 +375,11 @@ sub manipulateImages
             $openSigningFlags = OP_SIGNING_FLAG.$sb_hdrs{OPAL}{flag};
         }
 
+        # Used for corrupting partitions. By default all protected offsets start
+        # immediately after the container header which is size = PAGE_SIZE.
+        # *Note: this is before ECC.
+        my $protectedOffset = PAGE_SIZE;
+
         # Handle partitions that have an input binary.
         if (-e $bin_file)
         {
@@ -378,6 +414,10 @@ sub manipulateImages
                     if ($tempImages{hashPageTable} ne "" && -e $tempImages{hashPageTable})
                     {
                         trace(1,"Adding hash page table for $eyeCatch");
+                        my $hashPageTableSize = -s $tempImages{hashPageTable};
+                        die "hashPageTable size undefined" unless(defined $hashPageTableSize);
+                        # Move protected offset after hash page table.
+                        $protectedOffset += $hashPageTableSize;
                         if ($eyeCatch eq "HBI")
                         {
                             # Add the VFS module table to the payload text section.
@@ -386,10 +426,12 @@ sub manipulateImages
                             run_command("dd if=$bin_file of=$tempImages{TEMP_BIN} skip=".VFS_EXTENDED_MODULE_MAX." ibs=".VFS_MODULE_TABLE_ENTRY_SIZE);
                             run_command("cp $tempImages{TEMP_BIN} $bin_file");
                             # Pad after hash page table to have the VFS module table end at a 4K boundary
-                            my $hashPageTableSize = -s $tempImages{hashPageTable};
                             my $padSize = PAGE_SIZE - (($hashPageTableSize + VFS_MODULE_TABLE_MAX_SIZE) % PAGE_SIZE);
                             run_command("dd if=/dev/zero bs=$padSize count=1 | tr \"\\000\" \"\\377\" >> $tempImages{hashPageTable} ");
 
+                            # Move protected offset after padding of hash page table.
+                            $protectedOffset += $padSize;
+
                             # Payload text section
                             run_command("cat $tempImages{hashPageTable} $tempImages{VFS_MODULE_TABLE} > $tempImages{PAYLOAD_TEXT} ");
                         }
@@ -469,7 +511,7 @@ sub manipulateImages
                         $preReqImages{HBB_SW_SIG_FILE}) or die "Error opening file $preReqImages{HBB_SW_SIG_FILE}: $!\n";
                         binmode HBB_SW_SIG_FILE;
                         print HBB_SW_SIG_FILE getSwSignatures($tempImages{HDR_PHASE});
-                        die "Error reading of $preReqImages{HBB_SW_SIG_FILE} failed" if $!;
+                        die "Error writing to $preReqImages{HBB_SW_SIG_FILE} failed" if $!;
                         close HBB_SW_SIG_FILE;
                         die "Error closing of $preReqImages{HBB_SW_SIG_FILE} failed" if $!;
                     }
@@ -525,7 +567,7 @@ sub manipulateImages
             if ($eyeCatch eq "HBI" && $testRun)
             {
                 # If "--test" flag set do not pad as the test HBI images is
-                # possibly larger than parition size and does not need to be
+                # possibly larger than partition size and does not need to be
                 # fully padded. Size adjustments made in checkSpaceConstraints
                 run_command("dd if=$tempImages{PREFIX_PHASE} of=$tempImages{PAD_PHASE} ibs=4k conv=sync");
             }
@@ -541,28 +583,17 @@ sub manipulateImages
                 run_command("cp $tempImages{PAD_PHASE} $fsp_file");
             }
 
-            # Leave hacks in here for future testing purposes
-            # Hack HBI page to fail verification, Ensure location is past hash page table
-            #if ($eyeCatch eq "HBI")
-            #{
-                # Corrupt a single byte of the HBI partition at a address after
-                # the hash page table. Use dd with seek to maniuplate a bin file
-                # in-place at a specific location.
-                # run_command("printf \'\\xa1\' | dd conv=notrunc of=$tempImages{PAD_PHASE} bs=1 seek=\$((0x00013000))");
-            #}
-
-            # Hack HBD page to fail verification
-            #if ($eyeCatch eq "HBD")
-            #{
-                # Corrupt a single byte of HBD's RO section
-                # Use dd with seek to maniuplate a bin file in-place at a specific location.
-                #run_command("printf \'\\xa1\' | dd conv=notrunc of=$tempImages{PAD_PHASE} bs=1 seek=\$((0x00004000))");
-
-                # Corrupt a single byte of HBD's RW section
-                # Use dd with seek to maniuplate a bin file in-place at a specific location.
-                # Enusre seek address is after RO section on.
-                # run_command("printf \'\\xa1\' | dd conv=notrunc of=$tempImages{PAD_PHASE} bs=1 seek=\$((0x00044000))");
-            #}
+            # Corrupt section if user specified to do so, before ECC injection.
+            if ($secureboot && exists $partitionsToCorrupt{$eyeCatch})
+            {
+                # If no protected file ($tempImages{PAYLOAD_TEXT}) exists
+                # for this partition, then that means there is no unprotected
+                # section. A protected file is only created when there's a need
+                # to split up the partition for signing purposes.
+                corrupt_partition($eyeCatch, $protectedOffset,
+                                  $tempImages{PAYLOAD_TEXT},
+                                  $tempImages{PAD_PHASE});
+            }
         }
         # Handle partitions that have no input binary. Simply zero or random
         # fill the partition.
@@ -637,6 +668,74 @@ sub manipulateImages
 }
 
 ################################################################################
+# corrupt_partition : Corrupts a single byte of a section's bin file.
+#                     The input $protected_file is used to determine the
+#                     unprotected offset. Some partitions have no unprotected
+#                     section, so the file DNE.
+#                     *Note: this should be run before ECC is injected.
+################################################################################
+sub corrupt_partition
+{
+    my ($eyeCatch, $protected_offset, $protected_file, $bin_file) = @_;
+
+    die "Error> Missing bin file to corrupt $bin_file" if (!-f $bin_file);
+
+    my $section = $partitionsToCorrupt{$eyeCatch};
+    my $offset = 0;
+    my $bin_file_size = -s $bin_file;
+    die "size of $bin_file undef" unless(defined $bin_file_size);
+
+    if ($section eq CORRUPT_PROTECTED)
+    {
+        $offset = $protected_offset;
+    }
+    elsif ($section eq CORRUPT_UNPROTECTED)
+    {
+        # If no protected_file file exists for this partition, then that means
+        # there is no unprotected section. A protected_file is only created
+        # when there's a need to split up the partition for signing purposes.
+        # *Note: Must add PAGE_SIZE to protected size as it does not include
+        #        the secure container header.
+        $offset = (-f $protected_file) ? (-s $protected_file)+PAGE_SIZE : 0;
+        die "offset undef" unless(defined $offset);
+        if ($offset == 0)
+        {
+            die "Error> Section $eyeCatch does not have an unprotected section to corrupt";
+        }
+        elsif ($offset <= $protected_offset)
+        {
+            die "Error> Unprotected offset($offset) <= Protected offset($protected_offset)";
+        }
+    }
+    else
+    {
+        die "Error> Unsupported --corrupt value \"$section\"";
+    }
+
+    # Error checking
+    die "Error> corrupt offset not set" if ($offset == 0);
+    die "Error> Offset=$offset is past the size of the bin file to corrupt size=$bin_file_size" if ($offset >= $bin_file_size);
+
+    # Corrupt partition
+    my $num_pages_to_corrupt = 1;
+    # If corrupting the unprotected HBI section, corrupt multiple pages in
+    # attempt to corrupt a page that is actually used to result in a VFS
+    # verify page failure.
+    if (($eyeCatch eq "HBI") && ($section eq CORRUPT_UNPROTECTED))
+    {
+        $num_pages_to_corrupt = MAX_PAGES_TO_CORRUPT;
+    }
+    for (my $i = 0; $i < $num_pages_to_corrupt; $i++)
+    {
+        my $page_offset = $i*PAGE_SIZE;
+        my $hex_offset = sprintf("0x%X", $offset + $page_offset);
+        trace(1,"Corrupting $eyeCatch $section section offset=$hex_offset");
+        # dd used with seek to manipulate a bin file in-place at a specific location.
+        run_command("printf \'\\xaf\' | dd conv=notrunc of=$bin_file bs=1 seek=\$(($hex_offset))");
+    }
+}
+
+################################################################################
 # page_aligned_size_wo_ecc : Size of partition without ECC, rounded down to
 #                            nearest multiple of PAGE_SIZE.
 ################################################################################
@@ -850,7 +949,7 @@ print <<"ENDUSAGE";
     $programName --pnorlayout <layout xml file>
              --systemBinFiles HBI=hostboot_extended.bin,HBEL=HBEL.bin,GUARD=EMPTY
              --systemBinFiles MURANO:HBD=simics_MURANO_targeting.bin
-             --build-all --test --binDir <path> --secureboot
+             --build-all --test --binDir <path> --secureboot --corrupt HBI
 
   Parms:
     -h|--help           Print this help text
@@ -858,14 +957,22 @@ print <<"ENDUSAGE";
     --build-all         Indicates script should operate as if in ODE build_all
                         This is used to handle things that should happen once in
                         build_all phase and avoid parallel call issues.
-    --systemBinFiles [SYSTEM:]<NAME=FILE,NAME=FILE> CSV of bin files to format. Multiple '--systemBinFiles' allowed
-                                    Optional prefix 'SYSTEM:' used to specify with system bin files are being built.
-                                    For sections <NAME> that simply require zero-filling, you can pass in EMPTY or
-                                        any non-existing file. If a file DNE, the script will handle accordingly.
-                                    Example: HBI=hostboot_extended.bin,GUARD=EMPTY
-                                             MURANO:HBD=simics_MURANO_targeting.bin
-    --test                  Output test-only sections.
-    --secureboot            Indicates a secureboot build.
+    --systemBinFiles    [SYSTEM:]<NAME=FILE,NAME=FILE> CSV of bin files to format. Multiple '--systemBinFiles' allowed
+                            Optional prefix 'SYSTEM:' used to specify with system bin files are being built.
+                            For sections <NAME> that simply require zero-filling, you can pass in EMPTY or
+                                any non-existing file. If a file DNE, the script will handle accordingly.
+                            Example: HBI=hostboot_extended.bin,GUARD=EMPTY
+                                     MURANO:HBD=simics_MURANO_targeting.bin
+    --test              Output test-only sections.
+    --secureboot        Indicates a secureboot build.
+    --corrupt           <Partition name>[= pro|unpro] (Note: requires '--secureboot')
+                        Partition 'eyeCatch' name to corrupt a byte of.
+                        Optional '= pro|unpro' to indicate which section of the secure container to corrupt.
+                            Default (empty string '') is protected section.
+                            [Note: Some sections only have a protected section so not relevant for all.]
+                        Multiple '--corrupt' options are allowed, but note the system will checkstop on the
+                            first bad partition so multiple may not be that useful.
+                        Example: --corrupt HBI --corrupt HBD=unpro
 
   Current Limitations:
     - Issues with dependency on ENGD build for certain files such as SBE. This
diff --git a/src/build/mkrules/hbfw/img/makefile b/src/build/mkrules/hbfw/img/makefile
index aacb7a6..4cc1762 100755
--- a/src/build/mkrules/hbfw/img/makefile
+++ b/src/build/mkrules/hbfw/img/makefile
@@ -52,18 +52,15 @@ ENGD_OBJPATH = ${HBFW_OBJPATH:S/hbfw\/img/engd\/href/g}
 # changes expected in the future which will require using OBJ version.
 #################################################
 BASE_IMAGE = hostboot.bin
+BASE_ECC_IMAGE = hostboot.bin.ecc
+BASE_FINAL_IMAGE = HBB.bin
 EXT_IMAGE =  hostboot_extended.bin
 EXT_FINAL_IMAGE = HBI.bin
-BASE_FINAL_IMAGE = HBB.bin
 HBRT_IMAGE = hostboot_runtime.bin
 HBRT_SHA_IMAGE = hostboot_runtime.sha.bin
 HBRT_HEADER_IMAGE = hostboot_runtime.header.bin
 HBRT_ECC_HEADER_IMAGE = hostboot_runtime.header.bin.ecc
 BASE_IMAGES = ${BASE_IMAGE} ${EXT_IMAGE} ${HBRT_IMAGE}
-BASE_W_HEADER_IMAGE = hostboot.header.bin
-BASE_W_HEADER_ECC_IMAGE = hostboot.header.bin.ecc
-BASE_ECC_IMAGE = hostboot.bin.ecc
-BASE_SHA_IMAGE = hostboot.sha.bin
 TEMP_IMAGE = hostboot.temp.bin
 # Zero filled sections final bin names
 TEST_IMAGE = TEST.bin
@@ -79,10 +76,9 @@ SBKT_IMAGE = SBKT.bin
 ZERO_FILL_IMAGES = ${TEST_IMAGE} ${TESTRO_IMAGE} ${HBEL_IMAGE} ${GUARD_IMAGE} \
                    ${GLOBAL_IMAGE} ${DJVPD_IMAGE} ${MVPD_IMAGE} ${CVPD_IMAGE} \
                    ${PAYLOAD_IMAGE} ${SBKT_IMAGE}
-ALL_HB_IMAGES = ${BASE_IMAGES} ${BASE_W_HEADER_IMAGE} ${BASE_ECC_IMAGE}\
-                ${BASE_W_HEADER_ECC_IMAGE} ${BASE_SHA_IMAGE} ${HBRT_SHA_IMAGE} \
-                ${HBRT_HEADER_IMAGE} ${HBRT_ECC_HEADER_IMAGE} \
-                ${EXT_FINAL_IMAGE} ${BASE_FINAL_IMAGE} ${ZERO_FILL_IMAGES}
+ALL_HB_IMAGES = ${BASE_IMAGES} ${HBRT_SHA_IMAGE} ${HBRT_HEADER_IMAGE} \
+                ${HBRT_ECC_HEADER_IMAGE} ${EXT_FINAL_IMAGE} \
+                ${BASE_FINAL_IMAGE} ${ZERO_FILL_IMAGES}
 
 # Script to manipulate bin files to prepare for buildpnor (install_all phase)
 GEN_PNOR_IMAGE_SCRIPT = ${genPnorImages.pl:P}
@@ -116,7 +112,8 @@ gen_default_images: cp_hbfiles
 	# HBI + HBB partitions and ZERO_FILL_IMAGES
 	${GEN_PNOR_IMAGE_SCRIPT} --build-all ${TARGET_TEST:b--test} \
 		${CONFIG_SECUREBOOT:b--secureboot} --systemBinFiles ${GEN_DEFAULT_BIN_FILES} \
-		--pnorLayout ${DEFAULT_PNOR_LAYOUT} ${KEY_TRANSITION:b--key-transition}
+		--pnorLayout ${DEFAULT_PNOR_LAYOUT} ${KEY_TRANSITION:b--key-transition} \
+		${CORRUPT_PARAMS}
 	rm ${TEMP_IMAGE}
 
 clobber_gen_default_images:
@@ -251,11 +248,12 @@ gen_system_specific_images: build_sbe_partitions
 	ecc --inject ${TEMP_IMG} --output ${VENICE_LOCAL_SLW_IMG_ECC} --p8;
 	# Eventually use genPnorImages for every system specific image
 	${GEN_PNOR_IMAGE_SCRIPT} ${TARGET_TEST:b--test} ${CONFIG_SECUREBOOT:b--secureboot} \
-		--pnorLayout ${DEFAULT_PNOR_LAYOUT} \
+		--pnorLayout ${DEFAULT_PNOR_LAYOUT} ${CORRUPT_PARAMS} \
 		--systemBinFiles ${GEN_MURANO_BIN_FILES} \
 		--systemBinFiles ${GEN_NAPLES_BIN_FILES} \
 		--systemBinFiles ${GEN_VENICE_BIN_FILES} \
 		--systemBinFile  SBEC=${${SBEC_IMG}:P}
+
 	rm ${TEMP_IMG}
 
 MURANO_SECT = HBD=${MURANO_TARG_FINAL_IMG},SBE=${MURANO_SBE_FINAL_IMG},SBEC=${SBEC_FINAL_IMG},WINK=${MURANO_LOCAL_SLW_IMG_ECC}
diff --git a/src/build/tools/hbDistribute b/src/build/tools/hbDistribute
index 3e7d18d..8e86d66 100755
--- a/src/build/tools/hbDistribute
+++ b/src/build/tools/hbDistribute
@@ -26,6 +26,7 @@
 TARGET_DIR="invalid directory"
 TARGET="fsp_TARGET"
 TEST_TEST=0
+CORRUPT_PARAMS=""
 
 print_usage()
 {
@@ -50,40 +51,55 @@ print_usage()
 }
 
 # Parse arguments
-for ARG in $*
+while [[ $# -gt 0 ]]
 do
-    case $ARG in
+    case $1 in
         "--help")
             print_usage
-            exit
+            exit -1
         ;;
 
         "--test")
             TARGET_TEST=1
+            shift
         ;;
 
         "--vpo")
             TARGET="vpo_TARGET"
+            shift
         ;;
 
         "--simics" | "--fsp")
             TARGET="fsp_TARGET"
+            shift
         ;;
 
         "--openpower")
             TARGET="openpower_TARGET"
+            shift
         ;;
 
         "--release")
             TARGET="ALL"
+            shift
         ;;
 
         "--debug")
             DEBUG="-d"
+            shift
         ;;
 
         "--hb-standalone")
             HB_STANDALONE=1
+            shift
+        ;;
+
+        "--corrupt")
+            # Format is "--corrupt <partition[=pro|unpro]>"
+            CORRUPT_PARAMS="$CORRUPT_PARAMS $1"
+            shift
+            CORRUPT_PARAMS="$CORRUPT_PARAMS $1"
+            shift
         ;;
 
         "--key-transition")
@@ -91,12 +107,13 @@ do
         ;;
 
         --*)
-            echo "ERROR: Unknown option: $ARG"
-            exit
+            echo "ERROR: Unknown option: $1"
+            exit -1
         ;;
 
         *)
-            TARGET_DIR=$ARG
+            TARGET_DIR=$1
+            shift
         ;;
 
     esac
@@ -107,7 +124,7 @@ if [ "${TARGET_DIR}" == "invalid directory" ]; then
     if [ -z "${SANDBOXROOT}" -o -z "${SANDBOXNAME}" ]; then
         echo "ERROR: No path specified and \$SANDBOXBASE undefined."
         print_usage
-        exit
+        exit -1
     else
         TARGET_DIR=${SANDBOXROOT}/${SANDBOXNAME}/src/hbfw
     fi
@@ -120,7 +137,7 @@ else
     REPO_ROOT=`git rev-parse --show-toplevel`
     if [ -z $REPO_ROOT ]; then
         echo "ERROR: Not in a git repo."
-        exit
+        exit -1
     fi
 fi
 
@@ -141,11 +158,22 @@ else
     exit -1
 fi
 
+# Clean up preivous rand files. Should only be needed if a previous call failed.
+# Done before dist.targets.mk because there are parallel operations that occur.
+# So if we delete in genPnorImages.pl we would wipe out stuff currently being
+# used elsewhere and cause a file not found error.
+# Note: Prefix is set by genPnorImages.pl
+rm -f ${SANDBOXROOT}/${SANDBOXNAME}/obj/ppc/hbfw/img/rand-*
+
 # Execute makefile for distribution.
 mkdir -p $TARGET_DIR
 export TARGET_TEST
 export TARGET_DIR
 export HB_STANDALONE
 export KEY_TRANSITION
+export CORRUPT_PARAMS
+if [ -n "$CORRUPT_PARAMS" ]; then
+    echo "Corruption options = $CORRUPT_PARAMS"
+fi
 cd $REPO_ROOT/src/build/mkrules
 make -rR ${DEBUG:=} -f dist.targets.mk $TARGET
diff --git a/src/usr/vfs/vfsrp.C b/src/usr/vfs/vfsrp.C
index e7b3b6c..bea0bb7 100644
--- a/src/usr/vfs/vfsrp.C
+++ b/src/usr/vfs/vfsrp.C
@@ -170,10 +170,12 @@ errlHndl_t VfsRp::_init()
         iv_hashPageTableOffset = iv_pnor_vaddr;
 
         // calculate the hash page table size
-        TRACFCOMP(g_trac_vfs, "VfsRp::_init HB_EXT payload_text_size = 0x%X",
+        TRACFCOMP(g_trac_vfs, "VfsRp::_init HB_EXT total payload_text_size = 0x%X",
                     l_pnor_info.secureProtectedPayloadSize);
         iv_hashPageTableSize = l_pnor_info.secureProtectedPayloadSize
                                                        - VFS_MODULE_TABLE_SIZE;
+        TRACFCOMP(g_trac_vfs, "VfsRp::_init HB_EXT hash page table size = 0x%X",
+                    iv_hashPageTableSize);
         // skip the hash page table
         iv_pnor_vaddr += iv_hashPageTableSize;
         #endif
@@ -393,7 +395,7 @@ uint64_t VfsRp::verify_page(uint64_t i_vaddr, uint64_t i_baseOffset,
     TRACDCOMP(g_trac_vfs, "VfsRp::verify_page Current Page vaddr = 0x%llX, index = %d, bin file offset = 0x%llX",
              i_vaddr,
              getHashPageTableIndex(i_vaddr,i_baseOffset),
-             i_vaddr+PAGE_SIZE+iv_hashPageTableSize);
+             i_vaddr+PAGE_SIZE+iv_payloadTextSize);
     PAGE_TABLE_ENTRY_t* l_pageTableEntry = getHashPageTableEntry(i_vaddr,
                                                         i_baseOffset,
                                                         i_hashPageTableOffset);
@@ -403,7 +405,7 @@ uint64_t VfsRp::verify_page(uint64_t i_vaddr, uint64_t i_baseOffset,
     TRACDCOMP(g_trac_vfs, "VfsRp::verify_page Prev Page vaddr = 0x%llX, index = %d, bin file offset = 0x%llX",
              l_prevPage,
              getHashPageTableIndex(l_prevPage,i_baseOffset),
-             i_vaddr+PAGE_SIZE+iv_hashPageTableSize);
+             i_vaddr+PAGE_SIZE+iv_payloadTextSize);
     PAGE_TABLE_ENTRY_t* l_prevPageTableEntry = getHashPageTableEntry(
                                                         l_prevPage,
                                                         i_baseOffset,
@@ -424,7 +426,7 @@ uint64_t VfsRp::verify_page(uint64_t i_vaddr, uint64_t i_baseOffset,
     {
         TRACFCOMP(g_trac_vfs, "ERROR:>VfsRp::verify_page secureboot verify fail on vaddr 0x%llX, offset into HBI 0x%llX",
                               i_vaddr,
-                              i_vaddr+PAGE_SIZE+iv_hashPageTableSize);
+                              i_vaddr+PAGE_SIZE+iv_payloadTextSize);
         printk("Secureboot Verification Failure in HBI\n");
         rc = EACCES;
     }
diff --git a/src/usr/vfs/vfsrp.H b/src/usr/vfs/vfsrp.H
index 3a43813..197932b 100644
--- a/src/usr/vfs/vfsrp.H
+++ b/src/usr/vfs/vfsrp.H
@@ -94,7 +94,8 @@ namespace VFS
              * Ctor
              */
             VfsRp() : iv_msgQ(NULL), iv_msg(NULL), iv_pnor_vaddr(0),
-                      iv_hashPageTableOffset(0),iv_hashPageTableSize(0)
+                      iv_hashPageTableOffset(0),iv_hashPageTableSize(0),
+                      iv_payloadTextSize(0)
             {
                 mutex_init(&iv_mutex);
             }
@@ -252,6 +253,7 @@ namespace VFS
             uint64_t iv_pnor_vaddr;  //!< virtual address of ext image in PNOR
             uint64_t iv_hashPageTableOffset; //!< virtual address of hashPageTable of ext image
             uint64_t iv_hashPageTableSize; //!< size of hashPageTable of ext image
+            uint64_t iv_payloadTextSize; //!< size of entire protected payload
 
             typedef std::vector<VfsSystemModule *> ModuleList_t;
 
-- 
2.9.2


From 78d3e7d31e931861b21453afeaa13fa41bba162a Mon Sep 17 00:00:00 2001
From: Nick Bofferding <bofferdn@us.ibm.com>
Date: Mon, 26 Sep 2016 23:35:42 -0500
Subject: [PATCH 09/20] Set ab/pci/pb boundary PLL scan selects and chiplet IDs

- Set ab/pci/pb boundary PLL scan selects and chiplet IDs
- When customized to non-master SBE images, allows scan service to work

Change-Id: I5564c94c725324af84161474f9dc6fc3bfc21711
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/30334
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Reviewed-by: Michael Baiocchi <mbaiocch@us.ibm.com>
Reviewed-by: Stephen M. Cprek <smcprek@us.ibm.com>
Reviewed-by: Daniel M. Crowell <dcrowell@us.ibm.com>
---
 src/usr/targeting/common/xmltohb/attribute_types.xml | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/src/usr/targeting/common/xmltohb/attribute_types.xml b/src/usr/targeting/common/xmltohb/attribute_types.xml
index 9e1fe29..5233e50 100644
--- a/src/usr/targeting/common/xmltohb/attribute_types.xml
+++ b/src/usr/targeting/common/xmltohb/attribute_types.xml
@@ -9962,7 +9962,7 @@ Measured in GB</description>
     </description>
     <simpleType>
         <uint8_t>
-            <default>0</default>
+            <default>0x02</default>
         </uint8_t>
     </simpleType>
     <persistency>volatile</persistency>
@@ -9982,7 +9982,7 @@ Measured in GB</description>
     </description>
     <simpleType>
         <uint8_t>
-            <default>0</default>
+            <default>0x08</default>
         </uint8_t>
     </simpleType>
     <persistency>volatile</persistency>
@@ -10002,7 +10002,7 @@ Measured in GB</description>
     </description>
     <simpleType>
         <uint8_t>
-            <default>0</default>
+            <default>0x09</default>
         </uint8_t>
     </simpleType>
     <persistency>volatile</persistency>
@@ -10042,7 +10042,7 @@ Measured in GB</description>
     </description>
     <simpleType>
         <uint32_t>
-            <default>0</default>
+            <default>0x00100008</default>
         </uint32_t>
     </simpleType>
     <persistency>volatile</persistency>
@@ -10062,7 +10062,7 @@ Measured in GB</description>
     </description>
     <simpleType>
         <uint32_t>
-            <default>0</default>
+            <default>0x00100008</default>
         </uint32_t>
     </simpleType>
     <persistency>volatile</persistency>
@@ -10082,7 +10082,7 @@ Measured in GB</description>
     </description>
     <simpleType>
         <uint32_t>
-            <default>0</default>
+            <default>0x00100008</default>
         </uint32_t>
     </simpleType>
     <persistency>volatile</persistency>
-- 
2.9.2


From a5e4bdf334777965d8fb0f917420550775b043e8 Mon Sep 17 00:00:00 2001
From: Nick Bofferding <bofferdn@us.ibm.com>
Date: Fri, 30 Sep 2016 13:19:23 -0500
Subject: [PATCH 10/20] Enable trusted scan path after building SMP

Change-Id: Ia3ceeea75d312f8a06a5c1024867a9ed921a9b77
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/30569
Reviewed-by: Michael Baiocchi <mbaiocch@us.ibm.com>
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Reviewed-by: Stephen M. Cprek <smcprek@us.ibm.com>
Reviewed-by: Daniel M. Crowell <dcrowell@us.ibm.com>
---
 src/usr/hwpf/hwp/activate_powerbus/activate_powerbus.C | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/src/usr/hwpf/hwp/activate_powerbus/activate_powerbus.C b/src/usr/hwpf/hwp/activate_powerbus/activate_powerbus.C
index 642b539..7879db3 100644
--- a/src/usr/hwpf/hwp/activate_powerbus/activate_powerbus.C
+++ b/src/usr/hwpf/hwp/activate_powerbus/activate_powerbus.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2012,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2012,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -324,6 +324,11 @@ void*    call_proc_build_smp( void    *io_pArgs )
             ++curproc;
         }
 
+        // Enable the trusted scan path
+        TARGETING::TargetHandle_t pSys=NULL;
+        TARGETING::targetService().getTopLevelTarget(pSys);
+        assert(pSys!=NULL,"System target must not be NULL");
+        pSys->setAttr<TARGETING::ATTR_TRUSTED_SLAVE_SCAN_PATH_ACTIVE>(true);
 
     } while (0);
 
-- 
2.9.2


From 9ffca215f6313925e331e184987f417603d4fd6d Mon Sep 17 00:00:00 2001
From: Stephen Cprek <smcprek@us.ibm.com>
Date: Fri, 16 Sep 2016 13:12:10 -0500
Subject: [PATCH 11/20] Limit memory allocation when loading OCC from PNOR

Change-Id: Ia1b76c894f5964bb279fb2eb339840dc76941d1a
RTC: 160680
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/29858
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Reviewed-by: Michael Baiocchi <mbaiocch@us.ibm.com>
Reviewed-by: Nicholas E. Bofferding <bofferdn@us.ibm.com>
Reviewed-by: Daniel M. Crowell <dcrowell@us.ibm.com>
---
 src/include/usr/hwpf/hwpf_reasoncodes.H |   2 +
 src/include/usr/util/utillidmgr.H       |  22 ++++-
 src/usr/hwpf/hwp/occ/occ_common.C       | 145 ++++++++++++++++++++++++++------
 3 files changed, 144 insertions(+), 25 deletions(-)

diff --git a/src/include/usr/hwpf/hwpf_reasoncodes.H b/src/include/usr/hwpf/hwpf_reasoncodes.H
index ebc0492..9d288ce 100644
--- a/src/include/usr/hwpf/hwpf_reasoncodes.H
+++ b/src/include/usr/hwpf/hwpf_reasoncodes.H
@@ -85,6 +85,7 @@ namespace fapi
         MOD_FIND_MIN_DMI_SPD                       = 0x2B,
         MOD_OCC_LOAD_HOST_DATA_TO_SRAM             = 0x2C,
         MOD_START_XZ_PAYLOAD                       = 0x2D,
+        MOD_LOAD_OCC_IMAGE_DURING_IPL              = 0x2E
     };
 
     /**
@@ -147,6 +148,7 @@ namespace fapi
         RC_INVALID_WOF_INDEX          = HWPF_COMP_ID | 0x3C,
         RC_ECMD_INSERT_FAILED         = HWPF_COMP_ID | 0x3D,
         RC_INVALID_RETURN_XZ_CODE     = HWPF_COMP_ID | 0x3E,
+        RC_ECMD_INSERT_REMAINING_FAILED = HWPF_COMP_ID | 0x3F,
     };
 
     /**
diff --git a/src/include/usr/util/utillidmgr.H b/src/include/usr/util/utillidmgr.H
index ae37c11..5e0e948 100644
--- a/src/include/usr/util/utillidmgr.H
+++ b/src/include/usr/util/utillidmgr.H
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2013,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2013,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -141,6 +141,26 @@ class UtilLidMgr
      */
     errlHndl_t getLid(void* i_dest, size_t i_destSize);
 
+    /**
+     *  @brief Get lid managers' pointer to the lid vaddr.
+     *
+     *  @return void* - Returns pointer to virtual address the lid lives in.
+     *                  Null if the lid is not in virtual address space.
+     *                  NOTE: Only supporting PNOR Virt Addr now
+     */
+    inline const void* getLidVirtAddr() const
+    {
+        const void* l_addr = NULL;
+        // Get pointer to PNOR vaddr
+        if (iv_isLidInPnor)
+        {
+            l_addr = reinterpret_cast<const void*>(iv_lidPnorInfo.vaddr);
+        }
+        // Add support for other virtual address spaces here
+
+        return l_addr;
+    }
+
 #ifdef __HOSTBOOT_RUNTIME
     /**
      * @brief Get a list of LID numbers
diff --git a/src/usr/hwpf/hwp/occ/occ_common.C b/src/usr/hwpf/hwp/occ/occ_common.C
index 1a88532..c5f43bc 100644
--- a/src/usr/hwpf/hwp/occ/occ_common.C
+++ b/src/usr/hwpf/hwp/occ/occ_common.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2013,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2013,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -135,10 +135,8 @@ namespace HBOCC
         errlHndl_t l_errl = NULL;
         size_t lidSize = 0;
         void* l_occImage = NULL;
-        do {
-            // allocate memory big enough for all OCC
-            l_occImage = (void*)malloc(1*MEGABYTE);
 
+        do {
             UtilLidMgr lidMgr(HBOCC::OCC_LIDID);
 
             // Get the size of the OCC lid
@@ -151,22 +149,38 @@ namespace HBOCC
                 break;
             }
 
-            // Ensure occ lid size is less than memory allocated for it
-            assert(lidSize <= 1*MEGABYTE);
+            // Check if lid is in virtual address space to save on allocating
+            // a large local buffer to copy data to.
+            bool l_lidInVirtMem = false;
+            // Try to use virtual address space for accessing the lid
+            l_occImage = const_cast<void*>(lidMgr.getLidVirtAddr());
+            // Get lid from non virtual address space.
+            if( l_occImage == NULL )
+            {
+                // allocate memory big enough for all OCC
+                l_occImage = reinterpret_cast<void*>(malloc(1*MEGABYTE));
+
+                // Ensure occ lid size is less than memory allocated for it
+                assert(lidSize <= 1*MEGABYTE);
 
-            // Get the entire OCC lid and write it into temporary memory
-            l_errl = lidMgr.getLid(l_occImage, lidSize);
-            if(l_errl)
+                // Get the entire OCC lid and write it into temporary memory
+                l_errl = lidMgr.getLid(l_occImage, lidSize);
+                if(l_errl)
+                {
+                    TRACFCOMP( g_fapiImpTd,
+                               ERR_MRK"loadOCCImageDuringIpl: Error getting lid. lidId=0x%.8x",
+                               OCC_LIDID);
+                    break;
+                }
+            }
+            else
             {
-                TRACFCOMP( g_fapiImpTd,
-                           ERR_MRK"loadOCCImageDuringIpl: Error getting lid. lidId=0x%.8x",
-                           OCC_LIDID);
-                break;
+                l_lidInVirtMem = true;
             }
+
             // Pointer to OCC LID
             char *l_occLid = reinterpret_cast<char*>(l_occImage);
 
-
             // Get system target in order to access ATTR_NEST_FREQ_MHZ
             TARGETING::TargetService & tS = TARGETING::targetService();
             TARGETING::Target * sysTarget = NULL;
@@ -177,12 +191,11 @@ namespace HBOCC
             ATTR_NEST_FREQ_MHZ_type l_nestFreq =
                                      sysTarget->getAttr<ATTR_FREQ_PB>();
 
-
             size_t l_length = 0; // length of this section
             size_t l_startOffset = 0; // offset to start of the section
 
             // offset to length of the section
-            size_t l_offsetToLength = OCC_OFFSET_LENGTH; 
+            size_t l_offsetToLength = OCC_OFFSET_LENGTH;
 
             // Get length of OCC bootloader
             uint32_t *ptrToLength = (uint32_t *)(l_occLid + l_offsetToLength);
@@ -194,16 +207,28 @@ namespace HBOCC
             // Write the OCC Bootloader into memory
             memcpy(i_occVirtAddr, l_occImage, l_length);
 
-
             // OCC Main Application
             l_startOffset = l_length; // after the Boot image
             char * l_occMainAppPtr = reinterpret_cast<char *>(l_occLid) +
-                            l_startOffset;
+                                     l_startOffset;
 
             // Get the length of the OCC Main application
             ptrToLength = (uint32_t *)(l_occMainAppPtr + l_offsetToLength);
             l_length = *ptrToLength;
+            size_t l_occMainLength = l_length;
 
+            // If LID is in vaddr space we do not want to modify directly.
+            if (l_lidInVirtMem)
+            {
+                // Allocate memory for size of modified section.
+                // [ipl flag and freq]
+                l_length = OCC_OFFSET_FREQ + sizeof(ATTR_NEST_FREQ_MHZ_type);
+                l_occImage = reinterpret_cast<void*>(malloc(l_length));
+                // Fill in modify buffer from pnor vaddr.
+                memcpy(l_occImage, l_occMainAppPtr, l_length);
+                // Move occ main app pointer
+                l_occMainAppPtr = reinterpret_cast<char*>(l_occImage);
+            }
 
             // write the IPL flag and the nest freq into OCC main app.
             // IPL_FLAG is a two byte field.  OR a 1 into these two bytes.
@@ -221,17 +246,90 @@ namespace HBOCC
 
             // Store the OCC Main applicatoin into ecmdDataBuffer
             // so we may write it to SRAM
-            ecmdDataBufferBase l_occAppData(l_length * 8 /* bits */);
-            uint32_t rc = l_occAppData.insert((uint32_t *)l_occMainAppPtr, 0,
+            TRACDCOMP( g_fapiImpTd, "loadOCCImageDuringIpl: ecmdDataBufferBase size = 0x%X",
+                       l_occMainLength);
+
+            ecmdDataBufferBase l_occAppData(l_occMainLength * 8 /* bits */);
+            assert(l_length < l_occMainLength, "Cannot write more OCC data than the ECMD buffer has rooom for. write size = 0x%X, ECMD buffer size = 0x%X",
+                       l_length, l_occMainLength);
+            uint32_t rc = l_occAppData.insert(
+                                reinterpret_cast<uint32_t *>(l_occMainAppPtr),
+                                0,
                                 l_length * 8 /* bits */);
             if (rc)
             {
                 TRACFCOMP( g_fapiImpTd,
-                           ERR_MRK"loadOCCImageDuringIpl: Error %d doing insert",
-                           rc);
-                // create l_errl
+                           ERR_MRK"loadOCCImageDuringIpl: Error %d doing insert, write size = 0x%X, ECMD buffer size = 0x%X",
+                           rc, l_length, l_occMainLength);
+                /*@
+                 * @errortype
+                 * @severity     ERRORLOG::ERRL_SEV_UNRECOVERABLE
+                 * @moduleid     fapi::MOD_LOAD_OCC_IMAGE_DURING_IPL
+                 * @reasoncode   fapi::RC_ECMD_INSERT_FAILED
+                 * @userdata1    Return Code
+                 * @userdata2    Data size to insert
+                 * @devdesc      ecmd insert failed for l_occAppData
+                 * @custdesc     A problem occurred during the IPL
+                 *               of the system.
+                 */
+                l_errl = new ERRORLOG::ErrlEntry(
+                                          ERRORLOG::ERRL_SEV_UNRECOVERABLE,
+                                          fapi::MOD_LOAD_OCC_IMAGE_DURING_IPL,
+                                          fapi::RC_ECMD_INSERT_FAILED,
+                                          rc,
+                                          l_length,
+                                          true);
+                l_errl->collectTrace(FAPI_TRACE_NAME,256);
+                l_errl->collectTrace(FAPI_IMP_TRACE_NAME,256);
                 break;
             }
+
+            // If the lid is in vaddr space we only wrote the modify length to
+            // ECMD buffer. Now need to write the rest here.
+            if(l_lidInVirtMem)
+            {
+                size_t l_remainingSize = (l_occMainLength - l_length);
+                // Move occ main pointer back to PNOR vaddr + modified length
+                l_occMainAppPtr = reinterpret_cast<char *>(l_occLid) +
+                                  l_startOffset + l_length;
+
+                // Write to rest of OCC Main to buffer. This means Main app size
+                // minus the modified size.
+                rc = l_occAppData.insert(
+                                reinterpret_cast<uint32_t *>(l_occMainAppPtr),
+                                l_length * 8 /* bits */,
+                                l_remainingSize * 8 /* bits */);
+                if (rc)
+                {
+                    TRACFCOMP( g_fapiImpTd,
+                               ERR_MRK"loadOCCImageDuringIpl: Error %d doing insert of remaining data, write size = 0x%X, ECMD buffer size = 0x%X",
+                               rc,
+                               l_remainingSize,
+                               l_occMainLength);
+                    /*@
+                     * @errortype
+                     * @severity     ERRORLOG::ERRL_SEV_UNRECOVERABLE
+                     * @moduleid     fapi::MOD_LOAD_OCC_IMAGE_DURING_IPL
+                     * @reasoncode   fapi::RC_ECMD_INSERT_REMAINING_FAILED
+                     * @userdata1    Return Code
+                     * @userdata2    Remaining data size to insert
+                     * @devdesc      ecmd insert failed for l_occAppData
+                     * @custdesc     A problem occurred during the IPL
+                     *               of the system.
+                     */
+                    l_errl = new ERRORLOG::ErrlEntry(
+                                          ERRORLOG::ERRL_SEV_UNRECOVERABLE,
+                                          fapi::MOD_LOAD_OCC_IMAGE_DURING_IPL,
+                                          fapi::RC_ECMD_INSERT_REMAINING_FAILED,
+                                          rc,
+                                          l_remainingSize,
+                                          true);
+                    l_errl->collectTrace(FAPI_TRACE_NAME,256);
+                    l_errl->collectTrace(FAPI_IMP_TRACE_NAME,256);
+                    break;
+                }
+            }
+
             // Write the OCC Main app into SRAM
             const uint32_t l_SramAddrApp = OCC_SRAM_ADDRESS;
             l_errl = HBOCC::writeSRAM(i_target, l_SramAddrApp, l_occAppData);
@@ -242,7 +340,6 @@ namespace HBOCC
                 break;
             }
 
-
         }while(0);
 
         //free memory used for OCC lid
-- 
2.9.2


From 040e1b40f2ba7fcd27942d6dd6e1fd733bddd787 Mon Sep 17 00:00:00 2001
From: Nick Bofferding <bofferdn@us.ibm.com>
Date: Sat, 1 Oct 2016 00:48:27 -0500
Subject: [PATCH 12/20] Enable Centaur security protections in secure mode

Change-Id: Ie475fa47d138c6c39509951ec39992f482cd8788
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/30587
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Reviewed-by: Michael Baiocchi <mbaiocch@us.ibm.com>
Reviewed-by: Stephen M. Cprek <smcprek@us.ibm.com>
Reviewed-by: William G. Hoffa <wghoffa@us.ibm.com>
---
 src/build/tools/listdeps.pl                        |   3 +-
 .../hwp/dram_initialization/dram_initialization.C  | 102 ++++++++++++++++++++-
 2 files changed, 103 insertions(+), 2 deletions(-)

diff --git a/src/build/tools/listdeps.pl b/src/build/tools/listdeps.pl
index 4d1b6f6..813bae4 100755
--- a/src/build/tools/listdeps.pl
+++ b/src/build/tools/listdeps.pl
@@ -6,7 +6,7 @@
 #
 # OpenPOWER HostBoot Project
 #
-# Contributors Listed Below - COPYRIGHT 2013,2015
+# Contributors Listed Below - COPYRIGHT 2013,2016
 # [+] Google Inc.
 # [+] International Business Machines Corp.
 #
@@ -219,6 +219,7 @@ my $resident_modules = {
     "libipmi.so"           => '1',
     "libvpd.so"            => '1',
     "libsecureboot_trusted.so" => '1',
+    "libsecureboot_base.so" => '1',
 };
 
 # has with library to istep list file were the DepMod array is kept
diff --git a/src/usr/hwpf/hwp/dram_initialization/dram_initialization.C b/src/usr/hwpf/hwp/dram_initialization/dram_initialization.C
index 9702866..2c0dae8 100644
--- a/src/usr/hwpf/hwp/dram_initialization/dram_initialization.C
+++ b/src/usr/hwpf/hwp/dram_initialization/dram_initialization.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2012,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2012,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -35,6 +35,7 @@
 /******************************************************************************/
 // Includes
 /******************************************************************************/
+#include    <config.h>
 #include    <stdint.h>
 #include    <trace/interface.H>
 #include    <initservice/taskargs.H>
@@ -86,6 +87,10 @@
     #include    <occ/occ_common.H>
 #endif
 
+#ifdef CONFIG_SECUREBOOT
+#include <secureboot/service.H>
+#endif
+
 namespace   DRAM_INITIALIZATION
 {
 
@@ -892,6 +897,99 @@ void*    call_proc_exit_cache_contained( void    *io_pArgs )
         }
     }
 
+    #ifdef CONFIG_SECUREBOOT
+    // Enable membuf protections to prevent future clock starts if
+    // security enabled
+    if(!l_errl && SECUREBOOT::enabled())
+    {
+        uint64_t scomData = 0;
+        size_t size = sizeof(scomData);
+        const size_t expSize = size;
+        const uint64_t SYNC_CONFIG_CHIP_PROTECTION_ENABLE_BIT =
+            0x0002000000000000ull;
+        const uint64_t CENT_TP_SYNC_CONFIG_REG_0x01030000   = 0x01030000;
+        const uint64_t CENT_NEST_SYNC_CONFIG_REG_0x02030000 = 0x02030000;
+        const uint64_t CENT_MEM_SYNC_CONFIG_REG_0x03030000  = 0x03030000;
+
+        const uint64_t centSyncConfigReg[] =
+        {
+            CENT_TP_SYNC_CONFIG_REG_0x01030000,
+            CENT_NEST_SYNC_CONFIG_REG_0x02030000,
+            CENT_MEM_SYNC_CONFIG_REG_0x03030000
+        };
+
+        TARGETING::TargetHandleList membufList;
+        getAllChips(membufList, TYPE_MEMBUF, true);
+
+        for (  TargetHandleList::const_iterator pMembuf
+             = membufList.begin();
+             pMembuf != membufList.end();
+             ++pMembuf)
+        {
+            for(size_t i=0;
+                i<sizeof(centSyncConfigReg)/sizeof(centSyncConfigReg[0]);
+                ++i)
+            {
+                uint64_t scomAddr = centSyncConfigReg[i];
+                scomData = 0;
+
+                l_errl = DeviceFW::deviceRead(
+                    *pMembuf,
+                    &scomData,
+                    size,
+                    DEVICE_SCOM_ADDRESS(scomAddr));
+                if(l_errl)
+                {
+                    TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
+                        ERR_MRK "Failed to read 0x%08X SCOM register for "
+                        "target 0x%08X. Cannot enable chip protection.",
+                        scomAddr,
+                        TARGETING::get_huid(*pMembuf));
+                    break;
+                }
+
+                assert(size == expSize,
+                    "SCOM deviceRead returned size of %d, expected %d",
+                    size,expSize);
+
+                scomData |= SYNC_CONFIG_CHIP_PROTECTION_ENABLE_BIT;
+
+                l_errl = DeviceFW::deviceWrite(
+                    *pMembuf,
+                    &scomData,
+                    size,
+                    DEVICE_SCOM_ADDRESS(scomAddr));
+                if(l_errl)
+                {
+                    TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
+                        ERR_MRK "Failed to write 0x%08X SCOM register for "
+                        "target 0x%08X.  Cannot enable chip protection.",
+                        scomAddr,
+                        TARGETING::get_huid(*pMembuf));
+                    break;
+                }
+
+                assert(size == expSize,
+                    "SCOM deviceWrite returned size of %d, expected %d",
+                    size,expSize);
+
+                TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
+                    INFO_MRK "SECUREBOOT: Enabled Centaur chip protection "
+                    "for target 0x%08X, register 0x%08X "
+                    "(set to 0x%016llX)",
+                    TARGETING::get_huid(*pMembuf),
+                    scomAddr,
+                    scomData);
+            }
+
+            if(l_errl)
+            {
+                break;
+            }
+        }
+    }
+    #endif
+
     if(!l_errl)
     {
         if(!l_mpipl)
@@ -903,6 +1001,8 @@ void*    call_proc_exit_cache_contained( void    *io_pArgs )
             l_sys->setAttr<ATTR_PAYLOAD_BASE>(payloadBase);
         }
 
+
+
         //  call the HWP with each fapi::Target
         FAPI_INVOKE_HWP( l_errl,
                          proc_exit_cache_contained
-- 
2.9.2


From f1ec1fcc31ec31f71d2a333085f36a5721cefa04 Mon Sep 17 00:00:00 2001
From: Nick Bofferding <bofferdn@us.ibm.com>
Date: Fri, 30 Sep 2016 17:25:32 -0500
Subject: [PATCH 13/20] Write MBOX_SCRATCH_REG0 via cfam instead of SCOM reg
 prior to building SMP

Change-Id: I41cc799bbcceead9c8d7bc949641f7ecba1e4c35
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/30577
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Reviewed-by: Joseph J. McGill <jmcgill@us.ibm.com>
Reviewed-by: Michael Baiocchi <mbaiocch@us.ibm.com>
Reviewed-by: Stephen M. Cprek <smcprek@us.ibm.com>
Reviewed-by: Daniel M. Crowell <dcrowell@us.ibm.com>
---
 .../proc_a_x_pci_dmi_pll_setup/proc_a_x_pci_dmi_pll_utils.C         | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/usr/hwpf/hwp/nest_chiplets/proc_a_x_pci_dmi_pll_setup/proc_a_x_pci_dmi_pll_utils.C b/src/usr/hwpf/hwp/nest_chiplets/proc_a_x_pci_dmi_pll_setup/proc_a_x_pci_dmi_pll_utils.C
index de733a3..cbdb775 100644
--- a/src/usr/hwpf/hwp/nest_chiplets/proc_a_x_pci_dmi_pll_setup/proc_a_x_pci_dmi_pll_utils.C
+++ b/src/usr/hwpf/hwp/nest_chiplets/proc_a_x_pci_dmi_pll_setup/proc_a_x_pci_dmi_pll_utils.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2013,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2013,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: proc_a_x_pci_dmi_pll_utils.C,v 1.9 2015/08/14 16:31:17 thi Exp $
+// $Id: proc_a_x_pci_dmi_pll_utils.C,v 1.10 2016-10-04 19:53:36 dcrowell Exp $
 // $Source: /afs/awd/projects/eclipz/KnowledgeBase/.cvsroot/eclipz/chips/p8/working/procedures/ipl/fapi/proc_a_x_pci_dmi_pll_utils.C,v $
 //------------------------------------------------------------------------------
 // *|
@@ -835,7 +835,7 @@ fapi::ReturnCode p8_pll_utils_scan_bndy_sbe(
 
         // submit request to SBE
         FAPI_DBG("Submitting scan request to SBE");
-        rc = fapiPutScom(i_target, MBOX_SCRATCH_REG0_0x00050038, mbox_data);
+        rc = fapiPutCfamRegister(i_target, MBOX_SCRATCH_REG0_0x00002838, mbox_data);
         if (!rc.ok())
         {
             FAPI_ERR("Error writing SBE MBOX0 Register");
-- 
2.9.2


From 08c2776516a1f9f1928927ee1d636bb49f281ac3 Mon Sep 17 00:00:00 2001
From: Stephen Cprek <smcprek@us.ibm.com>
Date: Tue, 6 Sep 2016 16:58:23 -0500
Subject: [PATCH 14/20] Load key transition section and set new hw hash key if
 applicable

If the key transition section is empty, then by default there are
no operations needed. The section empty check is done by checking
if the secureboot container header magic number is at the beginning.

Change-Id: Ic1aab1c2e3e948f4015e36d8c3b30ebeccb3a82c
RTC: 145687
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/29296
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Reviewed-by: Michael Baiocchi <mbaiocch@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Reviewed-by: Nicholas E. Bofferding <bofferdn@us.ibm.com>
Reviewed-by: William G. Hoffa <wghoffa@us.ibm.com>
---
 src/include/usr/initservice/istepdispatcherif.H    |   8 +-
 src/include/usr/ipmi/ipmiif.H                      |  21 ++-
 src/include/usr/pnor/pnor_reasoncodes.H            |   3 +
 src/include/usr/pnor/pnorif.H                      |  30 ++++
 src/include/usr/secureboot/containerheader.H       |  46 ++++++-
 src/include/usr/secureboot/rom.H                   |  31 ++++-
 src/include/usr/secureboot/service.H               |  10 +-
 src/usr/devtree/bld_devtree.C                      |   2 +-
 .../initservice/istepdispatcher/istepdispatcher.C  |  11 +-
 .../initservice/istepdispatcher/istepdispatcher.H  |   7 +-
 src/usr/ipmi/ipmirp.C                              |  10 +-
 src/usr/pnor/pnor_common.C                         |   4 +-
 src/usr/pnor/pnorrp.C                              | 152 ++++++++++++---------
 src/usr/pnor/spnorrp.C                             | 134 +++++++++++++++---
 src/usr/pnor/spnorrp.H                             |  12 ++
 src/usr/sbe/sbe_resolve_sides.C                    |  95 +++++++------
 src/usr/sbe/sbe_resolve_sides.H                    |  16 ++-
 src/usr/sbe/sbe_update.C                           | 122 ++++++++++++++++-
 src/usr/sbe/sbe_update.H                           |  16 +++
 src/usr/secureboot/base/containerheader.C          |  54 +++++++-
 src/usr/secureboot/base/securerom.C                |  56 ++++----
 src/usr/secureboot/base/securerom.H                |  14 +-
 src/usr/secureboot/base/test/secureromtest.H       |   7 +-
 src/usr/secureboot/trusted/base/trustedboot_base.C |   2 +-
 src/usr/secureboot/trusted/trustedboot.C           |   2 +-
 25 files changed, 660 insertions(+), 205 deletions(-)

diff --git a/src/include/usr/initservice/istepdispatcherif.H b/src/include/usr/initservice/istepdispatcherif.H
index 752f9ff..606722f 100644
--- a/src/include/usr/initservice/istepdispatcherif.H
+++ b/src/include/usr/initservice/istepdispatcherif.H
@@ -25,6 +25,8 @@
 #ifndef __INITSERVICE_ISTEPDISPATCHERIF_H
 #define __INITSERVICE_ISTEPDISPATCHERIF_H
 
+#include <ipmi/ipmiif.H>
+
 namespace INITSERVICE
 {
 
@@ -79,11 +81,13 @@ void stopIpl( void );
 #ifdef CONFIG_BMC_IPMI
 /**
  * @brief This function is to be used by external code to
- *        initate a system reboot via IPMI commands
+ *        initiate a system shutdown/reboot via IPMI commands
  *
+ * @param[in] i_msgType  IPMI message type to send. Note must be a valid
+ *                       shutdown/reboot message type.
  * @return Nothing
  */
-void requestReboot( void );
+void requestShutdownOrReboot(const IPMI::msg_type i_msgType);
 #endif
 
 /**
diff --git a/src/include/usr/ipmi/ipmiif.H b/src/include/usr/ipmi/ipmiif.H
index 5647d5c..1c0e722 100644
--- a/src/include/usr/ipmi/ipmiif.H
+++ b/src/include/usr/ipmi/ipmiif.H
@@ -54,13 +54,22 @@ namespace IPMI
 
         MSG_STATE_GRACEFUL_SHUTDOWN,
 
-        // initate a reboot request
-        MSG_STATE_INITATE_POWER_CYCLE,
+        // initiate a reboot request
+        MSG_STATE_INITIATE_POWER_CYCLE,
 
         // Used to check range. Leave as last.
-        MSG_LAST_TYPE = MSG_STATE_INITATE_POWER_CYCLE,
+        MSG_LAST_TYPE = MSG_STATE_INITIATE_POWER_CYCLE,
     };
 
+    // Message types related to system shutdown/reboot
+    inline bool validShutdownRebootMsgType(msg_type i_msgType)
+    {
+        return i_msgType == MSG_STATE_SHUTDOWN
+               || i_msgType == MSG_STATE_SHUTDOWN_SEL
+               || i_msgType == MSG_STATE_GRACEFUL_SHUTDOWN
+               || i_msgType == MSG_STATE_INITIATE_POWER_CYCLE;
+    }
+
     // chassis power off request types
     enum power_request_type
     {
@@ -349,10 +358,12 @@ namespace IPMI
     size_t max_buffer(void);
 
     /**
-     * Tells ipmirp to start a graceful reboot sequence
+     * Tells ipmirp to start a graceful shutdown/reboot sequence
      *
+     * @param[in] i_msgType  IPMI message type to send. Note must be a valid
+     *                       shutdown/reboot message type.
      */
-    void initiateReboot();
+    void initiateShutdownReboot(const IPMI::msg_type i_msgType);
 
 }; // end namespace IPMI
 
diff --git a/src/include/usr/pnor/pnor_reasoncodes.H b/src/include/usr/pnor/pnor_reasoncodes.H
index c4ac684..55fa743 100644
--- a/src/include/usr/pnor/pnor_reasoncodes.H
+++ b/src/include/usr/pnor/pnor_reasoncodes.H
@@ -105,6 +105,7 @@ namespace PNOR
         MOD_SPNORRP_SET_PERMISSION      = 0xD5, /**< SPnorRP::initDaemon */
         MOD_PNORRP_LOADSECURESECTION    = 0xD6, /**< PnorRP::loadSecureSection */
         MOD_SPNORRP_BASE_EXT_VER_CHK    = 0xD7, /**< SPnorRP::baseExtVersCheck */
+        MOD_SPNORRP_KEY_TRAN_CHK        = 0xD8, /**< SPnorRP::keyTransitionCheck */
     };
 
     enum PNORReasonCode
@@ -164,6 +165,8 @@ namespace PNOR
         RC_WRONG_SIZE_FROM_READ      = PNOR_COMP_ID | 0x2A,
         RC_GETSECTIONINFO_FAILED     = PNOR_COMP_ID | 0x2B,
         RC_BASE_EXT_MISMATCH         = PNOR_COMP_ID | 0x2C,
+        RC_KEY_TRAN_FLAG_UNSET       = PNOR_COMP_ID | 0x2D,
+        RC_BAD_SECURE_MAGIC_NUM      = PNOR_COMP_ID | 0x2E,
 
         //@fixme-RTC:131607-Temporary value to allow HWSV compile
         //termination_rc
diff --git a/src/include/usr/pnor/pnorif.H b/src/include/usr/pnor/pnorif.H
index faff332..d97ef18 100644
--- a/src/include/usr/pnor/pnorif.H
+++ b/src/include/usr/pnor/pnorif.H
@@ -81,6 +81,7 @@ enum SectionId
     // Size and layout of this structure must be maintained for debug framework.
 struct SectionInfo_t
 {
+    SectionInfo_t(): id(INVALID_SECTION) {}
     SectionId id;       /**< Identifier for this section */
     const char* name;   /**< Name of the section */
     uint64_t vaddr;     /**< Virtual address of the start of the section */
@@ -185,6 +186,35 @@ errlHndl_t loadSecureSection(SectionId i_section);
  *  @retval !NULL Failed to unload PNOR section
  */
 errlHndl_t unloadSecureSection(SectionId i_section);
+
+/**
+  * @brief  Memcmp a vaddr to the known secureboot magic number
+  *
+  * @param[in]   i_vaddr: vaddr of secureboot header to check for magic number
+  *                       Note: must point to a buffer of size >= 4 bytes
+  *
+  * @return  bool - True if the magic number and starting bytes of the vaddr
+  *                 match. False otherwise.
+  */
+bool cmpSecurebootMagicNumber(const uint8_t* i_vaddr);
+
+/**
+  * @brief  Returns true if a PNOR section has the secureboot container
+  *         header magic number at the beginning. This is mainly used to
+  *         ignore unwanted PNOR sections like secureboot key transition.
+  *         It indicates the section has valid content to be securely
+  *         loaded, otherwise the section content will not be loaded.
+  *         If a section does not have the header but needs to be loaded,
+  *         it will fail ROM verify later on anyhow.
+  *         Note: Does not work with HBB section and will assert if attempted
+  *
+  * @param[in]   i_section: PNOR section to check first bytes of.
+  * @param[out]  o_valid:  true if section has the correct magic number at
+  *                        the beginning
+  *
+  * @return  errlHndl_t - NULL if success, errlHndl_t otherwise.
+  */
+errlHndl_t hasSecurebootMagicNumber(SectionId i_section, bool &o_valid);
 #endif // CONFIG_SECUREBOOT
 
 /**
diff --git a/src/include/usr/secureboot/containerheader.H b/src/include/usr/secureboot/containerheader.H
index 273ff74..c5188e6 100644
--- a/src/include/usr/secureboot/containerheader.H
+++ b/src/include/usr/secureboot/containerheader.H
@@ -57,6 +57,7 @@ class ContainerHeader
             assert(i_header != NULL);
             iv_pHdrStart = reinterpret_cast<const uint8_t*>(i_header);
             memset(&iv_headerInfo, 0x00, sizeof(iv_headerInfo));
+            memset(iv_hwKeyHash, 0, sizeof(SHA512_t));
             parse_header(i_header);
         };
 
@@ -73,6 +74,17 @@ class ContainerHeader
         size_t totalContainerSize() const;
 
         /**
+         * @brief Retrieves pointer to first hw key
+         * @return ecc_key_t* - ptr to first hw key
+         */
+        const ecc_key_t* hw_keys() const;
+
+        /**
+         * @brief Total size of all hw keys concatenated
+         */
+        static const size_t totalHwKeysSize = HW_KEY_COUNT*sizeof(ecc_key_t);
+
+        /**
          * @brief Retrieves payload text size
          * @return size_t - size of payload text size
          */
@@ -108,7 +120,19 @@ class ContainerHeader
          */
         const ecc_key_t* sw_sigs() const;
 
-        // @TODO RTC: 155374 remove, SecureROMTest will use iv_isValid.
+        /**
+         * @brief Retrieves pointer to sb flag struct holding all hw and sw
+         *        flags set when parsing the header.
+         * @return sb_flags_t - hw and sw flag struct
+         */
+        const sb_flags_t* sb_flags() const;
+
+        /**
+         * @brief Retrieves hw public key hash
+         * @return SHA512_t* - ptr to hash of hw public keys
+         */
+        const SHA512_t* hwKeyHash() const;
+
         /**
          * @brief Returns if the parsed header is a valid secureboot one. This
          *        is a temporary, non-secure way of pragmatically determining
@@ -153,6 +177,26 @@ class ContainerHeader
         // Total size of all software keys concatenated
         size_t iv_totalSwKeysSize;
 
+        // Struct to hold all hw and sw flags set
+        sb_flags_t iv_sbFlags;
+
+        // HW keys' hash for current container.
+        SHA512_t iv_hwKeyHash;
+
+        /**
+         * @brief Determines what flags are set based on the hw and sw flag bit
+         *        fields in the container header.
+         *        Also sets iv_sbFlags private member
+         */
+        void parseFlags();
+
+        /**
+         * @brief Generate and store hw key hash. Concatenate all hw public keys
+         *        and then take sha512 hash.
+         *        Also sets iv_hwKeyHash private member
+         */
+        void genHwKeyHash();
+
         /**
          * @brief Weak check to determine if secureboot header looks right.
          *        Also sets iv_isValid private member
diff --git a/src/include/usr/secureboot/rom.H b/src/include/usr/secureboot/rom.H
index 213b74c..45f9c5d 100644
--- a/src/include/usr/secureboot/rom.H
+++ b/src/include/usr/secureboot/rom.H
@@ -30,10 +30,39 @@ const uint32_t MAGIC_NUMBER = 0x17082011;
 const uint16_t ROM_VERSION = 1;
 const uint8_t ROM_HASH_ALG = 1;
 const uint8_t ROM_SIG_ALG = 1;
+const uint8_t HW_KEY_COUNT = 3;
 const uint8_t SW_KEY_COUNT_MIN = 1;
 const uint8_t SW_KEY_COUNT_MAX = 3;
 const size_t MAX_SECURE_HEADER_SIZE = 4096;
 
+// Security Flags
+
+// HW Security Flags
+enum HW_SB_FLAGS
+{
+    HB_FW_FLAG = 0x80000000,
+    OPAL_FLAG = 0x40000000,
+    PHYP_FLAG = 0x20000000,
+    KEY_TRANSITION_FLAG = 0x00000001
+};
+
+// SW Security Flags
+enum SW_SB_FLAGS
+{
+    // placeholder
+};
+
+// Structure to store all hw and sw flag values in a container header
+struct sb_flags_t
+{
+    sb_flags_t() : hw_hb_fw(false), hw_opal(false), hw_phyp(false),
+                   hw_key_transition(false) {}
+    bool hw_hb_fw;
+    bool hw_opal;
+    bool hw_phyp;
+    bool hw_key_transition;
+};
+
 /******************************************************************/
 /*  Start of Chip Logic Secure ROM include section  */
 /******************************************************************/
@@ -163,4 +192,4 @@ void         call_rom_SHA512(void*, const sha2_byte *, size_t, sha2_hash_t*);
 /*  End of Chip Logic ROM include section  */
 /******************************************************************/
 
-#endif
\ No newline at end of file
+#endif
diff --git a/src/include/usr/secureboot/service.H b/src/include/usr/secureboot/service.H
index 08777f5..d97893d 100644
--- a/src/include/usr/secureboot/service.H
+++ b/src/include/usr/secureboot/service.H
@@ -126,11 +126,13 @@ namespace SECUREBOOT
      * @brief Verify Signed Container
      *
      * @param[in] i_container  Void pointer to effective address of container
-     * @param[in] i_size       Size of container in bytes
+     * @param[in] i_hwKeyHash  Custom hw keys' hash to test against
+     *                         [default = NULL, use current hw hash key]
      *
      * @return errlHndl_t  NULL on success
      */
-    errlHndl_t verifyContainer(void * i_container, size_t i_size);
+    errlHndl_t verifyContainer(void * i_container,
+                               const sha2_hash_t* i_hwKeyHash = NULL);
 
     /**
      * @brief Hash Signed Blob
@@ -144,12 +146,12 @@ namespace SECUREBOOT
     errlHndl_t hashBlob(const void * i_blob, size_t i_size, SHA512_t o_buf);
 
     /**
-     * @brief Retrieve the internal hardware hash key from secure ROM
+     * @brief Retrieve the internal hardware hw key hash from secure ROM
      *        object.
      * @param[out] o_hash  Reference to the sha2_hash_t array to copy the
      *                     hash to.
      */
-     void getHwHashKeys(sha2_hash_t o_hash);
+     void getHwKeyHash(sha2_hash_t o_hash);
 
      /*
       * @brief Hash the concatenation of N Blobs
diff --git a/src/usr/devtree/bld_devtree.C b/src/usr/devtree/bld_devtree.C
index 5d59510..cbed3dd 100644
--- a/src/usr/devtree/bld_devtree.C
+++ b/src/usr/devtree/bld_devtree.C
@@ -2845,7 +2845,7 @@ errlHndl_t bld_fdt_secureboot(devTree * i_dt, bool i_smallTree)
 
         dtOffset_t secBootNode = i_dt->addNode(rootNode, "ibm,secureboot");
         sha2_hash_t hw_key_hash;
-        SECUREBOOT::getHwHashKeys(hw_key_hash);
+        SECUREBOOT::getHwKeyHash(hw_key_hash);
 
         i_dt->addPropertyBytes(secBootNode, "hw-key-hash",
                                reinterpret_cast<uint8_t*>(hw_key_hash),
diff --git a/src/usr/initservice/istepdispatcher/istepdispatcher.C b/src/usr/initservice/istepdispatcher/istepdispatcher.C
index 7cb0a66..a29ef7f 100644
--- a/src/usr/initservice/istepdispatcher/istepdispatcher.C
+++ b/src/usr/initservice/istepdispatcher/istepdispatcher.C
@@ -594,7 +594,8 @@ errlHndl_t IStepDispatcher::executeAllISteps()
 
                             // Request BMC to do power cycle that sends shutdown
                             // and reset the host
-                            requestReboot();
+                            requestShutdownOrReboot(
+                                          IPMI::MSG_STATE_INITIATE_POWER_CYCLE);
 
                             #endif
                             #ifdef CONFIG_CONSOLE
@@ -1375,9 +1376,9 @@ void IStepDispatcher::handleShutdownMsg(msg_t * & io_pMsg)
 }
 
 #ifdef CONFIG_BMC_IPMI
-void IStepDispatcher::requestReboot()
+void IStepDispatcher::requestShutdownOrReboot(const IPMI::msg_type i_msgType)
 {
-    IPMI::initiateReboot();
+    IPMI::initiateShutdownReboot(i_msgType);
 }
 #endif
 // ----------------------------------------------------------------------------
@@ -2080,9 +2081,9 @@ void setNewGardRecord()
     return IStepDispatcher::getTheInstance().setNewGardRecord();
 }
 #ifdef CONFIG_BMC_IPMI
-void requestReboot()
+void requestShutdownOrReboot(const IPMI::msg_type i_msgType)
 {
-    IStepDispatcher::getTheInstance().requestReboot();
+    IStepDispatcher::getTheInstance().requestShutdownOrReboot(i_msgType);
 }
 #endif
 void stopIpl()
diff --git a/src/usr/initservice/istepdispatcher/istepdispatcher.H b/src/usr/initservice/istepdispatcher/istepdispatcher.H
index 2ef7c75..2489eca 100644
--- a/src/usr/initservice/istepdispatcher/istepdispatcher.H
+++ b/src/usr/initservice/istepdispatcher/istepdispatcher.H
@@ -47,6 +47,7 @@
 #include "../baseinitsvc/initservice.H"
 #include "splesscommon.H"
 #include "istep_mbox_msgs.H"
+#include <ipmi/ipmiif.H>
 
 namespace   INITSERVICE
 {
@@ -216,9 +217,11 @@ public:
     void stop();
 #ifdef CONFIG_BMC_IPMI
     /**
-     * @brief This function will trigger a reboot via ipmi commands
+     * @brief This function will trigger a shutdown/reboot via ipmi commands
+     * @param[in] i_msgType  IPMI message type to send. Note must be a valid
+     *                       shutdown/reboot message type.
      */
-    void requestReboot();
+    void requestShutdownOrReboot(const IPMI::msg_type i_msgType);
 #endif
 
 
diff --git a/src/usr/ipmi/ipmirp.C b/src/usr/ipmi/ipmirp.C
index 54457ef..9b67688 100644
--- a/src/usr/ipmi/ipmirp.C
+++ b/src/usr/ipmi/ipmirp.C
@@ -696,8 +696,8 @@ void IpmiRP::execute(void)
             }
             break;
 
-            // begin a graceful reboot initated by us
-        case IPMI::MSG_STATE_INITATE_POWER_CYCLE:
+            // begin a graceful reboot initiated by us
+        case IPMI::MSG_STATE_INITIATE_POWER_CYCLE:
             {
                 msg_free(msg);
 
@@ -1079,13 +1079,13 @@ namespace IPMI
     }
 
     ///
-    /// @brief  kick off a reboot
+    /// @brief  initiate a graceful shutdown/reboot
     ///
-    void initiateReboot()
+    void initiateShutdownReboot(const IPMI::msg_type i_msgType)
     {
         static msg_q_t mq = Singleton<IpmiRP>::instance().msgQueue();
         msg_t * msg = msg_allocate();
-        msg->type =  IPMI::MSG_STATE_INITATE_POWER_CYCLE;
+        msg->type =  i_msgType;
         msg_send(mq, msg);
     }
 
diff --git a/src/usr/pnor/pnor_common.C b/src/usr/pnor/pnor_common.C
index 318b8c6..33d23bd 100644
--- a/src/usr/pnor/pnor_common.C
+++ b/src/usr/pnor/pnor_common.C
@@ -452,7 +452,6 @@ errlHndl_t PNOR::parseTOC(uint8_t* i_toc0Buffer, uint8_t* i_toc1Buffer,
                                             ((o_TOC[secId].size * 8 ) / 9);
                     }
 
-                    // @TODO RTC:153773 move header handling to secure pnor rp
                     // Don't skip header if verification is needed.
                     bool isSecure = PNOR::isSecureSection(secId);
                     if (o_TOC[secId].version == FFS_VERS_SHA512 || isSecure)
@@ -690,7 +689,8 @@ bool PNOR::isSecureSection(const uint32_t i_section)
            i_section == HB_DATA ||
            i_section == SBE_IPL ||
            i_section == CENTAUR_SBE ||
-           i_section == PAYLOAD;
+           i_section == PAYLOAD ||
+           i_section == SBKT;
 #else
     return false;
 #endif
diff --git a/src/usr/pnor/pnorrp.C b/src/usr/pnor/pnorrp.C
index fb19c2b..11f3725 100644
--- a/src/usr/pnor/pnorrp.C
+++ b/src/usr/pnor/pnorrp.C
@@ -510,73 +510,103 @@ errlHndl_t PnorRP::getSectionInfo( PNOR::SectionId i_section,
             id = PNOR::INVALID_SECTION;
             break;
         }
-    } while(0);
 
-    if (PNOR::INVALID_SECTION != id)
-    {
-        TRACDCOMP( g_trac_pnor, "PnorRP::getSectionInfo: i_section=%d, id=%d", i_section, iv_TOC[i_section].id );
+        if (PNOR::INVALID_SECTION != id)
+        {
+            TRACDCOMP( g_trac_pnor, "PnorRP::getSectionInfo: i_section=%d, id=%d", i_section, iv_TOC[i_section].id );
 
-        // copy my data into the external format
-        o_info.id = iv_TOC[id].id;
-        o_info.name = cv_EYECATCHER[id];
+            // copy my data into the external format
+            o_info.id = iv_TOC[id].id;
+            o_info.name = cv_EYECATCHER[id];
 
 #ifdef CONFIG_SECUREBOOT
-        o_info.secureProtectedPayloadSize = 0; // for non secure sections
-                                               // the protected payload size
-                                               // defaults to zero
-        // handle secure sections in SPnorRP's address space
-        if (PNOR::isSecureSection(o_info.id))
-        {
-            uint8_t* l_vaddr = reinterpret_cast<uint8_t*>(iv_TOC[id].virtAddr);
-            // By adding VMM_VADDR_SPNOR_DELTA twice we can translate a pnor
-            // address into a secure pnor address, since pnor, temp, and spnor
-            // spaces are equidistant.
-            // See comments in SPnorRP::verifySections() method in spnorrp.C
-            // and the definition of VMM_VADDR_SPNOR_DELTA in vmmconst.h
-            // for specifics.
-            o_info.vaddr = reinterpret_cast<uint64_t>(l_vaddr)
-                                                       + VMM_VADDR_SPNOR_DELTA
-                                                       + VMM_VADDR_SPNOR_DELTA;
-
-            // Get size of the secured payload for the secure section
-            // Note: the payloadSize we get back is untrusted because
-            // we are parsing the header in pnor (non secure space).
-            SECUREBOOT::ContainerHeader l_conHdr(l_vaddr);
-            size_t payloadTextSize = l_conHdr.payloadTextSize();
-
-            assert(payloadTextSize > 0,"Non-zero payload text size expected.");
-
-            // skip secure header for secure sections at this point in time
-            o_info.vaddr += PAGESIZE;
-            // now that we've skipped the header we also need to adjust the
-            // size of the section to reflect that.
-            // Note: For unsecured sections, the header skip and size decrement
-            // was done previously in pnor_common.C
-            o_info.size -= PAGESIZE;
-
-            // cache the value in SectionInfo struct so that we can
-            // parse the container header less often
-            o_info.secureProtectedPayloadSize = payloadTextSize;
-        }
-        else
+            o_info.secureProtectedPayloadSize = 0; // for non secure sections
+                                                   // the protected payload size
+                                                   // defaults to zero
+            // handle secure sections in SPnorRP's address space
+            if (PNOR::isSecureSection(o_info.id))
+            {
+                uint8_t* l_vaddr = reinterpret_cast<uint8_t*>(iv_TOC[id].virtAddr);
+                // By adding VMM_VADDR_SPNOR_DELTA twice we can translate a pnor
+                // address into a secure pnor address, since pnor, temp, and spnor
+                // spaces are equidistant.
+                // See comments in SPnorRP::verifySections() method in spnorrp.C
+                // and the definition of VMM_VADDR_SPNOR_DELTA in vmmconst.h
+                // for specifics.
+                o_info.vaddr = reinterpret_cast<uint64_t>(l_vaddr)
+                                                           + VMM_VADDR_SPNOR_DELTA
+                                                           + VMM_VADDR_SPNOR_DELTA;
+
+                // Get size of the secured payload for the secure section
+                // Note: the payloadSize we get back is untrusted because
+                // we are parsing the header in pnor (non secure space).
+                size_t payloadTextSize = 0;
+                // Do an existence check on the container to see if it's non-empty
+                // and has valid beginning bytes. For optional Secure PNOR sections.
+                if (PNOR::cmpSecurebootMagicNumber(l_vaddr))
+                {
+                    SECUREBOOT::ContainerHeader l_conHdr(l_vaddr);
+                    payloadTextSize = l_conHdr.payloadTextSize();
+                    assert(payloadTextSize > 0,"Non-zero payload text size expected.");
+                }
+                else
+                {
+                    uint32_t l_badMagicHeader = 0;
+                    memcpy(&l_badMagicHeader, l_vaddr, sizeof(MAGIC_NUMBER));
+                    TRACFCOMP( g_trac_pnor, ERR_MRK"PnorRP::getSectionInfo: magic number not valid to parse container for section = %s magic number = 0x%X",
+                               o_info.name, l_badMagicHeader);
+                    /*@
+                     * @errortype
+                     * @severity     ERRORLOG::ERRL_SEV_UNRECOVERABLE
+                     * @moduleid     PNOR::MOD_PNORRP_GETSECTIONINFO
+                     * @reasoncode   PNOR::RC_BAD_SECURE_MAGIC_NUM
+                     * @userdata1    Requested Section
+                     * @userdata2    Bad magic number
+                     * @devdesc      PNOR section does not have the known secureboot magic number
+                     * @custdesc     Corrupted flash image or firmware error during system boot
+                     */
+                    l_errhdl = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
+                                                       PNOR::MOD_PNORRP_GETSECTIONINFO,
+                                                       PNOR::RC_BAD_SECURE_MAGIC_NUM,
+                                                       TO_UINT64(i_section),
+                                                       TO_UINT64(l_badMagicHeader),
+                                                       true /*Add HB SW Callout*/);
+                    l_errhdl->collectTrace(PNOR_COMP_NAME);
+                    break;
+                }
+
+                // skip secure header for secure sections at this point in time
+                o_info.vaddr += PAGESIZE;
+                // now that we've skipped the header we also need to adjust the
+                // size of the section to reflect that.
+                // Note: For unsecured sections, the header skip and size decrement
+                // was done previously in pnor_common.C
+                o_info.size -= PAGESIZE;
+
+                // cache the value in SectionInfo struct so that we can
+                // parse the container header less often
+                o_info.secureProtectedPayloadSize = payloadTextSize;
+            }
+            else
 #endif
-        {
-            o_info.vaddr = iv_TOC[id].virtAddr;
-        }
+            {
+                o_info.vaddr = iv_TOC[id].virtAddr;
+            }
 
-        o_info.flashAddr = iv_TOC[id].flashAddr;
-        o_info.size = iv_TOC[id].size;
-        o_info.eccProtected = ((iv_TOC[id].integrity & FFS_INTEG_ECC_PROTECT)
-                                != 0) ? true : false;
-        o_info.sha512Version = ((iv_TOC[id].version & FFS_VERS_SHA512)
-                                 != 0) ? true : false;
-        o_info.sha512perEC = ((iv_TOC[id].version & FFS_VERS_SHA512_PER_EC)
-                               != 0) ? true : false;
-        o_info.readOnly = ((iv_TOC[id].misc & FFS_MISC_READ_ONLY)
-                               != 0) ? true : false;
-        o_info.reprovision = ((iv_TOC[id].misc & FFS_MISC_REPROVISION)
-                               != 0) ? true : false;
-    }
+            o_info.flashAddr = iv_TOC[id].flashAddr;
+            o_info.size = iv_TOC[id].size;
+            o_info.eccProtected = ((iv_TOC[id].integrity & FFS_INTEG_ECC_PROTECT)
+                                    != 0) ? true : false;
+            o_info.sha512Version = ((iv_TOC[id].version & FFS_VERS_SHA512)
+                                     != 0) ? true : false;
+            o_info.sha512perEC = ((iv_TOC[id].version & FFS_VERS_SHA512_PER_EC)
+                                   != 0) ? true : false;
+            o_info.readOnly = ((iv_TOC[id].misc & FFS_MISC_READ_ONLY)
+                                   != 0) ? true : false;
+            o_info.reprovision = ((iv_TOC[id].misc & FFS_MISC_REPROVISION)
+                                   != 0) ? true : false;
+        }
+    } while(0);
 
     return l_errhdl;
 }
diff --git a/src/usr/pnor/spnorrp.C b/src/usr/pnor/spnorrp.C
index 53f9491..8b9cb48 100644
--- a/src/usr/pnor/spnorrp.C
+++ b/src/usr/pnor/spnorrp.C
@@ -151,6 +151,7 @@ errlHndl_t SPnorRP::allocBlock(msg_q_t i_mq, void* i_va, uint64_t i_size) const
                            TO_UINT64(rc),
                            true); //Add HB SW Callout
         l_errhdl->collectTrace(PNOR_COMP_NAME);
+        l_errhdl->collectTrace(SECURE_COMP_NAME);
     }
     return l_errhdl;
 }
@@ -186,6 +187,7 @@ errlHndl_t SPnorRP::setPermission(void* i_va, uint64_t i_size,
                             TO_UINT64(rc),
                             true); // Add HB SW Callout
         l_errhdl->collectTrace(PNOR_COMP_NAME);
+        l_errhdl->collectTrace(SECURE_COMP_NAME);
     }
     return l_errhdl;
 }
@@ -259,7 +261,7 @@ void SPnorRP::initDaemon()
  */
 void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
 {
-    SectionInfo_t l_info = {PNOR::INVALID_SECTION};
+    SectionInfo_t l_info;
     errlHndl_t l_errhdl = NULL;
     bool failedVerify = false;
 
@@ -280,8 +282,8 @@ void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
         l_info.size += PAGESIZE; // add a page to size to account for the header
 
         // it's a coding error if l_info.vaddr is not in secure space
-        assert(l_info.vaddr >= SBASE_VADDR, "For section %s, getSectionInfo"
-            " returned a non secure space address", l_info.name);
+        assert(l_info.vaddr >= SBASE_VADDR, "Virtual address for section %s is"
+            " not in secure space. Bad ptr=0x%X", l_info.name, l_info.vaddr);
 
         // Note: A pointer to virtual memory in one PNOR space can be converted
         // to a pointer to any of the other two PNOR spaces and visa versa.
@@ -346,11 +348,10 @@ void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
         // verify while in temp space
         if (SECUREBOOT::enabled())
         {
-            l_errhdl = SECUREBOOT::verifyContainer(l_tempAddr,
-                                                         l_totalContainerSize);
+            l_errhdl = SECUREBOOT::verifyContainer(l_tempAddr);
             if (l_errhdl)
             {
-                TRACFCOMP(g_trac_pnor, "< SPnorrRP::verifySections - section "
+                TRACFCOMP(g_trac_pnor, ERR_MRK"SPnorrRP::verifySections - section "
                       "with id 0x%08X failed verifyContainer", i_id);
                 failedVerify = true;
                 break;
@@ -359,7 +360,7 @@ void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
             l_errhdl = miscSectionVerification(l_tempAddr, i_id);
             if (l_errhdl)
             {
-                TRACFCOMP(g_trac_pnor, "< SPnorrRP::verifySections  - section "
+                TRACFCOMP(g_trac_pnor, ERR_MRK"SPnorrRP::verifySections  - section "
                      " with id 0x%08X failed miscSectionVerification", i_id);
                 failedVerify = true;
                 break;
@@ -619,6 +620,7 @@ void SPnorRP::waitForMessage()
                                            reinterpret_cast<uint64_t>(eff_addr),
                                            true /*Add HB SW Callout*/);
                     l_errhdl->collectTrace(PNOR_COMP_NAME);
+                    l_errhdl->collectTrace(SECURE_COMP_NAME);
                     status_rc = -EINVAL; /* Invalid argument */
             }
 
@@ -681,8 +683,9 @@ errlHndl_t PNOR::loadSecureSection(const SectionId i_section)
     //else remove the if clause below at some point
     if (rc != 0)
     {
-        /* @errorlog tag
-         * @errortype         ERRL_SEV_CRITICAL_SYS_TERM
+        /*
+         * @errortype
+         * @severity          ERRL_SEV_CRITICAL_SYS_TERM
          * @moduleid          MOD_PNORRP_LOADSECURESECTION
          * @reasoncode        RC_EXTERNAL_ERROR
          * @userdata1         returncode from msg_sendrecv()
@@ -737,6 +740,11 @@ errlHndl_t SPnorRP::miscSectionVerification(const uint8_t *i_vaddr,
             // table by skipping past the container header.
             l_errl = baseExtVersCheck((i_vaddr + PAGESIZE));
             break;
+        case SBKT:
+            // Ensure the SBKT partition has a valid key transition container
+            // Add PAGESIZE to skip outer container
+            l_errl = keyTransitionCheck((i_vaddr + PAGESIZE));
+            break;
         default:
             break;
     }
@@ -779,31 +787,115 @@ errlHndl_t SPnorRP::baseExtVersCheck(const uint8_t *i_vaddr) const
                 HASH_PAGE_TABLE_ENTRY_SIZE) != 0 )
     {
         TRACFCOMP(g_trac_pnor, ERR_MRK"SPnorRP::baseExtVersCheck Hostboot Base and Extended image mismatch");
-        TRACFBIN(g_trac_pnor,"SPnorRP:::baseExtVersCheck Measured sw key hash",
+        TRACFBIN(g_trac_pnor,"SPnorRP::baseExtVersCheck Measured sw key hash",
                             l_hashSwSigs, HASH_PAGE_TABLE_ENTRY_SIZE);
         TRACFBIN(g_trac_pnor,"SPnorRP::baseExtVersCheck HBI's hash page table salt entry",
                         l_hashPageTableSaltEntry, HASH_PAGE_TABLE_ENTRY_SIZE);
 
-        /*@ errorlog tag
-         * @errortype       ERRL_SEV_CRITICAL_SYS_TERM
+        /*@
+         * @errortype
+         * @severity        ERRL_SEV_CRITICAL_SYS_TERM
          * @moduleid        MOD_SPNORRP_BASE_EXT_VER_CHK
          * @reasoncode      RC_BASE_EXT_MISMATCH
          * @userdata1       0
          * @userdata2       0
          * @devdesc         Hostboot Base and Extend code do not match versions.
          * @custdesc        Firmware level mismatch.
-         *
          */
-        l_errl = new ERRORLOG::ErrlEntry
-            (
-             ERRORLOG::ERRL_SEV_CRITICAL_SYS_TERM,   //  severity
-             MOD_SPNORRP_BASE_EXT_VER_CHK,           //  moduleid
-             RC_BASE_EXT_MISMATCH,                    //  reason Code
-             0,
-             0
-            );
+        l_errl = new ERRORLOG::ErrlEntry( ERRORLOG::ERRL_SEV_CRITICAL_SYS_TERM,
+                                          MOD_SPNORRP_BASE_EXT_VER_CHK,
+                                          RC_BASE_EXT_MISMATCH,
+                                          0,
+                                          0);
+        l_errl->collectTrace(PNOR_COMP_NAME);
+        l_errl->collectTrace(SECURE_COMP_NAME);
+    }
+
+    return l_errl;
+}
+
+errlHndl_t SPnorRP::keyTransitionCheck(const uint8_t *i_vaddr) const
+{
+    errlHndl_t l_errl = NULL;
+    assert(i_vaddr != NULL);
+
+    do {
+    // Check if the header flags have the key transition bit set
+    SECUREBOOT::ContainerHeader l_nestedConHdr(i_vaddr);
+    if (!l_nestedConHdr.sb_flags()->hw_key_transition)
+    {
+        TRACFCOMP( g_trac_pnor, ERR_MRK"SPnorRP::keyTransitionCheck() - Key transition flag not set");
+        /*@
+         * @errortype
+         * @severity        ERRL_SEV_CRITICAL_SYS_TERM
+         * @moduleid        MOD_SPNORRP_KEY_TRAN_CHK
+         * @reasoncode      RC_KEY_TRAN_FLAG_UNSET
+         * @userdata1       0
+         * @userdata2       0
+         * @devdesc         Key transition flag not set in nested SBKT container containing new hw keys
+         * @custdesc        Secureboot key transition failure
+         */
+         l_errl = new ERRORLOG::ErrlEntry( ERRORLOG::ERRL_SEV_CRITICAL_SYS_TERM,
+                                           MOD_SPNORRP_KEY_TRAN_CHK,
+                                           RC_KEY_TRAN_FLAG_UNSET,
+                                           0,
+                                           0,
+                                           true /*Add HB Software Callout*/ );
         l_errl->collectTrace(PNOR_COMP_NAME);
+        l_errl->collectTrace(SECURE_COMP_NAME);
+        break;
     }
 
+    // Validate nested container is properly signed using new hw keys
+    l_errl = SECUREBOOT::verifyContainer(const_cast<uint8_t*>(i_vaddr),
+                                         l_nestedConHdr.hwKeyHash());
+    if (l_errl)
+    {
+        TRACFCOMP( g_trac_pnor, ERR_MRK"SPnorRP::keyTransitionCheck() - failed verifyContainer");
+        break;
+    }
+    }while(0);
+
+    return l_errl;
+}
+
+bool PNOR::cmpSecurebootMagicNumber(const uint8_t* i_vaddr)
+{
+    return memcmp(&MAGIC_NUMBER, i_vaddr, sizeof(MAGIC_NUMBER)) == 0;
+}
+
+errlHndl_t PNOR::hasSecurebootMagicNumber(const SectionId i_section,
+                                          bool &o_valid)
+{
+    errlHndl_t l_errl = NULL;
+    SectionInfo_t l_info;
+
+    // Force to false
+    o_valid = false;
+
+    // This will not work for HBB
+    assert(i_section != HB_BASE_CODE, "hasSecurebootMagicNumber() does not work for HBB section");
+
+    bool isSecure = PNOR::isSecureSection(i_section);
+    do {
+        l_errl = getSectionInfo(i_section, l_info);
+        if (l_errl)
+        {
+            TRACFCOMP(g_trac_pnor, ERR_MRK"PNOR::hasSecurebootMagicNumber(): - getSectionInfo failed");
+            break;
+        }
+
+        // Use PNOR vaddr
+        if(isSecure)
+        {
+            // back up a page to expose the secure header
+            l_info.vaddr = l_info.vaddr - VMM_VADDR_SPNOR_DELTA
+                                        - VMM_VADDR_SPNOR_DELTA
+                                        - PAGESIZE;
+        }
+        o_valid = cmpSecurebootMagicNumber(reinterpret_cast<uint8_t*>
+                                           (l_info.vaddr));
+    }while(0);
+
     return l_errl;
 }
diff --git a/src/usr/pnor/spnorrp.H b/src/usr/pnor/spnorrp.H
index 6acdc78..9f7e533 100644
--- a/src/usr/pnor/spnorrp.H
+++ b/src/usr/pnor/spnorrp.H
@@ -174,5 +174,17 @@ class SPnorRP
      * @return  errlHndl_t - NULL if success, errlHndl_t otherwise.
      */
     errlHndl_t baseExtVersCheck(const uint8_t *i_vaddr) const;
+
+    /**
+     * @brief  Check if SBKT is properly formatted to then provide the new HW
+     *         key hash to transition the system to.
+     * @param[in]  i_vaddr - vaddr points to start SBKT's nested container
+     *                       NOTE: Since this expects the vaddr to point to the
+     *                       start of the nested container, the outer secureboot
+     *                       header must be skipped prior by the caller.
+     *                       NULL will assert
+     * @return  errlHndl_t - NULL if success, errlHndl_t otherwise.
+     */
+    errlHndl_t keyTransitionCheck(const uint8_t *i_vaddr) const;
 };
 #endif
diff --git a/src/usr/sbe/sbe_resolve_sides.C b/src/usr/sbe/sbe_resolve_sides.C
index cf8517d..84b01bd 100644
--- a/src/usr/sbe/sbe_resolve_sides.C
+++ b/src/usr/sbe/sbe_resolve_sides.C
@@ -311,10 +311,10 @@ errlHndl_t resolveProcessorSbeSeeproms()
                        l_restartNeeded);
 
 #ifdef CONFIG_BMC_IPMI
-            err = sbePreRebootIpmiCalls();
+            err = sbePreShutdownIpmiCalls(IPMI::MSG_STATE_INITIATE_POWER_CYCLE);
             if (err)
             {
-                TRACFCOMP( g_trac_sbe,ERR_MRK"sbePreRebootIpmiCalls failed");
+                TRACFCOMP( g_trac_sbe,ERR_MRK"sbePreShutdownIpmiCalls failed");
                 break;
             }
 #endif
@@ -1570,71 +1570,76 @@ errlHndl_t resolveImageHBBaddr(TARGETING::Target* i_target,
 
 #ifdef CONFIG_BMC_IPMI
 /////////////////////////////////////////////////////////////////////
-errlHndl_t sbePreRebootIpmiCalls( void )
+errlHndl_t sbeIncrementRebootCount()
 {
     errlHndl_t err = NULL;
-    TRACFCOMP( g_trac_sbe, ENTER_MRK"sbePreRebootIpmiCalls");
+    uint16_t count = 0;
+    SENSOR::RebootCountSensor l_sensor;
 
-    do{
-        uint16_t count = 0;
-        SENSOR::RebootCountSensor l_sensor;
+    // Read reboot count sensor
+    err = l_sensor.getRebootCount(count);
+    if ( err )
+    {
+        TRACFCOMP( g_trac_sbe,
+                   ERR_MRK"sbeIncrementRebootCount: "
+                   "FAIL Reading Reboot Sensor Count. "
+                   "Committing Error Log rc=0x%.4X eid=0x%.8X "
+                   "plid=0x%.8X, but continuing shutdown",
+                   err->reasonCode(),
+                   err->eid(),
+                   err->plid());
+        err->collectTrace(SBE_COMP_NAME);
+        errlCommit( err, SBE_COMP_ID );
+    }
+    else
+    {
+        // Increment Reboot Count Sensor
+        count++;
+        TRACFCOMP( g_trac_sbe,
+                   INFO_MRK"sbeIncrementRebootCount: "
+                   "Writing Reboot Sensor Count=%d", count);
 
-        // Read reboot count sensor
-        err = l_sensor.getRebootCount(count);
+        err = l_sensor.setRebootCount( count );
         if ( err )
         {
             TRACFCOMP( g_trac_sbe,
-                       ERR_MRK"sbePreRebootIpmiCalls: "
-                       "FAIL Reading Reboot Sensor Count. "
+                       ERR_MRK"sbeIncrementRebootCount: "
+                       "FAIL Writing Reboot Sensor Count to %d. "
                        "Committing Error Log rc=0x%.4X eid=0x%.8X "
                        "plid=0x%.8X, but continuing shutdown",
+                       count,
                        err->reasonCode(),
                        err->eid(),
                        err->plid());
             err->collectTrace(SBE_COMP_NAME);
             errlCommit( err, SBE_COMP_ID );
-
-            // No Break - Still do reboot
         }
-        else
-        {
-            // Increment Reboot Count Sensor
-            count++;
-            TRACFCOMP( g_trac_sbe,
-                       INFO_MRK"sbePreRebootIpmiCalls: "
-                       "Writing Reboot Sensor Count=%d", count);
+    }
+    return err;
+}
 
-            err = l_sensor.setRebootCount( count );
-            if ( err )
-            {
-                TRACFCOMP( g_trac_sbe,
-                           ERR_MRK"sbePreRebootIpmiCalls: "
-                           "FAIL Writing Reboot Sensor Count to %d. "
-                           "Committing Error Log rc=0x%.4X eid=0x%.8X "
-                           "plid=0x%.8X, but continuing shutdown",
-                           count,
-                           err->reasonCode(),
-                           err->eid(),
-                           err->plid());
-                err->collectTrace(SBE_COMP_NAME);
-                errlCommit( err, SBE_COMP_ID );
+/////////////////////////////////////////////////////////////////////
+errlHndl_t sbePreShutdownIpmiCalls(const IPMI::msg_type i_msgType)
+{
+    errlHndl_t err = NULL;
+    TRACFCOMP( g_trac_sbe, ENTER_MRK"sbePreShutdownIpmiCalls");
 
-                // No Break - Still send chassis power cycle
-            }
-        }
+    assert(IPMI::validShutdownRebootMsgType(i_msgType), "sbePreShutdownIpmiCalls: Invalid msg_type 0x%8X",
+           i_msgType);
 
-        TRACFCOMP( g_trac_sbe,"sbePreRebootIpmiCalls: "
-                   "requesting chassis power cycle");
+    // Still send chassis shutdown message on fail
+    err = sbeIncrementRebootCount();
 
-        // tell the istepdispacher to stop
-        INITSERVICE::stopIpl();
+    TRACFCOMP( g_trac_sbe,"sbePreShutdownIpmiCalls: requesting chassis "
+               "shutdown type = 0x%8X", i_msgType);
 
-        // initate a graceful power cycle
-        INITSERVICE::requestReboot();
+    // tell the istepdispacher to stop
+    INITSERVICE::stopIpl();
 
-    }while(0);
+    // initiate a power cycle of type i_msgType
+    INITSERVICE::requestShutdownOrReboot(i_msgType);
 
-    TRACFCOMP( g_trac_sbe, EXIT_MRK"sbePreRebootIpmiCalls");
+    TRACFCOMP( g_trac_sbe, EXIT_MRK"sbePreShutdownIpmiCalls");
 
     return err;
 }
diff --git a/src/usr/sbe/sbe_resolve_sides.H b/src/usr/sbe/sbe_resolve_sides.H
index e227da9..ac1cbfe 100644
--- a/src/usr/sbe/sbe_resolve_sides.H
+++ b/src/usr/sbe/sbe_resolve_sides.H
@@ -35,6 +35,7 @@
 #include <targeting/common/targetservice.H>
 #include <i2c/eepromif.H>
 #include "sbe_update.H"
+#include <ipmi/ipmiif.H>
 
 namespace SBE
 {
@@ -286,11 +287,22 @@ namespace SBE
 
 #ifdef CONFIG_BMC_IPMI
     /**
-     * @brief Performs any necessary IPMI calls before reboot the system
+     * @brief Performs any necessary IPMI calls before shutdown/reboot
+     *
+     * @param[in] i_msgType  IPMI message type to send. Note must be a valid
+     *                       shutdown/reboot message type.
+     *
+     * @return errlHndl_t    Error log handle on failure.
+     */
+    errlHndl_t sbePreShutdownIpmiCalls(const IPMI::msg_type i_msgType);
+
+    /**
+     * @brief Increment Reboot Count sensor by 1. Due to SBE specific traces
+     *        and errl trace collection, keeping this specific to the SBE code.
      *
      * @return errlHndl_t    Error log handle on failure.
      */
-    errlHndl_t sbePreRebootIpmiCalls( void );
+    errlHndl_t sbeIncrementRebootCount();
 #endif
 
 } //end namespace SBE
diff --git a/src/usr/sbe/sbe_update.C b/src/usr/sbe/sbe_update.C
index 9d7f9b0..5815b4a 100644
--- a/src/usr/sbe/sbe_update.C
+++ b/src/usr/sbe/sbe_update.C
@@ -53,6 +53,10 @@
 #include <sbe/sbereasoncodes.H>
 #include "sbe_update.H"
 #include "sbe_resolve_sides.H"
+#include <ipmi/ipmiif.H>
+#ifdef CONFIG_SECUREBOOT
+#include <secureboot/containerheader.H>
+#endif
 
 //  fapi support
 #include    <fapi.H>
@@ -139,7 +143,6 @@ namespace SBE
             // else - continue on
 #endif
 
-
             // Get Target Service, and the system target.
             TargetService& tS = targetService();
             TARGETING::Target* sys = NULL;
@@ -264,6 +267,24 @@ namespace SBE
                  err = NULL;
             }
 
+            // Check if a key transition is needed
+            std::vector<uint8_t> l_transHwKeyHash;
+            err = secureKeyTransition(l_transHwKeyHash);
+            if (err)
+            {
+                TRACFCOMP( g_trac_sbe, ERR_MRK"updateProcessorSbeSeeproms() - failed secureKeyTransition");
+                break;
+            }
+            // If vector has a size then there is a key to transition to.
+            if(!l_transHwKeyHash.empty())
+            {
+                assert(l_transHwKeyHash.size() == SBE::SBE_HW_KEY_HASH_SIZE, "Transition HW key hash is the wrong size");
+                memcpy(g_hw_keys_hash_transition_data, l_transHwKeyHash.begin(),
+                       SBE::SBE_HW_KEY_HASH_SIZE);
+                g_do_hw_keys_hash_transition = true;
+                TRACFBIN(g_trac_sbe, "updateProcessorSbeSeeproms(): Key transition new hw key hash",
+                     g_hw_keys_hash_transition_data, SBE::SBE_HW_KEY_HASH_SIZE);
+            }
 
             for(uint32_t i=0; i<procList.size(); i++)
             {
@@ -424,20 +445,33 @@ namespace SBE
                 }
 
 #ifdef CONFIG_BMC_IPMI
-                err = sbePreRebootIpmiCalls();
+                // When doing a HW key hash transition, shutdown only.
+                if (g_do_hw_keys_hash_transition)
+                {
+                    err = sbePreShutdownIpmiCalls(
+                                            IPMI::MSG_STATE_GRACEFUL_SHUTDOWN);
+                }
+                else
+                {
+                    err = sbePreShutdownIpmiCalls(
+                                         IPMI::MSG_STATE_INITIATE_POWER_CYCLE);
+                }
                 if (err)
                 {
-                    TRACFCOMP( g_trac_sbe,ERR_MRK"sbePreRebootIpmiCalls "
+                    TRACFCOMP( g_trac_sbe,ERR_MRK"sbePreShutdownIpmiCalls "
                                "failed");
                     break;
                 }
 #endif
 
 #ifdef CONFIG_CONSOLE
-            CONSOLE::displayf(SBE_COMP_NAME, "System Rebooting To "
-                              "Perform SBE Update\n");
+            if(!g_do_hw_keys_hash_transition)
+            {
+                CONSOLE::displayf(SBE_COMP_NAME, "System Rebooting To "
+                                  "Perform SBE Update\n");
 
-            CONSOLE::flush();
+                CONSOLE::flush();
+            }
 #endif
 
 #ifndef CONFIG_BMC_IPMI
@@ -3007,7 +3041,6 @@ namespace SBE
             ///////////////////////////////////////////////////////////////////
 
 #endif
-
             // Set actions
             io_sbeState.update_actions = static_cast<sbeUpdateActions_t>
                                                     (l_actions);
@@ -4704,6 +4737,12 @@ errlHndl_t determineHwKeysHash(const void* i_imgPtr,
             memcpy(seeprom_hw_keys_hash_ptr,
                    g_hw_keys_hash_transition_data,
                    SBE_HW_KEY_HASH_SIZE);
+
+        #ifdef CONFIG_CONSOLE
+            CONSOLE::displayf(SBE_COMP_NAME, "Performing Secureboot Key Transition\n");
+            CONSOLE::displayf(SBE_COMP_NAME, "System will power off after completion\n");
+            CONSOLE::flush();
+        #endif
         }
 
         // Normal Preservation of HW Keys Hash
@@ -4856,5 +4895,74 @@ errlHndl_t getHwKeysHashPtrFromSbeImage(const void*   i_imgPtr,
     return err;
 }
 
+errlHndl_t secureKeyTransition(std::vector<uint8_t> &o_transHwKeyHash)
+{
+    errlHndl_t l_errl = NULL;
+    o_transHwKeyHash.clear();
+
+#ifdef CONFIG_SECUREBOOT
+    do {
+    bool l_loaded = false;
+    PNOR::SectionInfo_t l_secInfo;
+    bool l_hasMagicHeader = false;
+
+    // Do an existence check on the container to see if it's non-empty and has
+    // valid beginning bytes.
+    l_errl = hasSecurebootMagicNumber(PNOR::SBKT, l_hasMagicHeader);
+    // SBKT section is optional so just delete error and no-op
+    if (l_errl)
+    {
+        TRACFCOMP( g_trac_sbe, ERR_MRK"secureKeyTransition() - hasSecurebootMagicNumber() optional PNOR::SBKT DNE");
+        delete l_errl;
+        l_errl = NULL;
+        break;
+    }
+
+    // If key transition partition does not have a header, it is assumed
+    // we do not need to load or perform any operations.
+    if(l_hasMagicHeader)
+    {
+        // Verify and Load SBKT section and nested container.
+        l_errl = loadSecureSection(PNOR::SBKT);
+        if (l_errl)
+        {
+            TRACFCOMP( g_trac_sbe, ERR_MRK,"secureKeyTransition() - Error from loadSecureSection(PNOR::SBKT)");
+            break;
+        }
+        l_loaded = true;
+
+        // Get SBKT PNOR section info from PNOR RP
+        l_errl = getSectionInfo(PNOR::SBKT, l_secInfo);
+        // SBKT section is optional, but we check ealier if it exists, so if
+        // this fails, something is really wrong and we have to prevent key
+        // transition.
+        if (l_errl)
+        {
+            TRACFCOMP( g_trac_sbe, ERR_MRK"secureKeyTransition() - getSectionInfo(PNOR::SBKT) passed prior to this, but now fails. Prevent key transition!");
+            break;
+        }
+
+        // Get new verified HW key hash
+        const void* l_pVaddr = reinterpret_cast<void*>(l_secInfo.vaddr);
+        SECUREBOOT::ContainerHeader l_nestedConHdr(l_pVaddr);
+        // Get pointer to first element of hwKeyHash from header.
+        const uint8_t* l_hwKeyHash = l_nestedConHdr.hwKeyHash()[0];
+        o_transHwKeyHash.insert(o_transHwKeyHash.end(), l_hwKeyHash,
+                                l_hwKeyHash + SHA512_DIGEST_LENGTH);
+    }
+    if(l_loaded)
+    {
+        l_errl = unloadSecureSection(PNOR::SBKT);
+        if (l_errl)
+        {
+            TRACFCOMP( g_trac_sbe, ERR_MRK,"secureKeyTransition() - Error from unloadSecureSection(PNOR::SBKT)");
+            break;
+        }
+    }
+    } while(0);
+#endif
+
+    return l_errl;
+}
 
 } //end SBE Namespace
diff --git a/src/usr/sbe/sbe_update.H b/src/usr/sbe/sbe_update.H
index 72a081e..c6cf2f7 100644
--- a/src/usr/sbe/sbe_update.H
+++ b/src/usr/sbe/sbe_update.H
@@ -642,5 +642,21 @@ namespace SBE
     errlHndl_t getHwKeysHashPtrFromSbeImage(const void*  i_imgPtr,
                                             void*& o_HwKeysHashPtr);
 
+    /**
+     * @brief Checks if a secure key transition is needed and if so verifies
+     *        the key transition container is valid and gets the new hw key hash
+     *
+     * @param[out]  o_transHwKeyHash   New hw key hash to transition to.
+     *                                 Should be empty on input
+     *                                 Will return empty if keys will not be
+     *                                     transitioned.
+     *                                 Otherwise 64 bytes of the key to
+     *                                     transition to
+     *
+     * @return errlHndl_t    Error log handle on failure. NULL on success
+     */
+    errlHndl_t secureKeyTransition(std::vector<uint8_t> &o_transHwKeyHash);
+
+
 } //end namespace SBE
 #endif
diff --git a/src/usr/secureboot/base/containerheader.C b/src/usr/secureboot/base/containerheader.C
index 5f73fdd..5f8e2fd 100644
--- a/src/usr/secureboot/base/containerheader.C
+++ b/src/usr/secureboot/base/containerheader.C
@@ -43,6 +43,12 @@ void ContainerHeader::parse_header(const void* i_header)
     size_t l_size = offsetof(ROM_container_raw, prefix);
     safeMemCpyAndInc(&iv_headerInfo.hw_hdr, l_hdr, l_size);
 
+    // Early check if magic number is valid, as a quick check to try and prevent
+    // any storage exceptions while parsing header.
+    assert(iv_headerInfo.hw_hdr.magic_number == MAGIC_NUMBER,
+           "ContainerHeader: magic number = 0x%08X not valid",
+           iv_headerInfo.hw_hdr.magic_number);
+
     /*---- Parse ROM_prefix_header_raw ----*/
     l_size = offsetof(ROM_prefix_header_raw, ecid);
     safeMemCpyAndInc(&iv_headerInfo.hw_prefix_hdr, l_hdr, l_size);
@@ -72,6 +78,12 @@ void ContainerHeader::parse_header(const void* i_header)
     /*---- Parse ROM_sw_sig_raw ----*/
     safeMemCpyAndInc(&iv_headerInfo.sw_sig.sw_sig_p, l_hdr, iv_totalSwKeysSize);
 
+    // Parse hw and sw flags
+    parseFlags();
+
+    // Generate hw hash key
+    genHwKeyHash();
+
     // After parsing check if header is valid, do some quick bound checks
     validate();
 
@@ -97,6 +109,7 @@ void ContainerHeader::print() const
     TRACFBIN(g_trac_secure,"hw_pkey_c", iv_headerInfo.hw_hdr.hw_pkey_c, 64);
 
     /*---- Print ROM_prefix_header_raw ----*/
+    TRACFCOMP(g_trac_secure,"hw_flags 0x%X", iv_headerInfo.hw_prefix_hdr.flags);
     TRACFCOMP(g_trac_secure,"sw_key_count 0x%X", iv_headerInfo.hw_prefix_hdr.sw_key_count);
     TRACFBIN(g_trac_secure,"sw public key hash", iv_headerInfo.hw_prefix_hdr.payload_hash, SHA512_DIGEST_LENGTH);
 
@@ -135,6 +148,11 @@ size_t ContainerHeader::totalContainerSize() const
     return iv_headerInfo.hw_hdr.container_size;
 }
 
+const ecc_key_t* ContainerHeader::hw_keys() const
+{
+    return &iv_headerInfo.hw_hdr.hw_pkey_a;
+}
+
 size_t ContainerHeader::payloadTextSize() const
 {
     return iv_headerInfo.sw_hdr.payload_size;
@@ -165,6 +183,16 @@ const ecc_key_t* ContainerHeader::sw_sigs() const
     return &iv_headerInfo.sw_sig.sw_sig_p;
 }
 
+const sb_flags_t* ContainerHeader::sb_flags() const
+{
+    return &iv_sbFlags;
+}
+
+const SHA512_t* ContainerHeader::hwKeyHash() const
+{
+    return &iv_hwKeyHash;
+}
+
 void ContainerHeader::validate()
 {
     iv_isValid = (iv_hdrBytesRead <= MAX_SECURE_HEADER_SIZE)
@@ -181,24 +209,40 @@ void ContainerHeader::validate()
 void ContainerHeader::safeMemCpyAndInc(void* i_dest, const uint8_t* &io_hdr,
                                        const size_t i_size)
 {
-    assert(i_dest != NULL);
-    assert(io_hdr != NULL);
-    assert(iv_pHdrStart != NULL);
+    assert(i_dest != NULL, "ContainerHeader: dest ptr NULL");
+    assert(io_hdr != NULL, "ContainerHeader: current header location ptr NULL");
+    assert(iv_pHdrStart != NULL, "ContainerHeader: start of header ptr NULL");
 
     TRACDCOMP(g_trac_secure,"dest: 0x%X src: 0x%X size: 0x%X",i_dest, io_hdr, i_size);
 
     // Determine if the memcpy is within the bounds of the container header
     iv_hdrBytesRead = io_hdr - iv_pHdrStart;
-    assert( (iv_hdrBytesRead + i_size) <= MAX_SECURE_HEADER_SIZE);
+    assert( (iv_hdrBytesRead + i_size) <= MAX_SECURE_HEADER_SIZE,
+            "ContainerHeader: memcpy is out of bounds of max header size");
 
     memcpy(i_dest, io_hdr, i_size);
     io_hdr += i_size;
 }
 
-// @TODO RTC: 155374 remove, SecureROMTest will use iv_isValid.
 bool ContainerHeader::isValid() const
 {
     return iv_isValid;
 }
 
+void ContainerHeader::parseFlags()
+{
+    iv_sbFlags.hw_hb_fw = iv_headerInfo.hw_prefix_hdr.flags & HB_FW_FLAG;
+    iv_sbFlags.hw_opal = iv_headerInfo.hw_prefix_hdr.flags & OPAL_FLAG;
+    iv_sbFlags.hw_phyp = iv_headerInfo.hw_prefix_hdr.flags & PHYP_FLAG;
+    iv_sbFlags.hw_key_transition = iv_headerInfo.hw_prefix_hdr.flags
+                                   & KEY_TRANSITION_FLAG;
+}
+
+void ContainerHeader::genHwKeyHash()
+{
+    // Generate and store hw hash key
+    SECUREBOOT::hashBlob(&iv_headerInfo.hw_hdr.hw_pkey_a,
+                         totalHwKeysSize, iv_hwKeyHash);
+}
+
 }; //end of SECUREBOOT namespace
diff --git a/src/usr/secureboot/base/securerom.C b/src/usr/secureboot/base/securerom.C
index 7606d4f..ec86829 100644
--- a/src/usr/secureboot/base/securerom.C
+++ b/src/usr/secureboot/base/securerom.C
@@ -65,13 +65,10 @@ errlHndl_t initializeSecureROM(void)
 /**
  * @brief Verify Signed Container
  */
-errlHndl_t verifyContainer(void * i_container, size_t i_size)
+errlHndl_t verifyContainer(void * i_container, const sha2_hash_t* i_hwKeyHash)
 {
-    TRACUCOMP(g_trac_secure, "verifyContainer(): i_container=%p, size=0x%x",
-              i_container, i_size);
-
     return Singleton<SecureROM>::instance().verifyContainer(i_container,
-                                                            i_size);
+                                                            i_hwKeyHash);
 }
 
 /**
@@ -95,9 +92,9 @@ errlHndl_t hashConcatBlobs(const blobPair_t &i_blobs, SHA512_t o_buf)
 /*
  * @brief  Externally available hardware hash key function
  */
-void getHwHashKeys(sha2_hash_t o_hash)
+void getHwKeyHash(sha2_hash_t o_hash)
 {
-    return Singleton<SecureROM>::instance().getHwHashKeys(o_hash);
+    return Singleton<SecureROM>::instance().getHwKeyHash(o_hash);
 }
 
 }; //end SECUREBOOT namespace
@@ -261,13 +258,13 @@ errlHndl_t SecureROM::initialize()
         /*  Retrieve HW Hash Keys From The System                      */
         /***************************************************************/
 
-        // @todo RTC:RTC:34080 - Support for SecureROM::getHwHashKeys()
-        l_errl = SecureROM::getHwHashKeys();
+        // @todo RTC:RTC:34080 - Support for SecureROM::getHwKeyHash()
+        l_errl = SecureROM::getHwKeyHash();
 
         if (l_errl != NULL)
         {
             TRACFCOMP(g_trac_secure,ERR_MRK"SecureROM::initialize():"
-            " SecureROM::getHwHashKeys() returned an error");
+            " SecureROM::getHwKeyHash() returned an error");
 
             l_errl->collectTrace(SECURE_COMP_NAME,256);
             break;
@@ -303,10 +300,11 @@ errlHndl_t SecureROM::initialize()
 /**
  * @brief Verify Container against system hash keys
  */
-errlHndl_t SecureROM::verifyContainer(void * i_container, size_t i_size)
+errlHndl_t SecureROM::verifyContainer(void * i_container,
+                                      const sha2_hash_t* i_hwKeyHash)
 {
     TRACDCOMP(g_trac_secure,ENTER_MRK"SecureROM::verifyContainer(): "
-              "i_container=%p, size=0x%x", i_container, i_size);
+              "i_container=%p", i_container);
 
     errlHndl_t  l_errl = NULL;
     uint64_t    l_rc   = 0;
@@ -326,8 +324,17 @@ errlHndl_t SecureROM::verifyContainer(void * i_container, size_t i_size)
         // struct elements my_ecid, entry_point and log
         memset(&l_hw_parms, 0, sizeof(ROM_hw_params));
 
-        // Now set hw_key_hash, which is of type sha2_hash_t, to iv_hash_key
-        memcpy (&l_hw_parms.hw_key_hash, &iv_hash_key, sizeof(sha2_hash_t));
+        // Now set hw_key_hash, which is of type sha2_hash_t, to iv_key_hash
+        if (i_hwKeyHash == NULL)
+        {
+            // Use current hw hash key
+            memcpy (&l_hw_parms.hw_key_hash, &iv_key_hash, sizeof(sha2_hash_t));
+        }
+        else
+        {
+            // Use custom hw hash key
+            memcpy (&l_hw_parms.hw_key_hash, i_hwKeyHash, sizeof(sha2_hash_t));
+        }
 
         /*******************************************************************/
         /* Call ROM_verify() function via an assembly call                 */
@@ -366,6 +373,7 @@ errlHndl_t SecureROM::verifyContainer(void * i_container, size_t i_size)
 
             /*@
              * @errortype
+             * @severity     ERRORLOG::ERRL_SEV_UNRECOVERABLE
              * @moduleid     SECUREBOOT::MOD_SECURE_ROM_VERIFY
              * @reasoncode   SECUREBOOT::RC_ROM_VERIFY
              * @userdata1    l_rc
@@ -470,8 +478,8 @@ SecureROM::SecureROM()
 {
     TRACDCOMP(g_trac_secure, "SecureROM::SecureROM()>");
 
-    // Clear out iv_hash_keys, which is of type sha2_hash_t
-    memset(&iv_hash_key, 0, sizeof(sha2_hash_t) );
+    // Clear out iv_key_hash, which is of type sha2_hash_t
+    memset(&iv_key_hash, 0, sizeof(sha2_hash_t) );
 
 }
 
@@ -549,16 +557,16 @@ void SecureROM::_cleanup()
 /**
  * @brief Retrieves HW Keys from the system
  */
-errlHndl_t SecureROM::getHwHashKeys()
+errlHndl_t SecureROM::getHwKeyHash()
 {
 
     errlHndl_t l_errl = NULL;
 
-    TRACFCOMP(g_trac_secure,INFO_MRK"SecureROM::getHwHashKeys()");
+    TRACFCOMP(g_trac_secure,INFO_MRK"SecureROM::getHwKeyHash()");
 
     // The length of the hash is SHA512_DIGEST_LENGTH
     // The data will be read from PIBMEM using SCOM addresses via deviceRead
-    // iv_hash_key is where the data will be copied.
+    // iv_key_hash is where the data will be copied.
 
     // simplify notation below
     using namespace TARGETING; // for MASTER_PROCESSOR_CHIP_TARGET_SENTINEL
@@ -580,7 +588,7 @@ errlHndl_t SecureROM::getHwHashKeys()
     // This is NOT a pointer as it represents a SCOM address and not RAM.
     uint32_t l_pibaddr = PIBMEM_HW_KEY_HASH;
 
-    // stop at the end of iv_hash_key, so get its end pointer
+    // stop at the end of iv_key_hash, so get its end pointer
     uint64_t* l_stop;
     l_stop = reinterpret_cast<uint64_t*>(&l_temp_hash[SHA512_DIGEST_LENGTH]);
 
@@ -612,14 +620,14 @@ errlHndl_t SecureROM::getHwHashKeys()
     // if there was an error indicate it as a trace message
     if (l_errl != NULL)
     {
-        TRACFCOMP(g_trac_secure,ERR_MRK"SecureROM::getHwHashKeys():"
+        TRACFCOMP(g_trac_secure,ERR_MRK"SecureROM::getHwKeyHash():"
         " Fail SCOM Read of hash key at PIBMEM address (0x%x)",
         PIBMEM + (l_hash - reinterpret_cast<uint64_t*>(l_temp_hash)));
     }
     else
     {
         // copy the successfully retreived hash key to the member variable
-        memcpy(iv_hash_key, l_temp_hash, sizeof(sha2_hash_t));
+        memcpy(iv_key_hash, l_temp_hash, sizeof(sha2_hash_t));
     }
 
     return l_errl;
@@ -628,9 +636,9 @@ errlHndl_t SecureROM::getHwHashKeys()
 /**
  * @brief  Retrieve the internal hardware hash key from secure ROM object.
  */
-void SecureROM::getHwHashKeys(sha2_hash_t o_hash)
+void SecureROM::getHwKeyHash(sha2_hash_t o_hash)
 {
-    memcpy(o_hash, iv_hash_key, sizeof(sha2_hash_t));
+    memcpy(o_hash, iv_key_hash, sizeof(sha2_hash_t));
 }
 
 /**
diff --git a/src/usr/secureboot/base/securerom.H b/src/usr/secureboot/base/securerom.H
index 9d7f733..278291e 100644
--- a/src/usr/secureboot/base/securerom.H
+++ b/src/usr/secureboot/base/securerom.H
@@ -52,11 +52,13 @@ class SecureROM
          *
          * @param[in] i_container  Void pointer to effective address
          *                          of container
-         * @param[in] i_size       Size of container
+         * @param[in] i_hwKeyHash  Custom hw keys' hash to test against
+         *                         [default = NULL, use current hw hash key]
          *
          * @return errlHndl_t  NULL on success
          */
-        errlHndl_t verifyContainer(void * i_container, size_t i_size);
+        errlHndl_t verifyContainer(void * i_container,
+                                   const sha2_hash_t* i_hwKeyHash = NULL);
 
         /**
          * @brief Hash Blob
@@ -77,7 +79,7 @@ class SecureROM
          * @param[out] o_hash  Reference to the sha2_hash_t array to copy the
          *                     hash to.
          */
-        void getHwHashKeys(sha2_hash_t o_hash);
+        void getHwKeyHash(sha2_hash_t o_hash);
 
         /*
          * @brief Hash the concatenation of N Blobs
@@ -119,9 +121,9 @@ class SecureROM
         void * iv_device_ptr;
 
         /**
-         * Hash Key Retrieved From System
+         * HW key hash Retrieved From System
          */
-        sha2_hash_t iv_hash_key;
+        sha2_hash_t iv_key_hash;
 
         /********************************************
          * Private Functions
@@ -132,7 +134,7 @@ class SecureROM
          *
          * @return errlHndl_t  NULL on success
          */
-        errlHndl_t getHwHashKeys();
+        errlHndl_t getHwKeyHash();
 
         /**
          * @brief Static instance function for testcase only
diff --git a/src/usr/secureboot/base/test/secureromtest.H b/src/usr/secureboot/base/test/secureromtest.H
index 79a1cd0..3e1760e 100644
--- a/src/usr/secureboot/base/test/secureromtest.H
+++ b/src/usr/secureboot/base/test/secureromtest.H
@@ -64,7 +64,7 @@ void unloadSignedFile( void * & io_signedFile_pageAddr,
 
 // secureboot_signed_container was generated using this hw hash key. If another
 // key is in pibmem, this test will always fail.
-const uint64_t hw_hash_key[] =
+const uint64_t hw_key_hash[] =
 {
     0x40d487ff7380ed6a,
     0xd54775d5795fea0d,
@@ -149,7 +149,7 @@ class SecureROMTest : public CxxTest::TestSuite
         }
 
         // Set hw hash key
-        memcpy (& l_sRom.iv_hash_key, &hw_hash_key, sizeof(sha2_hash_t));
+        memcpy (& l_sRom.iv_key_hash, &hw_key_hash, sizeof(sha2_hash_t));
 
         /*******************************************************************/
         /* Call verify function                                            */
@@ -158,8 +158,7 @@ class SecureROMTest : public CxxTest::TestSuite
         // Warn about the exception being handled during verification
         printkd("test_verify(): expect to see 'mfsr r2 to CFAR handled': ");
 
-        l_errl = l_sRom.verifyContainer( signedFile_pageAddr,
-                                         signedFile_size     );
+        l_errl = l_sRom.verifyContainer( signedFile_pageAddr);
 
         if (l_errl)
         {
diff --git a/src/usr/secureboot/trusted/base/trustedboot_base.C b/src/usr/secureboot/trusted/base/trustedboot_base.C
index b5bfe15..a1c2604 100644
--- a/src/usr/secureboot/trusted/base/trustedboot_base.C
+++ b/src/usr/secureboot/trusted/base/trustedboot_base.C
@@ -286,7 +286,7 @@ errlHndl_t extendBaseImage()
     const void* pHbbVa = NULL;
     if(!SECUREBOOT::enabled())
     {
-        PNOR::SectionInfo_t l_info = {PNOR::INVALID_SECTION};
+        PNOR::SectionInfo_t l_info;
         pError = getSectionInfo(PNOR::HB_BASE_CODE, l_info);
         if(pError)
         {
diff --git a/src/usr/secureboot/trusted/trustedboot.C b/src/usr/secureboot/trusted/trustedboot.C
index b326340..f59c8c4 100644
--- a/src/usr/secureboot/trusted/trustedboot.C
+++ b/src/usr/secureboot/trusted/trustedboot.C
@@ -561,7 +561,7 @@ errlHndl_t tpmLogConfigEntries(TRUSTEDBOOT::TpmTarget & io_target)
 
         // HW Key Hash
         sha2_hash_t l_hw_key_hash;
-        SECUREBOOT::getHwHashKeys(l_hw_key_hash);
+        SECUREBOOT::getHwKeyHash(l_hw_key_hash);
         l_err = pcrExtend(PCR_1, l_hw_key_hash,
                           sizeof(sha2_hash_t),"HW KEY HASH");
         if (l_err)
-- 
2.9.2


From 6687a6ece24eb79ead3ab96b862fb396e0646f62 Mon Sep 17 00:00:00 2001
From: Stephen Cprek <smcprek@us.ibm.com>
Date: Thu, 29 Sep 2016 11:52:43 -0500
Subject: [PATCH 15/20] Remove TPM measurements from parseTOC in pnorrp

Change-Id: I4fcb417c5e28e4e3c2c6e8e28e58051f2d3d3fa9
RTC:157607
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/30488
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Reviewed-by: Nicholas E. Bofferding <bofferdn@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Reviewed-by: Christopher J. Engel <cjengel@us.ibm.com>
Reviewed-by: Michael Baiocchi <mbaiocch@us.ibm.com>
Reviewed-by: William G. Hoffa <wghoffa@us.ibm.com>
---
 src/usr/pnor/pnor_common.C | 86 ++++++----------------------------------------
 src/usr/pnor/pnor_common.H | 12 -------
 2 files changed, 11 insertions(+), 87 deletions(-)

diff --git a/src/usr/pnor/pnor_common.C b/src/usr/pnor/pnor_common.C
index 33d23bd..a6c1a05 100644
--- a/src/usr/pnor/pnor_common.C
+++ b/src/usr/pnor/pnor_common.C
@@ -453,56 +453,24 @@ errlHndl_t PNOR::parseTOC(uint8_t* i_toc0Buffer, uint8_t* i_toc1Buffer,
                     }
 
                     // Don't skip header if verification is needed.
-                    bool isSecure = PNOR::isSecureSection(secId);
-                    if (o_TOC[secId].version == FFS_VERS_SHA512 || isSecure)
+                    if (o_TOC[secId].version == FFS_VERS_SHA512
+                        && !PNOR::isSecureSection(secId))
                     {
-                        uint32_t l_addr = o_TOC[secId].flashAddr;
+                        TRACFCOMP(g_trac_pnor, "PNOR::parseTOC: Incrementing"
+                                            " Flash Address for SHA Header");
 
-                        size_t l_headerSize = 0;
-                        if(!isSecure) // if not a secure section skip header
+                        if (o_TOC[secId].integrity == FFS_INTEG_ECC_PROTECT)
                         {
-                            TRACFCOMP(g_trac_pnor, "PNOR::parseTOC: Incrementing"
-                                                " Flash Address for SHA Header");
-
-                            if (o_TOC[secId].integrity == FFS_INTEG_ECC_PROTECT)
-                            {
-                                o_TOC[secId].flashAddr += PAGESIZE_PLUS_ECC;
-                                l_headerSize = PAGESIZE_PLUS_ECC;
-                            }
-                            else
-                            {
-                                o_TOC[secId].flashAddr += PAGESIZE;
-                                l_headerSize = PAGESIZE;
-                            }
-
-                            // now that we've skipped the header
-                            // adjust the size to reflect that
-                            o_TOC[secId].size -= PAGESIZE;
+                            o_TOC[secId].flashAddr += PAGESIZE_PLUS_ECC;
                         }
-
-                        bool extend = true;
-                        // If secureboot is compiled out, then we extend HBB
-                        // the traditional way.  Otherwise, we defer to the
-                        // caller
-                        #ifdef CONFIG_SECUREBOOT
-                        if(secId == PNOR::HB_BASE_CODE || isSecure)
+                        else
                         {
-                            extend = false;
+                            o_TOC[secId].flashAddr += PAGESIZE;
                         }
-                        #endif
 
-                        if(extend)
-                        {
-                            // CONFIG_SECUREBOOT:
-                            // true - Extend all PNOR hashes
-                            // false - Do not extend sections with secureboot support
-                            l_errhdl = PNOR::extendHash(l_addr, l_headerSize,
-                                                        cv_EYECATCHER[secId]);
-                            if (l_errhdl)
-                            {
-                                break;
-                            }
-                        }
+                        // now that we've skipped the header
+                        // adjust the size to reflect that
+                        o_TOC[secId].size -= PAGESIZE;
                     }
 
                     if((o_TOC[secId].flashAddr + o_TOC[secId].size) >
@@ -650,38 +618,6 @@ errlHndl_t PNOR::parseTOC(uint8_t* i_toc0Buffer, uint8_t* i_toc1Buffer,
     return l_errhdl;
 }
 
-errlHndl_t PNOR::extendHash(uint64_t i_addr, size_t i_size, const char* i_name)
-{
-    errlHndl_t l_errhdl = NULL;
-
-    do {
-        #ifndef __HOSTBOOT_RUNTIME
-        // Read data from the PNOR DD
-        uint8_t* l_buf = new uint8_t[i_size]();
-        TARGETING::Target* l_target = TARGETING::MASTER_PROCESSOR_CHIP_TARGET_SENTINEL;
-        l_errhdl = DeviceFW::deviceRead(l_target, l_buf, i_size,
-                                        DEVICE_PNOR_ADDRESS(0,i_addr));
-        if (l_errhdl)
-        {
-            break;
-        }
-
-        SHA512_t l_hash = {0};
-        SECUREBOOT::hashBlob(l_buf, i_size, l_hash);
-        l_errhdl = TRUSTEDBOOT::pcrExtend(TRUSTEDBOOT::PCR_0, l_hash,
-                                          sizeof(SHA512_t), i_name);
-        delete[] l_buf;
-
-        if (l_errhdl)
-        {
-            break;
-        }
-        #endif
-    } while(0);
-
-    return l_errhdl;
-}
-
 bool PNOR::isSecureSection(const uint32_t i_section)
 {
 #ifdef CONFIG_SECUREBOOT
diff --git a/src/usr/pnor/pnor_common.H b/src/usr/pnor/pnor_common.H
index 5e4f908..bca4614 100644
--- a/src/usr/pnor/pnor_common.H
+++ b/src/usr/pnor/pnor_common.H
@@ -133,18 +133,6 @@ namespace PNOR {
      void physicalToMmioOffset(uint64_t  i_hbbAddress,
                                uint64_t& o_mmioOffset);
 
-    /**
-     * @brief Reads version header of section, hashes it, and extends to tpm
-     *        buffer list.
-     *
-     * @parm i_addr  Offset into flash to read
-     * @parm i_size  Number of bytes to read
-     * @parm i_name  Name of PNOR section
-     *
-     * @return Error from operation
-     */
-    errlHndl_t extendHash(uint64_t i_addr, size_t i_size, const char* i_name);
-
     enum
     {
         LPC_TOP_OF_FLASH_OFFSET = 0x0FFFFFFF,
-- 
2.9.2


From 2538edd14e7cfd21bde8b4ea8c1eb3ec6604f099 Mon Sep 17 00:00:00 2001
From: Mike Baiocchi <mbaiocch@us.ibm.com>
Date: Tue, 30 Aug 2016 01:41:55 -0500
Subject: [PATCH 16/20] Securely load and unload OCC section of PNOR when
 necessary

Change-Id: I8978640663699312f19e560ce75274159b4a7de5
RTC: 157233
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/28940
Reviewed-by: Stephen M. Cprek <smcprek@us.ibm.com>
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Reviewed-by: William G. Hoffa <wghoffa@us.ibm.com>
---
 src/build/buildpnor/genPnorImages.pl |  3 +-
 src/usr/pnor/pnor_common.C           |  3 +-
 src/usr/util/utillidmgr.C            | 83 ++++++++++++++++++++++++++----------
 src/usr/util/utillidpnor.C           | 37 +++++++++++++++-
 4 files changed, 100 insertions(+), 26 deletions(-)

diff --git a/src/build/buildpnor/genPnorImages.pl b/src/build/buildpnor/genPnorImages.pl
index 333c35a..6f892db 100755
--- a/src/build/buildpnor/genPnorImages.pl
+++ b/src/build/buildpnor/genPnorImages.pl
@@ -361,7 +361,8 @@ sub manipulateImages
         my $isNormalSecure =    ($eyeCatch eq "SBE")
                              || ($eyeCatch eq "SBEC")
                              || ($eyeCatch eq "PAYLOAD")
-                             || ($eyeCatch eq "SBKT");
+                             || ($eyeCatch eq "SBKT")
+                             || ($eyeCatch eq "OCC");
 
         my $isSpecialSecure =    ($eyeCatch eq "HBB")
                               || ($eyeCatch eq "HBI")
diff --git a/src/usr/pnor/pnor_common.C b/src/usr/pnor/pnor_common.C
index a6c1a05..cd1acf1 100644
--- a/src/usr/pnor/pnor_common.C
+++ b/src/usr/pnor/pnor_common.C
@@ -626,7 +626,8 @@ bool PNOR::isSecureSection(const uint32_t i_section)
            i_section == SBE_IPL ||
            i_section == CENTAUR_SBE ||
            i_section == PAYLOAD ||
-           i_section == SBKT;
+           i_section == SBKT ||
+           i_section == OCC;
 #else
     return false;
 #endif
diff --git a/src/usr/util/utillidmgr.C b/src/usr/util/utillidmgr.C
index 25253eb..3e63d36 100644
--- a/src/usr/util/utillidmgr.C
+++ b/src/usr/util/utillidmgr.C
@@ -35,6 +35,11 @@
 #include <initservice/initserviceif.H>
 #include <sys/mm.h>
 
+#include <config.h>
+#ifdef CONFIG_SECUREBOOT
+#include <pnor/pnorif.H>
+#endif
+
 using namespace ERRORLOG;
 mutex_t UtilLidMgr::cv_mutex = MUTEX_INITIALIZER;
 
@@ -653,30 +658,64 @@ errlHndl_t UtilLidMgr::cleanup()
     // laying around
     if(iv_isLidInPnor)
     {
-        int rc = mm_remove_pages( RELEASE,
-                                  reinterpret_cast<void *>(iv_lidPnorInfo.vaddr),
-                                  iv_lidPnorInfo.size );
-        if( rc )
+        bool skip_remove_pages = false;
+
+#ifdef CONFIG_SECUREBOOT
+        // If in SECUREBOOT the lid could be securely signed in PNOR (like OCC)
+        // If so, unload it securely below rather than call mm_remove_pages
+        if (PNOR::isSecureSection(iv_lidPnorInfo.id))
         {
-            UTIL_FT( ERR_MRK"rc=%d from mm_remove_pages(%llX,%llX)", iv_lidPnorInfo.vaddr, iv_lidPnorInfo.size );
-            /*@
-             *   @errortype
-             *   @moduleid      Util::UTIL_LIDMGR_CLEANUP
-             *   @reasoncode    Util::UTIL_LIDMGR_MM_FAIL
-             *   @userdata1[00:31]  LID ID
-             *   @userdata1[32:63]  rc from mm_remove_pages
-             *   @userdata2     Virtual address being removed
-             *   @devdesc       Error returned from mm_remove_pages
-             *                  when evicting lid from memory.
-             *   @custdesc      Firmware error during boot.
-             */
-            l_err = new ErrlEntry(ERRL_SEV_UNRECOVERABLE,
-                                  Util::UTIL_LIDMGR_CLEANUP,
-                                  Util::UTIL_LIDMGR_MM_FAIL,
-                                  TWO_UINT32_TO_UINT64(iv_lidId,rc),
-                                  iv_lidPnorInfo.vaddr,
-                                  true /*sw fail*/);
+            skip_remove_pages = true;
         }
+#endif
+
+        if (skip_remove_pages == false)
+        {
+            int rc = mm_remove_pages( RELEASE,
+                                      reinterpret_cast<void *>(
+                                        iv_lidPnorInfo.vaddr),
+                                      iv_lidPnorInfo.size );
+            if( rc )
+            {
+                UTIL_FT( ERR_MRK"rc=%d from mm_remove_pages(%llX,%llX)", iv_lidPnorInfo.vaddr, iv_lidPnorInfo.size );
+                /*@
+                 *   @errortype
+                 *   @moduleid      Util::UTIL_LIDMGR_CLEANUP
+                 *   @reasoncode    Util::UTIL_LIDMGR_MM_FAIL
+                 *   @userdata1[00:31]  LID ID
+                 *   @userdata1[32:63]  rc from mm_remove_pages
+                 *   @userdata2     Virtual address being removed
+                 *   @devdesc       Error returned from mm_remove_pages
+                 *                  when evicting lid from memory.
+                 *   @custdesc      Firmware error during boot.
+                 */
+                l_err = new ErrlEntry(ERRL_SEV_UNRECOVERABLE,
+                                      Util::UTIL_LIDMGR_CLEANUP,
+                                      Util::UTIL_LIDMGR_MM_FAIL,
+                                      TWO_UINT32_TO_UINT64(iv_lidId,rc),
+                                      iv_lidPnorInfo.vaddr,
+                                      true /*sw fail*/);
+            }
+        }
+
+#ifdef CONFIG_SECUREBOOT
+        // If in SECUREBOOT the lid could be securely signed in PNOR (like OCC)
+        // If so, unload it securely
+        // NOTE:  It is safe to unload it even if it was unloaded before
+        if (PNOR::isSecureSection(iv_lidPnorInfo.id))
+        {
+            l_err = PNOR::unloadSecureSection(iv_lidPnorInfo.id);
+
+            if (l_err)
+            {
+                UTIL_FT(ERR_MRK"UtilLidMgr::cleanup: Error from "
+                               "unloadSecureSection(PNOR::OCC): "
+                               "unloading module : %s (id=0x%X)",
+                               iv_lidFileName, iv_lidId);
+            }
+        }
+#endif
+
     }
 
 
diff --git a/src/usr/util/utillidpnor.C b/src/usr/util/utillidpnor.C
index bd178d8..e7644f2 100644
--- a/src/usr/util/utillidpnor.C
+++ b/src/usr/util/utillidpnor.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2014,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2014,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -26,6 +26,11 @@
 #include <util/utillidmgr.H>
 #include <utility>
 #include "utillidpnor.H"
+#include <config.h>
+#ifdef CONFIG_SECUREBOOT
+#include <pnor/pnorif.H>
+#include <errl/errlmanager.H>
+#endif
 
 bool UtilLidMgr::getLidPnorSection(uint32_t i_lidId,
                                    PNOR::SectionInfo_t &o_lidPnorInfo)
@@ -58,8 +63,36 @@ bool UtilLidMgr::getLidPnorSection(uint32_t i_lidId,
         else
         {
             l_lidInPnor = true;
+
+#ifdef CONFIG_SECUREBOOT
+#ifndef __HOSTBOOT_RUNTIME
+            // The lid could be securely signed in PNOR
+            if(PNOR::isSecureSection(l_result->second))
+            {
+                // Load the secure section
+                l_err = loadSecureSection(l_result->second);
+
+                // If secure section fails to load log the error and assert
+                if (l_err)
+                {
+                    errlCommit(l_err, UTIL_COMP_ID);
+                    assert(false,"UtilLidMgr::getLidPnorSection: attempt to "
+                                 "load Secure Section %d failed",
+                                 l_result->second);
+                }
+
+                // In Secureboot, rather than using the whole partition size,
+                // only use the protected payload size that the Secure PnorRP
+                // handles. This limits the memory footprint and prevents
+                // downstream logic from going past the end of the image.
+                // NOTE:  This assumes that any secure lid loaded from PNOR by
+                // UtilLidMgr does not contain an unprotected section
+                iv_lidPnorInfo.size = iv_lidPnorInfo.secureProtectedPayloadSize;
+            }
+#endif
+#endif
         }
     }
     return l_lidInPnor;
 
-}
\ No newline at end of file
+}
-- 
2.9.2


From 45cd600da55c75ceff3f3cc87174113d8a556859 Mon Sep 17 00:00:00 2001
From: Stephen Cprek <smcprek@us.ibm.com>
Date: Thu, 22 Sep 2016 16:54:12 -0500
Subject: [PATCH 17/20] Common handler for security validation failures

Change-Id: Ic81e427644d123d1bcad73dc68de76f61cede13b
RTC: 125309
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/30137
Reviewed-by: Michael Baiocchi <mbaiocch@us.ibm.com>
Reviewed-by: Nicholas E. Bofferding <bofferdn@us.ibm.com>
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Reviewed-by: William G. Hoffa <wghoffa@us.ibm.com>
---
 src/build/buildpnor/genPnorImages.pl         |  7 +--
 src/build/tools/hbDistribute                 |  1 +
 src/include/usr/errl/errlmanager.H           | 10 ++++
 src/include/usr/secureboot/service.H         | 10 +++-
 src/include/usr/vfs/vfs_reasoncodes.H        |  4 +-
 src/usr/errl/errlentry.C                     |  2 +-
 src/usr/errl/errlmanager.C                   |  4 +-
 src/usr/pnor/spnorrp.C                       | 78 +++++++++++++++-------------
 src/usr/secureboot/base/securerom.C          |  5 +-
 src/usr/secureboot/base/service.C            | 29 +++++++++++
 src/usr/secureboot/base/test/secureromtest.H | 21 ++++----
 src/usr/vfs/vfsrp.C                          | 38 ++++++++++----
 src/usr/vfs/vfsrp.H                          | 16 +++---
 13 files changed, 152 insertions(+), 73 deletions(-)

diff --git a/src/build/buildpnor/genPnorImages.pl b/src/build/buildpnor/genPnorImages.pl
index 6f892db..aa3bbc5 100755
--- a/src/build/buildpnor/genPnorImages.pl
+++ b/src/build/buildpnor/genPnorImages.pl
@@ -234,11 +234,11 @@ if ($secureboot)
         # and '/i' with a perl constant
         if ($value eq "" || $value =~ m/^${\(CORRUPT_PROTECTED)}/i)
         {
-            $partitionsToCorrupt{$key} = CORRUPT_PROTECTED
+            $partitionsToCorrupt{uc($key)} = CORRUPT_PROTECTED
         }
         elsif ($value =~ m/^${\(CORRUPT_UNPROTECTED)}/i)
         {
-            $partitionsToCorrupt{$key} = CORRUPT_UNPROTECTED;
+            $partitionsToCorrupt{uc($key)} = CORRUPT_UNPROTECTED;
         }
         else
         {
@@ -416,7 +416,7 @@ sub manipulateImages
                     {
                         trace(1,"Adding hash page table for $eyeCatch");
                         my $hashPageTableSize = -s $tempImages{hashPageTable};
-                        die "hashPageTable size undefined" unless(defined $hashPageTableSize);
+                        die "hashPageTable size undefined: errno = $!" unless(defined $hashPageTableSize);
                         # Move protected offset after hash page table.
                         $protectedOffset += $hashPageTableSize;
                         if ($eyeCatch eq "HBI")
@@ -623,6 +623,7 @@ sub manipulateImages
                     # Remove PAGE_SIZE bytes from generated dummy content of file
                     # to make room for the secure header
                     my $fileSize = (-s $tempImages{PAD_PHASE}) - PAGE_SIZE;
+                    die "fileSize undefined: errno = $!" unless(defined $fileSize);
                     run_command("dd if=$tempImages{PAD_PHASE} of=$tempImages{TEMP_BIN} count=1 bs=$fileSize");
                     # @TODO RTC:155374 Remove when official signing supported
                     run_command("$SIGNING_DIR/build -good -if $secureboot_hdr -of $tempImages{PAD_PHASE} -bin $tempImages{TEMP_BIN} $SIGN_BUILD_PARAMS");
diff --git a/src/build/tools/hbDistribute b/src/build/tools/hbDistribute
index 8e86d66..76fd85c 100755
--- a/src/build/tools/hbDistribute
+++ b/src/build/tools/hbDistribute
@@ -104,6 +104,7 @@ do
 
         "--key-transition")
             KEY_TRANSITION=1
+            shift
         ;;
 
         --*)
diff --git a/src/include/usr/errl/errlmanager.H b/src/include/usr/errl/errlmanager.H
index 1fbc7aa..33255e8 100644
--- a/src/include/usr/errl/errlmanager.H
+++ b/src/include/usr/errl/errlmanager.H
@@ -217,6 +217,15 @@ public:
      */
     static uint8_t iv_hiddenErrLogsEnable;
 
+    /**
+     * @brief   Determines if the target service is enabled or not.
+     * @return bool - true if enabled, false otherwise.
+     */
+    inline const bool isTargetServiceEnabled() const
+    {
+        return iv_isTargetServiceEnabled;
+    }
+
 protected:
     /**
      * @brief   Destructor
@@ -522,6 +531,7 @@ private:
     bool iv_isIpmiEnabled;      // are we able to send to BMC via IPMI
     bool iv_nonInfoCommitted;   // Keeps track of any non-informational logs.
     bool iv_isErrlDisplayEnabled; // are we able to use the errorDisplay
+    bool iv_isTargetServiceEnabled; // Indiciates if Target Service up or not
 
     // Errl flags which represent processing needed by the errl
     // represented as a bit field (8 bits)
diff --git a/src/include/usr/secureboot/service.H b/src/include/usr/secureboot/service.H
index d97893d..924de82 100644
--- a/src/include/usr/secureboot/service.H
+++ b/src/include/usr/secureboot/service.H
@@ -173,7 +173,15 @@ namespace SECUREBOOT
      *
      * @return void   - All error logs are handled internally in this function
      */
-    void secureSbeSeeproms( void ) ;
+    void secureSbeSeeproms( void );
+
+    /**
+     * @brief Common secureboot handler for secureboot failures.
+     *        Properly handles callouts etc.
+     *
+     * @return i_err   - Error log to cascade through failure path.
+     */
+    void handleSecurebootFailure(errlHndl_t &i_err);
 
 }
 
diff --git a/src/include/usr/vfs/vfs_reasoncodes.H b/src/include/usr/vfs/vfs_reasoncodes.H
index f2012b9..501fecc 100644
--- a/src/include/usr/vfs/vfs_reasoncodes.H
+++ b/src/include/usr/vfs/vfs_reasoncodes.H
@@ -37,6 +37,7 @@ namespace VFS
         VFS_WATCHER                 = 0x03,
         VFS_MODULE_LOAD_MONITOR     = 0x04,
         VFS_MODULE_EXEC_MONITOR     = 0x05,
+        VFS_VERIFY_PAGE             = 0x06,
     };
 
     enum VfsReasonCode
@@ -47,7 +48,8 @@ namespace VFS
         VFS_PERMS_VMEM_FAILED =     VFS_COMP_ID | 0x04,
         VFS_MODULE_DOES_NOT_EXIST = VFS_COMP_ID | 0x05,
         VFS_INVALID_DATA_MODULE   = VFS_COMP_ID | 0x06,
-        VFS_TASK_CRASHED          = VFS_COMP_ID | 0x07
+        VFS_TASK_CRASHED          = VFS_COMP_ID | 0x07,
+        VFS_PAGE_VERIFY_FAILED    = VFS_COMP_ID | 0x08
     };
 };
 
diff --git a/src/usr/errl/errlentry.C b/src/usr/errl/errlentry.C
index b6ef744..4fcbb62 100644
--- a/src/usr/errl/errlentry.C
+++ b/src/usr/errl/errlentry.C
@@ -845,7 +845,7 @@ void ErrlEntry::commit( compId_t  i_committerComponent )
 
     // Check to make sure targeting is initialized. If so, collect part and
     // serial numbers
-    if( TARGETING::targetService().isInitialized() )
+    if (ERRORLOG::theErrlManager::instance().isTargetServiceEnabled())
     {
         // If this error was a hardware callout, add the serial and part numbers
         // to the log. FSP provides this data so if there is no FSP, get them here.
diff --git a/src/usr/errl/errlmanager.C b/src/usr/errl/errlmanager.C
index defc1d2..2b971c0 100644
--- a/src/usr/errl/errlmanager.C
+++ b/src/usr/errl/errlmanager.C
@@ -125,7 +125,8 @@ ErrlManager::ErrlManager() :
     iv_isMboxEnabled(false),    // assume mbox isn't ready yet..
     iv_isIpmiEnabled(false),    // assume ipmi isn't ready yet..
     iv_nonInfoCommitted(false),
-    iv_isErrlDisplayEnabled(false)
+    iv_isErrlDisplayEnabled(false),
+    iv_isTargetServiceEnabled(false)
 {
     TRACFCOMP( g_trac_errl, ENTER_MRK "ErrlManager::ErrlManager constructor" );
 
@@ -262,6 +263,7 @@ void ErrlManager::errlogMsgHndlr ()
             case ERRLOG_ACCESS_TARG_TYPE:
                 {
                     // TARGETING is up and running now.
+                    iv_isTargetServiceEnabled = true;
 
                     //  do we NOT need to send the error?
                     TARGETING::Target * sys = NULL;
diff --git a/src/usr/pnor/spnorrp.C b/src/usr/pnor/spnorrp.C
index 8b9cb48..5019c14 100644
--- a/src/usr/pnor/spnorrp.C
+++ b/src/usr/pnor/spnorrp.C
@@ -136,6 +136,7 @@ errlHndl_t SPnorRP::allocBlock(msg_q_t i_mq, void* i_va, uint64_t i_size) const
             "with mm_alloc_block at address 0x%.16llX : rc=%d", i_va, rc );
         /*@
          * @errortype
+         * @severity     ERRL_SEV_CRITICAL_SYS_TERM
          * @moduleid     PNOR::MOD_SPNORRP_ALLOCATE_BLOCK
          * @reasoncode   PNOR::RC_EXTERNAL_ERROR
          * @userdata1    Requested Address
@@ -144,7 +145,7 @@ errlHndl_t SPnorRP::allocBlock(msg_q_t i_mq, void* i_va, uint64_t i_size) const
          * @custdesc     A problem occurred while initializing secure PNOR
          */
         l_errhdl = new ERRORLOG::ErrlEntry(
-                           ERRORLOG::ERRL_SEV_UNRECOVERABLE,
+                           ERRORLOG::ERRL_SEV_CRITICAL_SYS_TERM,
                            PNOR::MOD_SPNORRP_ALLOCATE_BLOCK,
                            PNOR::RC_EXTERNAL_ERROR,
                            TO_UINT64(reinterpret_cast<uint64_t>(i_va)),
@@ -171,6 +172,7 @@ errlHndl_t SPnorRP::setPermission(void* i_va, uint64_t i_size,
             "with mm_set_permission at address 0x%.16llX : rc=%d",i_va, rc );
         /*@
          * @errortype
+         * @severity      ERRL_SEV_CRITICAL_SYS_TERM
          * @moduleid      PNOR::MOD_SPNORRP_SET_PERMISSION
          * @reasoncode    PNOR::RC_EXTERNAL_ERROR
          * @userdata1     Requested Address
@@ -180,7 +182,7 @@ errlHndl_t SPnorRP::setPermission(void* i_va, uint64_t i_size,
          * @custdesc      A problem occurred while initializing secure PNOR
          */
         l_errhdl = new ERRORLOG::ErrlEntry(
-                            ERRORLOG::ERRL_SEV_UNRECOVERABLE,
+                            ERRORLOG::ERRL_SEV_CRITICAL_SYS_TERM,
                             PNOR::MOD_SPNORRP_SET_PERMISSION,
                             PNOR::RC_EXTERNAL_ERROR,
                             TO_UINT64(reinterpret_cast<uint64_t>(i_va)),
@@ -450,14 +452,17 @@ void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
     {
         uint32_t l_errPlid = l_errhdl->plid();
         iv_startupRC = l_errhdl->reasonCode();
-        errlCommit(l_errhdl,PNOR_COMP_ID);
-        TRACFCOMP(g_trac_pnor,"SPnorRP::verifySections there was an error");
-        if (failedVerify) {
-            // TODO RTC 125309
-            // Change failedVerify from doShutdown to something more clever.
-            TRACFCOMP(g_trac_pnor,"SPnorRP::verifySections failed verify");
+        TRACFCOMP(g_trac_pnor,ERR_MRK"SPnorRP::verifySections there was an error");
+        if (failedVerify)
+        {
+            TRACFCOMP(g_trac_pnor,ERR_MRK"SPnorRP::verifySections failed verify");
+            SECUREBOOT::handleSecurebootFailure(l_errhdl);
+        }
+        else
+        {
+            errlCommit(l_errhdl,PNOR_COMP_ID);
+            INITSERVICE::doShutdown(l_errPlid);
         }
-        INITSERVICE::doShutdown(l_errPlid);
     }
 }
 
@@ -598,11 +603,12 @@ void SPnorRP::waitForMessage()
                     break;
 
                 default:
-                    TRACDCOMP( g_trac_pnor, "SPnorRP::waitForMessage> "
+                    TRACFCOMP( g_trac_pnor, ERR_MRK"SPnorRP::waitForMessage> "
                     "Unrecognized message type : user_addr=%p, eff_addr=%p,"
                     " msgtype=%d", user_addr, eff_addr, message->type );
                     /*@
                      * @errortype
+                     * @severity     ERRL_SEV_CRITICAL_SYS_TERM
                      * @moduleid     PNOR::MOD_SPNORRP_WAITFORMESSAGE
                      * @reasoncode   PNOR::RC_INVALID_MESSAGE_TYPE
                      * @userdata1    Message type
@@ -613,7 +619,7 @@ void SPnorRP::waitForMessage()
                      *               the boot flash.
                      */
                     l_errhdl = new ERRORLOG::ErrlEntry(
-                                           ERRORLOG::ERRL_SEV_UNRECOVERABLE,
+                                           ERRORLOG::ERRL_SEV_CRITICAL_SYS_TERM,
                                            PNOR::MOD_SPNORRP_WAITFORMESSAGE,
                                            PNOR::RC_INVALID_MESSAGE_TYPE,
                                            TO_UINT64(message->type),
@@ -683,8 +689,10 @@ errlHndl_t PNOR::loadSecureSection(const SectionId i_section)
     //else remove the if clause below at some point
     if (rc != 0)
     {
-        /*
-         * @errortype
+
+        TRACFCOMP(g_trac_pnor,ERR_MRK"PNOR::loadSecureSection> Error from msg_sendrecv rc=%d",
+                  rc );
+        /* @errorlog
          * @severity          ERRL_SEV_CRITICAL_SYS_TERM
          * @moduleid          MOD_PNORRP_LOADSECURESECTION
          * @reasoncode        RC_EXTERNAL_ERROR
@@ -695,19 +703,15 @@ errlHndl_t PNOR::loadSecureSection(const SectionId i_section)
          * @custdesc          Security failure: unable to securely load
          *                    requested firmware.
          */
-
-        err = new ERRORLOG::ErrlEntry
-            (
-             ERRORLOG::ERRL_SEV_CRITICAL_SYS_TERM,   // severity
-             MOD_PNORRP_LOADSECURESECTION,           // moduleid
-             RC_EXTERNAL_ERROR,                      // reason Code
-             rc,                                     // user1 = msg_sendrecv rc
-             TWO_UINT32_TO_UINT64(
-               PNOR::MSG_LOAD_SECTION,               // user2 = message type
-               i_section                             //         and section Id
-             ),
-             true /* Add HB Software Callout */
-            );
+        err = new ERRORLOG::ErrlEntry(
+                         ERRORLOG::ERRL_SEV_CRITICAL_SYS_TERM,
+                         MOD_PNORRP_LOADSECURESECTION,
+                         RC_EXTERNAL_ERROR,
+                         rc,
+                         TWO_UINT32_TO_UINT64(PNOR::MSG_LOAD_SECTION,
+                                              i_section),
+                         true /* Add HB Software Callout */);
+        err->collectTrace(PNOR_COMP_NAME);
     }
     msg_free(msg);
     return err;
@@ -792,21 +796,25 @@ errlHndl_t SPnorRP::baseExtVersCheck(const uint8_t *i_vaddr) const
         TRACFBIN(g_trac_pnor,"SPnorRP::baseExtVersCheck HBI's hash page table salt entry",
                         l_hashPageTableSaltEntry, HASH_PAGE_TABLE_ENTRY_SIZE);
 
-        /*@
-         * @errortype
+        // Memcpy needed for measured hash to avoid gcc error: dereferencing
+        // type-punned pointer will break strict-aliasing rules
+        uint64_t l_measuredHash = 0;
+        memcpy(&l_measuredHash, l_hashSwSigs, sizeof(l_measuredHash));
+        /*@ errorlog
          * @severity        ERRL_SEV_CRITICAL_SYS_TERM
          * @moduleid        MOD_SPNORRP_BASE_EXT_VER_CHK
          * @reasoncode      RC_BASE_EXT_MISMATCH
-         * @userdata1       0
-         * @userdata2       0
+         * @userdata1       First 8 bytes of hash of measured SW signatures
+         * @userdata2       First 8 bytes of hash of stored SW signatures in
+         *                  hash page table
          * @devdesc         Hostboot Base and Extend code do not match versions.
          * @custdesc        Firmware level mismatch.
          */
-        l_errl = new ERRORLOG::ErrlEntry( ERRORLOG::ERRL_SEV_CRITICAL_SYS_TERM,
-                                          MOD_SPNORRP_BASE_EXT_VER_CHK,
-                                          RC_BASE_EXT_MISMATCH,
-                                          0,
-                                          0);
+        l_errl = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_CRITICAL_SYS_TERM,
+            MOD_SPNORRP_BASE_EXT_VER_CHK,
+            RC_BASE_EXT_MISMATCH,
+            l_measuredHash,
+            TO_UINT64(*reinterpret_cast<const uint64_t*>(l_hashPageTableSaltEntry)));
         l_errl->collectTrace(PNOR_COMP_NAME);
         l_errl->collectTrace(SECURE_COMP_NAME);
     }
diff --git a/src/usr/secureboot/base/securerom.C b/src/usr/secureboot/base/securerom.C
index ec86829..6091c4e 100644
--- a/src/usr/secureboot/base/securerom.C
+++ b/src/usr/secureboot/base/securerom.C
@@ -99,7 +99,6 @@ void getHwKeyHash(sha2_hash_t o_hash)
 
 }; //end SECUREBOOT namespace
 
-
 /********************
  Public Methods
  ********************/
@@ -409,9 +408,7 @@ errlHndl_t SecureROM::verifyContainer(void * i_container,
  */
 errlHndl_t SecureROM::hashBlob(const void * i_blob, size_t i_size, SHA512_t io_buf) const
 {
-
-    TRACDCOMP(g_trac_secure,INFO_MRK"SecureROM::hashBlob() NOT "
-              "supported, but not returning error log");
+    TRACDCOMP(g_trac_secure,ENTER_MRK"SecureROM::hashBlob()");
 
     errlHndl_t  l_errl      =   NULL;
 
diff --git a/src/usr/secureboot/base/service.C b/src/usr/secureboot/base/service.C
index 17c372f..aa51c2c 100644
--- a/src/usr/secureboot/base/service.C
+++ b/src/usr/secureboot/base/service.C
@@ -37,6 +37,9 @@
 #include <initservice/initserviceif.H>
 #include <secureboot/settings.H>
 #include <secureboot/header.H>
+#include <sys/misc.h>
+#include <kernel/console.H>
+#include <console/consoleif.H>
 
 #include "coreops.H"
 
@@ -268,4 +271,30 @@ bool getJumperState()
     return Singleton<Settings>::instance().getJumperState();
 }
 
+void handleSecurebootFailure(errlHndl_t &i_err)
+{
+    TRACFCOMP( g_trac_secure, ENTER_MRK"handleSecurebootFailure()");
+
+    assert(i_err != NULL, "Secureboot Failure has a NULL error log")
+
+    // Grab errlog reason code before committing.
+    uint16_t l_rc = i_err->reasonCode();
+
+#ifdef CONFIG_CONSOLE
+    CONSOLE::displayf(SECURE_COMP_NAME, "Secureboot Failure plid = 0x%08X, rc = 0x%04X\n",
+                      i_err->plid(), l_rc);
+    CONSOLE::flush();
+#endif
+    printk("Secureboot Failure plid = 0x%08X, rc = 0x%04X\n",
+           i_err->plid(),l_rc);
+
+    // Add Verification callout
+    i_err->addProcedureCallout(HWAS::EPUB_PRC_FW_VERIFICATION_ERR,
+                               HWAS::SRCI_PRIORITY_HIGH);
+    errlCommit(i_err, SECURE_COMP_ID);
+
+    // Shutdown with Secureboot error status
+    INITSERVICE::doShutdown(l_rc);
+}
+
 }  //namespace SECUREBOOT
diff --git a/src/usr/secureboot/base/test/secureromtest.H b/src/usr/secureboot/base/test/secureromtest.H
index 3e1760e..30892d2 100644
--- a/src/usr/secureboot/base/test/secureromtest.H
+++ b/src/usr/secureboot/base/test/secureromtest.H
@@ -320,14 +320,14 @@ class SecureROMTest : public CxxTest::TestSuite
         // Verify a page
         TRACUCOMP(g_trac_secure, "SecureROMTest::test_hash_page_table_verify vaddr = 0x%X, base offset = 0x%X, hash page table offset = 0x%X",
                   l_vaddr, l_baseOffset, l_hashPageTableOffset);
-        uint64_t l_rc = VFS::VfsRp::getInstance().verify_page(
-                                                    l_vaddr,
-                                                    l_baseOffset,
-                                                    l_hashPageTableOffset);
+        l_errl = VFS::VfsRp::getInstance().verify_page(l_vaddr,
+                                                       l_baseOffset,
+                                                       l_hashPageTableOffset);
         // Failed to pass secureboot verification
-        if(l_rc)
+        if (l_errl)
         {
             TS_FAIL("SecureROMTest::test_hash_page_table_verify failed");
+            errlCommit(l_errl, SECURE_COMP_ID);
             break;
         }
 
@@ -346,20 +346,21 @@ class SecureROMTest : public CxxTest::TestSuite
         // Corrupt page
         uint8_t l_corruptByte = 0xFF;
         memcpy(reinterpret_cast<uint8_t*>(l_pnorVaddr), &l_corruptByte, sizeof(uint8_t));
-        l_rc = VFS::VfsRp::getInstance().verify_page(
-                                        l_vaddr,
-                                        l_baseOffset,
-                                        l_hashPageTableOffset);
+        l_errl =  VFS::VfsRp::getInstance().verify_page(l_vaddr,
+                                                        l_baseOffset,
+                                                        l_hashPageTableOffset);
 
         // Fix page back up
         memcpy(reinterpret_cast<uint8_t*>(l_pnorVaddr), l_originPage, PAGESIZE);
 
         // Failed to catch secureboot verification failure
-        if(!l_rc)
+        if (!l_errl)
         {
             TS_FAIL("SecureROMTest::test_hash_page_table_verify did not catch verification error");
             break;
         }
+        delete l_errl;
+        l_errl = NULL;
 
         } while(0);
 
diff --git a/src/usr/vfs/vfsrp.C b/src/usr/vfs/vfsrp.C
index bea0bb7..468cc6c 100644
--- a/src/usr/vfs/vfsrp.C
+++ b/src/usr/vfs/vfsrp.C
@@ -44,7 +44,6 @@
 #include <errl/errlmanager.H>
 #include <secureboot/service.H>
 #include <secureboot/containerheader.H>
-#include <kernel/console.H>
 #include <config.h>
 
 using namespace VFS;
@@ -349,11 +348,14 @@ void VfsRp::msgHandler()
                         #ifdef CONFIG_SECUREBOOT
                         if (SECUREBOOT::enabled())
                         {
-                            uint64_t l_rc = verify_page(vaddr);
+                            errlHndl_t l_errl = verify_page(vaddr);
                             // Failed to pass secureboot verification
-                            if(l_rc)
+                            if(l_errl)
                             {
-                                msg->data[1] = -l_rc;
+                                SECUREBOOT::handleSecurebootFailure(l_errl);
+                                // The previous call will never return, but
+                                // just in case set proper kernel rc.
+                                msg->data[1] = -EACCES;
                                 break;
                             }
                         }
@@ -385,10 +387,10 @@ void VfsRp::msgHandler()
     } // while(1)
 }
 
-uint64_t VfsRp::verify_page(uint64_t i_vaddr, uint64_t i_baseOffset,
-                            uint64_t i_hashPageTableOffset) const
+errlHndl_t VfsRp::verify_page(uint64_t i_vaddr, uint64_t i_baseOffset,
+                              uint64_t i_hashPageTableOffset) const
 {
-    uint64_t rc = 0;
+    errlHndl_t l_errl = NULL;
     uint64_t l_pnorVaddr = iv_pnor_vaddr + i_vaddr;
 
     // Get current hash page table entry
@@ -427,11 +429,27 @@ uint64_t VfsRp::verify_page(uint64_t i_vaddr, uint64_t i_baseOffset,
         TRACFCOMP(g_trac_vfs, "ERROR:>VfsRp::verify_page secureboot verify fail on vaddr 0x%llX, offset into HBI 0x%llX",
                               i_vaddr,
                               i_vaddr+PAGE_SIZE+iv_payloadTextSize);
-        printk("Secureboot Verification Failure in HBI\n");
-        rc = EACCES;
+        /*@
+         * @severity        ERRL_SEV_CRITICAL_SYS_TERM
+         * @moduleid        VFS_VERIFY_PAGE
+         * @reasoncode      VFS_PAGE_VERIFY_FAILED
+         * @userdata1       Kernel RC
+         * @userdata2       virtual address accessed
+         *
+         * @devdesc         Secureboot page verify failure.
+         * @custdesc  Corrupted flash image or firmware error during system boot
+         */
+        l_errl = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_CRITICAL_SYS_TERM,
+                                         VFS_VERIFY_PAGE,
+                                         VFS_PAGE_VERIFY_FAILED,
+                                         TO_UINT64(EACCES),
+                                         i_vaddr,
+                                         true);
+        l_errl->collectTrace(VFS_COMP_NAME);
+        l_errl->collectTrace(PNOR_COMP_NAME);
     }
 
-    return rc;
+    return l_errl;
 }
 
 // ----------------------------------------------------------------------------
diff --git a/src/usr/vfs/vfsrp.H b/src/usr/vfs/vfsrp.H
index 197932b..39c2926 100644
--- a/src/usr/vfs/vfsrp.H
+++ b/src/usr/vfs/vfsrp.H
@@ -189,17 +189,19 @@ namespace VFS
              *
              * @param[in] i_vaddr address to verify
              * @param[in] i_baseOffset base offset within a PNOR section
-             *                         [Optional - Used by test cases]
+             *                         [Default 0 when called within VfsRP.
+             *                          Fill for test cases]
              * @param[in] i_hashPageTableOffset hash page table offset based on
              *                          iv_pnor_vaddr
-             *                         [Default to 0 when called within VfsRP,
-             *                          Filled in by test cases]
+             *                         [Default 0 when called within VfsRP to
+             *                          get internal hpt offset. Otherwise
+             *                          filled in by test cases]
              *
-             * @return return code on error
+             * @return errlog - error log to pass along shutdown path.
              */
-            uint64_t verify_page(uint64_t i_vaddr,
-                                 uint64_t i_baseOffset = 0,
-                                 uint64_t i_hashPageTableOffset = 0) const;
+            errlHndl_t verify_page(uint64_t i_vaddr,
+                                   uint64_t i_baseOffset = 0,
+                                   uint64_t i_hashPageTableOffset = 0) const;
 
             /**
              * @brief  Determines the hash page table index associated with a
-- 
2.9.2


From 6fc88ae76be22576e1d22165a565906e119689d7 Mon Sep 17 00:00:00 2001
From: Jaymes Wilks <mjwilks@us.ibm.com>
Date: Fri, 26 Aug 2016 10:48:37 -0500
Subject: [PATCH 18/20] Extend SLW Image

Extends the SLW Image to PCR allowing system administrators to
see the code level at which the system is running.

Change-Id: Ie9c4eb66ce050881589c0a5e5e0094bf248371aa
RTC:125300
---
 src/build/mkrules/hbfw/img/makefile                | 43 +++++++---------------
 .../hwp/build_winkle_images/build_winkle_images.C  | 27 +++++++++++++-
 src/usr/pnor/pnor_common.C                         |  3 +-
 3 files changed, 40 insertions(+), 33 deletions(-)

diff --git a/src/build/mkrules/hbfw/img/makefile b/src/build/mkrules/hbfw/img/makefile
index 4cc1762..e042206 100755
--- a/src/build/mkrules/hbfw/img/makefile
+++ b/src/build/mkrules/hbfw/img/makefile
@@ -210,15 +210,12 @@ VENICE_TARG_IMG = simics_VENICE_targeting.bin
 MURANO_TARG_FINAL_IMG = ${MURANO}.HBD.bin
 NAPLES_TARG_FINAL_IMG = ${NAPLES}.HBD.bin
 VENICE_TARG_FINAL_IMG = ${VENICE}.HBD.bin
-MURANO_SLW_IMG = ${ENGD_OBJPATH:Fs1.ref_image.hdr.bin}
-NAPLES_SLW_IMG = ${ENGD_OBJPATH:Fs1.ref_image.hdr.bin}
-VENICE_SLW_IMG = ${ENGD_OBJPATH:Fp8.ref_image.hdr.bin}
-MURANO_LOCAL_SLW_IMG = s1.ref_image.hdr.bin
-NAPLES_LOCAL_SLW_IMG = s1.ref_image.hdr.bin
-VENICE_LOCAL_SLW_IMG = p8.ref_image.hdr.bin
-MURANO_LOCAL_SLW_IMG_ECC = s1.ref_image.hdr.bin.ecc
-NAPLES_LOCAL_SLW_IMG_ECC = s1.ref_image.hdr.bin.ecc
-VENICE_LOCAL_SLW_IMG_ECC = p8.ref_image.hdr.bin.ecc
+MURANO_SLW_IMG = ${ENGD_OBJPATH:Fs1.ref_image.bin}
+NAPLES_SLW_IMG = ${ENGD_OBJPATH:Fs1.ref_image.bin}
+VENICE_SLW_IMG = ${ENGD_OBJPATH:Fp8.ref_image.bin}
+MURANO_SLW_FINAL_IMG = ${MURANO}.WINK.bin
+NAPLES_SLW_FINAL_IMG = ${NAPLES}.WINK.bin
+VENICE_SLW_FINAL_IMG = ${VENICE}.WINK.bin
 MURANO_SBE_IMG = s1SbePartition.bin
 NAPLES_SBE_IMG = s1SbePartition.bin
 VENICE_SBE_IMG = p8SbePartition.bin
@@ -227,25 +224,13 @@ NAPLES_SBE_FINAL_IMG = ${NAPLES}.SBE.bin
 VENICE_SBE_FINAL_IMG = ${VENICE}.SBE.bin
 SBEC_IMG = centSbePartition.bin
 SBEC_FINAL_IMG = SBEC.bin
-TEMP_IMG = temp.bin
 # Paramemters passed into GEN_PNOR_IMAGE_SCRIPT.
-GEN_MURANO_BIN_FILES = ${MURANO}:HBD=${${MURANO_TARG_IMG}:P},SBE=${${MURANO_SBE_IMG}:P}
-GEN_NAPLES_BIN_FILES = ${NAPLES}:HBD=${${NAPLES_TARG_IMG}:P},SBE=${${NAPLES_SBE_IMG}:P}
-GEN_VENICE_BIN_FILES = ${VENICE}:HBD=${${VENICE_TARG_IMG}:P},SBE=${${VENICE_SBE_IMG}:P}
+GEN_MURANO_BIN_FILES = ${MURANO}:HBD=${${MURANO_TARG_IMG}:P},SBE=${${MURANO_SBE_IMG}:P},WINK=${${MURANO_SLW_IMG}:P}
+GEN_NAPLES_BIN_FILES = ${NAPLES}:HBD=${${NAPLES_TARG_IMG}:P},SBE=${${NAPLES_SBE_IMG}:P},WINK=${${NAPLES_SLW_IMG}:P}
+GEN_VENICE_BIN_FILES = ${VENICE}:HBD=${${VENICE_TARG_IMG}:P},SBE=${${VENICE_SBE_IMG}:P},WINK=${${VENICE_SLW_IMG}:P}
 
 gen_system_specific_images: build_sbe_partitions
-	# cp file with full path to one with local path
-	cp ${MURANO_SLW_IMG} ${MURANO_LOCAL_SLW_IMG}
-	cp ${NAPLES_SLW_IMG} ${NAPLES_LOCAL_SLW_IMG}
-	cp ${VENICE_SLW_IMG} ${VENICE_LOCAL_SLW_IMG}
-	# SBE and SBECs partitions handled with genPnorImages below
-	# WINK partition
-	dd if=${${MURANO_LOCAL_SLW_IMG}:P} of=${TEMP_IMG} ibs=1024k conv=sync;
-	ecc --inject ${TEMP_IMG} --output ${MURANO_LOCAL_SLW_IMG_ECC} --p8;
-	dd if=${${NAPLES_LOCAL_SLW_IMG}:P} of=${TEMP_IMG} ibs=1024k conv=sync;
-	ecc --inject ${TEMP_IMG} --output ${NAPLES_LOCAL_SLW_IMG_ECC} --p8;
-	dd if=${${VENICE_LOCAL_SLW_IMG}:P} of=${TEMP_IMG} ibs=1024k conv=sync;
-	ecc --inject ${TEMP_IMG} --output ${VENICE_LOCAL_SLW_IMG_ECC} --p8;
+	# SBE and SBECs and WINK partitions handled with genPnorImages below
 	# Eventually use genPnorImages for every system specific image
 	${GEN_PNOR_IMAGE_SCRIPT} ${TARGET_TEST:b--test} ${CONFIG_SECUREBOOT:b--secureboot} \
 		--pnorLayout ${DEFAULT_PNOR_LAYOUT} ${CORRUPT_PARAMS} \
@@ -254,11 +239,9 @@ gen_system_specific_images: build_sbe_partitions
 		--systemBinFiles ${GEN_VENICE_BIN_FILES} \
 		--systemBinFile  SBEC=${${SBEC_IMG}:P}
 
-	rm ${TEMP_IMG}
-
-MURANO_SECT = HBD=${MURANO_TARG_FINAL_IMG},SBE=${MURANO_SBE_FINAL_IMG},SBEC=${SBEC_FINAL_IMG},WINK=${MURANO_LOCAL_SLW_IMG_ECC}
-NAPLES_SECT = HBD=${NAPLES_TARG_FINAL_IMG},SBE=${NAPLES_SBE_FINAL_IMG},SBEC=${SBEC_FINAL_IMG},WINK=${NAPLES_LOCAL_SLW_IMG_ECC}
-VENICE_SECT = HBD=${VENICE_TARG_FINAL_IMG},SBE=${VENICE_SBE_FINAL_IMG},SBEC=${SBEC_FINAL_IMG},WINK=${VENICE_LOCAL_SLW_IMG_ECC}
+MURANO_SECT = HBD=${MURANO_TARG_FINAL_IMG},SBE=${MURANO_SBE_FINAL_IMG},SBEC=${SBEC_FINAL_IMG},WINK=${MURANO_SLW_FINAL_IMG}
+NAPLES_SECT = HBD=${NAPLES_TARG_FINAL_IMG},SBE=${NAPLES_SBE_FINAL_IMG},SBEC=${SBEC_FINAL_IMG},WINK=${NAPLES_SLW_FINAL_IMG}
+VENICE_SECT = HBD=${VENICE_TARG_FINAL_IMG},SBE=${VENICE_SBE_FINAL_IMG},SBEC=${SBEC_FINAL_IMG},WINK=${VENICE_SLW_FINAL_IMG}
 
 PNOR_IMG_INFO = \
    murano.pnor:defaultPnorLayout.xml:${MURANO_SECT},${HOSTBOOT_DEFAULT_SECTIONS} \
diff --git a/src/usr/hwpf/hwp/build_winkle_images/build_winkle_images.C b/src/usr/hwpf/hwp/build_winkle_images/build_winkle_images.C
index a32a84a..f8a451d 100644
--- a/src/usr/hwpf/hwp/build_winkle_images/build_winkle_images.C
+++ b/src/usr/hwpf/hwp/build_winkle_images/build_winkle_images.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2012,2014                        */
+/* Contributors Listed Below - COPYRIGHT 2012,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -58,6 +58,7 @@
 #include    <targeting/namedtarget.H>
 
 #include <pnor/pnorif.H>
+#include <config.h>
 
 //  fapi support
 #include    <fapi.H>
@@ -81,7 +82,6 @@
 #include    <runtime/runtime.H>
 #include    "p8_slw_build/p8_image_help_base.H"
 
-
 namespace   BUILD_WINKLE_IMAGES
 {
 
@@ -403,6 +403,9 @@ void*    call_host_build_winkle( void    *io_pArgs )
     uint32_t    l_poreSize      =   0;
     void        *l_pRealMemBase = NULL;
     void* l_pVirtMemBase        = NULL;
+    #ifdef CONFIG_SECUREBOOT
+    bool l_secureSectionLoaded = false;
+    #endif
 
     ISTEP_ERROR::IStepError     l_StepError;
 
@@ -454,6 +457,14 @@ void*    call_host_build_winkle( void    *io_pArgs )
 
         //  Continue, build SLW images
 
+        #ifdef CONFIG_SECUREBOOT
+        l_errl = loadSecureSection(PNOR::WINK);
+        if(l_errl)
+        {
+            break;
+        }
+        l_secureSectionLoaded = true;
+        #endif
 
         //Load the reference image from PNOR
         l_errl  =   loadPoreImage(  l_pPoreImage,
@@ -609,6 +620,18 @@ void*    call_host_build_winkle( void    *io_pArgs )
         errlCommit( l_errl, HWPF_COMP_ID );
     }
 
+    #ifdef CONFIG_SECUREBOOT
+    if (l_secureSectionLoaded)
+    {
+        l_errl = unloadSecureSection(PNOR::WINK);
+        if(l_errl)
+        {
+            l_StepError.addErrorDetails( l_errl );
+            errlCommit( l_errl, HWPF_COMP_ID );
+        }
+    }
+    #endif
+
     // delete working buffers
     if( l_rs4_tmp ) { free(l_rs4_tmp); }
     if( l_wf_tmp ) { free(l_wf_tmp); }
diff --git a/src/usr/pnor/pnor_common.C b/src/usr/pnor/pnor_common.C
index cd1acf1..24f86c6 100644
--- a/src/usr/pnor/pnor_common.C
+++ b/src/usr/pnor/pnor_common.C
@@ -627,7 +627,8 @@ bool PNOR::isSecureSection(const uint32_t i_section)
            i_section == CENTAUR_SBE ||
            i_section == PAYLOAD ||
            i_section == SBKT ||
-           i_section == OCC;
+           i_section == OCC ||
+           i_section == WINK;
 #else
     return false;
 #endif
-- 
2.9.2


From ceae65c39a80cd879d08d2f8fa36a3810a9bce24 Mon Sep 17 00:00:00 2001
From: Jaymes Wilks <mjwilks@us.ibm.com>
Date: Tue, 30 Aug 2016 10:06:13 -0500
Subject: [PATCH 19/20] Extend HBRT Image

Extends the HBRT Image to PCR allowing system administrators to
see the code level at which the system is running.

Change-Id: Iaa14ae4c4de28cea4a44548f10f1e5eb217a4fee
RTC:157234
---
 src/build/buildpnor/genPnorImages.pl |  3 ++-
 src/build/mkrules/hbfw/img/makefile  | 31 +++++++++++--------------------
 src/usr/devtree/bld_devtree.C        | 24 +++++++++++++++++++++++-
 src/usr/pnor/pnor_common.C           |  3 ++-
 src/usr/pnor/spnorrp.C               |  6 ++++--
 src/usr/testcore/rtloader/loader.H   | 20 ++++++++++++++++++--
 6 files changed, 60 insertions(+), 27 deletions(-)

diff --git a/src/build/buildpnor/genPnorImages.pl b/src/build/buildpnor/genPnorImages.pl
index aa3bbc5..2149a6c 100755
--- a/src/build/buildpnor/genPnorImages.pl
+++ b/src/build/buildpnor/genPnorImages.pl
@@ -362,7 +362,8 @@ sub manipulateImages
                              || ($eyeCatch eq "SBEC")
                              || ($eyeCatch eq "PAYLOAD")
                              || ($eyeCatch eq "SBKT")
-                             || ($eyeCatch eq "OCC");
+                             || ($eyeCatch eq "OCC")
+                             || ($eyeCatch eq "HBRT");
 
         my $isSpecialSecure =    ($eyeCatch eq "HBB")
                               || ($eyeCatch eq "HBI")
diff --git a/src/build/mkrules/hbfw/img/makefile b/src/build/mkrules/hbfw/img/makefile
index e042206..7e1b7bb 100755
--- a/src/build/mkrules/hbfw/img/makefile
+++ b/src/build/mkrules/hbfw/img/makefile
@@ -57,11 +57,12 @@ BASE_FINAL_IMAGE = HBB.bin
 EXT_IMAGE =  hostboot_extended.bin
 EXT_FINAL_IMAGE = HBI.bin
 HBRT_IMAGE = hostboot_runtime.bin
-HBRT_SHA_IMAGE = hostboot_runtime.sha.bin
-HBRT_HEADER_IMAGE = hostboot_runtime.header.bin
-HBRT_ECC_HEADER_IMAGE = hostboot_runtime.header.bin.ecc
+HBRT_FINAL_IMAGE = HBRT.bin
 BASE_IMAGES = ${BASE_IMAGE} ${EXT_IMAGE} ${HBRT_IMAGE}
-TEMP_IMAGE = hostboot.temp.bin
+BASE_W_HEADER_IMAGE = hostboot.header.bin
+BASE_W_HEADER_ECC_IMAGE = hostboot.header.bin.ecc
+BASE_ECC_IMAGE = hostboot.bin.ecc
+BASE_SHA_IMAGE = hostboot.sha.bin
 # Zero filled sections final bin names
 TEST_IMAGE = TEST.bin
 TESTRO_IMAGE = TESTRO.bin
@@ -76,9 +77,9 @@ SBKT_IMAGE = SBKT.bin
 ZERO_FILL_IMAGES = ${TEST_IMAGE} ${TESTRO_IMAGE} ${HBEL_IMAGE} ${GUARD_IMAGE} \
                    ${GLOBAL_IMAGE} ${DJVPD_IMAGE} ${MVPD_IMAGE} ${CVPD_IMAGE} \
                    ${PAYLOAD_IMAGE} ${SBKT_IMAGE}
-ALL_HB_IMAGES = ${BASE_IMAGES} ${HBRT_SHA_IMAGE} ${HBRT_HEADER_IMAGE} \
-                ${HBRT_ECC_HEADER_IMAGE} ${EXT_FINAL_IMAGE} \
-                ${BASE_FINAL_IMAGE} ${ZERO_FILL_IMAGES}
+ALL_HB_IMAGES = ${BASE_IMAGES} ${BASE_W_HEADER_IMAGE} ${BASE_ECC_IMAGE}\
+                ${BASE_W_HEADER_ECC_IMAGE} ${BASE_SHA_IMAGE} ${HBRT_FINAL_IMAGE} \
+                ${EXT_FINAL_IMAGE} ${BASE_FINAL_IMAGE} ${ZERO_FILL_IMAGES}
 
 # Script to manipulate bin files to prepare for buildpnor (install_all phase)
 GEN_PNOR_IMAGE_SCRIPT = ${genPnorImages.pl:P}
@@ -87,7 +88,7 @@ GEN_PNOR_IMAGE_SCRIPT = ${genPnorImages.pl:P}
 # them, rather than use an input.
 # Note: HBI depends on HBB for sw signatures. Ensure that both are passed into
 #       the same --systemBinFiles parameter for genPnorImages
-GEN_DEFAULT_BIN_FILES = HBB=${BASE_IMAGE},HBI=${EXT_IMAGE},TEST=EMPTY,TESTRO=EMPTY,HBEL=EMPTY,GUARD=EMPTY,GLOBAL=EMPTY,PAYLOAD=EMPTY,CVPD=EMPTY,MVPD=EMPTY,DJVPD=EMPTY,SBKT=EMPTY
+GEN_DEFAULT_BIN_FILES = HBB=${BASE_IMAGE},HBI=${EXT_IMAGE},HBRT=${HBRT_IMAGE},TEST=EMPTY,TESTRO=EMPTY,HBEL=EMPTY,GUARD=EMPTY,GLOBAL=EMPTY,PAYLOAD=EMPTY,CVPD=EMPTY,MVPD=EMPTY,DJVPD=EMPTY,SBKT=EMPTY
 DEFAULT_PNOR_LAYOUT = ${defaultPnorLayout.xml:P}
 
 ################################################################################
@@ -100,21 +101,11 @@ cp_hbfiles: .SPECTARG
 gen_default_images: cp_hbfiles
 	currentsb -chain
 	ecc --inject ${BASE_IMAGE} --output ${BASE_ECC_IMAGE} --p8
-	# Add version header w/ HBRT sha hash
-	echo -en VERSION\\0 > ${HBRT_SHA_IMAGE}
-	sha512sum ${HBRT_IMAGE} | awk '{print $$1}' | xxd -pr -r >> ${HBRT_SHA_IMAGE}
-	dd if=${HBRT_SHA_IMAGE} of=${TEMP_IMAGE} ibs=4k conv=sync
-	cat ${HBRT_IMAGE} >> ${TEMP_IMAGE}
-	# HBRT partition
-	dd if=${TEMP_IMAGE} of=${HBRT_HEADER_IMAGE} ibs=3072K conv=sync
-	ecc --inject ${HBRT_HEADER_IMAGE} --output ${HBRT_ECC_HEADER_IMAGE} --p8
 	# Eventually use genPnorImages for every default image
 	# HBI + HBB partitions and ZERO_FILL_IMAGES
 	${GEN_PNOR_IMAGE_SCRIPT} --build-all ${TARGET_TEST:b--test} \
 		${CONFIG_SECUREBOOT:b--secureboot} --systemBinFiles ${GEN_DEFAULT_BIN_FILES} \
-		--pnorLayout ${DEFAULT_PNOR_LAYOUT} ${KEY_TRANSITION:b--key-transition} \
-		${CORRUPT_PARAMS}
-	rm ${TEMP_IMAGE}
+		--pnorLayout ${DEFAULT_PNOR_LAYOUT} ${KEY_TRANSITION:b--key-transition}
 
 clobber_gen_default_images:
 	rm -f ${ALL_HB_IMAGES} \
@@ -196,7 +187,7 @@ GEN_FAKE_HEADER_SCRIPT = ${genfakeheader.pl:P}
 .tryinclude <${.PATH:Ffips_pnor.mk}>
 
 ZERO_FILL_SECTIONS = TEST=${TEST_IMAGE},TESTRO=${TESTRO_IMAGE},HBEL=${HBEL_IMAGE},GUARD=${GUARD_IMAGE},GLOBAL=${GLOBAL_IMAGE},PAYLOAD=${PAYLOAD_IMAGE},CVPD=${CVPD_IMAGE},MVPD=${MVPD_IMAGE},DJVPD=${DJVPD_IMAGE},SBKT=${SBKT_IMAGE}
-HOSTBOOT_DEFAULT_SECTIONS = HBB=${BASE_FINAL_IMAGE},HBI=${EXT_FINAL_IMAGE},HBRT=${HBRT_ECC_HEADER_IMAGE},${ZERO_FILL_SECTIONS}
+HOSTBOOT_DEFAULT_SECTIONS = HBB=${BASE_FINAL_IMAGE},HBI=${EXT_FINAL_IMAGE},HBRT=${HBRT_FINAL_IMAGE},${ZERO_FILL_SECTIONS}
 
 HBFW_OBJPATH = ${.PATH:M*obj*}
 ENGD_OBJPATH = ${HBFW_OBJPATH:S/hbfw\/img/engd\/href/g}
diff --git a/src/usr/devtree/bld_devtree.C b/src/usr/devtree/bld_devtree.C
index cbed3dd..227599e 100644
--- a/src/usr/devtree/bld_devtree.C
+++ b/src/usr/devtree/bld_devtree.C
@@ -58,7 +58,7 @@
 #include <vpd/mvpdenums.H>
 #include <vpd/cvpdenums.H>
 #include <vpd/spdenums.H>
-
+#include <config.h>
 
 trace_desc_t *g_trac_devtree = NULL;
 TRAC_INIT(&g_trac_devtree, "DEVTREE", 4096);
@@ -1481,9 +1481,20 @@ void add_reserved_mem(devTree * i_dt,
 void load_hbrt_image(uint64_t& io_address)
 {
     errlHndl_t l_errl = NULL;
+    #ifdef CONFIG_SECUREBOOT
+    bool l_secureSectionLoaded = false;
+    #endif
 
     do
     {
+        #ifdef CONFIG_SECUREBOOT
+        l_errl = loadSecureSection(PNOR::HB_RUNTIME);
+        if(l_errl)
+        {
+            break;
+        }
+        l_secureSectionLoaded = true;
+        #endif
 
         PNOR::SectionInfo_t l_pnorInfo;
         l_errl = getSectionInfo( PNOR::HB_RUNTIME , l_pnorInfo);
@@ -1525,6 +1536,17 @@ void load_hbrt_image(uint64_t& io_address)
         io_address = 0;
         errlCommit(l_errl, DEVTREE_COMP_ID);
     }
+
+    #ifdef CONFIG_SECUREBOOT
+    if (l_secureSectionLoaded)
+    {
+        l_errl = unloadSecureSection(PNOR::HB_RUNTIME);
+        if(l_errl)
+        {
+            errlCommit(l_errl, DEVTREE_COMP_ID);
+        }
+    }
+    #endif
 }
 
 void load_tpmlog(devTree * i_dt, uint64_t& io_address)
diff --git a/src/usr/pnor/pnor_common.C b/src/usr/pnor/pnor_common.C
index 24f86c6..bc745df 100644
--- a/src/usr/pnor/pnor_common.C
+++ b/src/usr/pnor/pnor_common.C
@@ -628,7 +628,8 @@ bool PNOR::isSecureSection(const uint32_t i_section)
            i_section == PAYLOAD ||
            i_section == SBKT ||
            i_section == OCC ||
-           i_section == WINK;
+           i_section == WINK ||
+           i_section == HB_RUNTIME;
 #else
     return false;
 #endif
diff --git a/src/usr/pnor/spnorrp.C b/src/usr/pnor/spnorrp.C
index 5019c14..2da74cb 100644
--- a/src/usr/pnor/spnorrp.C
+++ b/src/usr/pnor/spnorrp.C
@@ -277,8 +277,8 @@ void SPnorRP::verifySections(LoadRecord* o_rec, SectionId i_id)
 
             break;
         }
-        TRACDCOMP(g_trac_pnor,"SPnorRP::verifySections getSectionInfo succeeded for sec = %s",
-                  l_info.name);
+        TRACDCOMP(g_trac_pnor,"SPnorRP::verifySections getSectionInfo"
+                " succeeded for sec = %s", l_info.name);
 
         l_info.vaddr -= PAGESIZE; // back up a page to expose the secure header
         l_info.size += PAGESIZE; // add a page to size to account for the header
@@ -679,6 +679,8 @@ errlHndl_t PNOR::loadSecureSection(const SectionId i_section)
     msg->data[0] = static_cast<uint64_t>(i_section);
     int rc = msg_sendrecv(spnorQ, msg);
 
+    TRACFCOMP(g_trac_pnor, "loadSecureSection i_section = %i",i_section);
+
     // TODO RTC 156118 - Need to be able to receive an error from the
     // message handler. Also, message handler should police whether the request
     // is for a secure section or not and throw an error accordingly.
diff --git a/src/usr/testcore/rtloader/loader.H b/src/usr/testcore/rtloader/loader.H
index 4b3e140..53a0c0f 100644
--- a/src/usr/testcore/rtloader/loader.H
+++ b/src/usr/testcore/rtloader/loader.H
@@ -42,6 +42,7 @@
 #include <devicefw/userif.H>
 #include <pnor/ecc.H>
 #include <ipmi/ipmiif.H>
+#include <config.h>
 trace_desc_t* g_trac_hbrt = NULL;
 TRAC_INIT(&g_trac_hbrt, "HBRT_TEST", 2*KILOBYTE);
 
@@ -53,11 +54,26 @@ class RuntimeLoaderTest : public CxxTest::TestSuite
         void testLoader()
         {
             static const uint64_t HEADER_OFFSET = 0x2000;
+            errlHndl_t l_errl = NULL;
+
+            #ifdef CONFIG_SECUREBOOT
+            // load secure section
+            // TODO RTC: 157475 Since this is a test case and unload is
+            // merely a stub function at this point in time, add a call
+            // to unload later when the aforementioned story is implemented.
+            l_errl = loadSecureSection(PNOR::HB_RUNTIME);
+            if(l_errl)
+            {
+                TS_WARN("Could not securely load runtime section.");
+                delete l_errl;
+                return;
+            }
+            #endif
+
 
             PNOR::SectionInfo_t runtimeSection;
 
-            errlHndl_t l_errl =
-                PNOR::getSectionInfo(PNOR::HB_RUNTIME, runtimeSection);
+            l_errl = PNOR::getSectionInfo(PNOR::HB_RUNTIME, runtimeSection);
 
             if (l_errl)
             {
-- 
2.9.2


From 779aa1642d325587e9f19ef9f45ab1ff6144b6df Mon Sep 17 00:00:00 2001
From: Stephen Cprek <smcprek@us.ibm.com>
Date: Thu, 29 Sep 2016 15:46:06 -0500
Subject: [PATCH 20/20] OpenPOWER support for signing key transition partition

Change-Id: Id11b7568dfc49142a0d9aa3ea34ae0650d4bc93a
RTC: 157351
---
 src/build/buildpnor/genPnorImages.pl | 36 ++++++++++++++++++++++++++++++------
 1 file changed, 30 insertions(+), 6 deletions(-)

diff --git a/src/build/buildpnor/genPnorImages.pl b/src/build/buildpnor/genPnorImages.pl
index 2149a6c..214fb54 100755
--- a/src/build/buildpnor/genPnorImages.pl
+++ b/src/build/buildpnor/genPnorImages.pl
@@ -214,6 +214,12 @@ my $OPEN_SIGN_REQUEST="$SIGNING_DIR/crtSignedContainer.pl -v "
     . "-hwPrivKeyC $DEV_KEY_DIR/hw_key_c.key "
     . "-swPrivKeyP $DEV_KEY_DIR/sw_key_a.key ";
 
+my $OPEN_SIGN_KEY_TRANS_REQUEST="$SIGNING_DIR/crtSignedContainer.pl -v "
+    . "-hwPrivKeyA $DEV_KEY_DIR/hw_key_c.key "
+    . "-hwPrivKeyB $DEV_KEY_DIR/hw_key_b.key "
+    . "-hwPrivKeyC $DEV_KEY_DIR/hw_key_a.key "
+    . "-swPrivKeyP $DEV_KEY_DIR/sw_key_a.key ";
+
 if ($secureboot)
 {
     # Check all components needed for developer signing
@@ -609,7 +615,8 @@ sub manipulateImages
             elsif ($eyeCatch eq "SBKT" && $secureboot && $key_transition)
             {
                 $callerHwHdrFields{configure} = 1;
-                create_sb_key_transition_container($tempImages{PAD_PHASE});
+                create_sb_key_transition_container($openSigningFlags,
+                                                   $tempImages{PAD_PHASE});
                 setCallerHwHdrFields(\%callerHwHdrFields, $tempImages{PAD_PHASE});
             }
             # Other partitions fill with FF's if no empty bin file provided
@@ -888,7 +895,7 @@ sub gen_test_containers
 ################################################################################
 sub create_sb_key_transition_container
 {
-    my ($o_file) = @_;
+    my ($i_opSigningFlags, $o_file) = @_;
 
     my $randPrefix = "rand-".POSIX::ceil(rand(0xFFFFFFFF));
     my %tempImages = (
@@ -899,11 +906,28 @@ sub create_sb_key_transition_container
     # Gen 4K blob of random data
     run_command("dd if=/dev/urandom of=$tempImages{RAND_BLOB} count=1 bs=4k");
 
-    # Create a signed container with new production keys
-    run_command("$SIGNING_DIR/build -good -if $sb_hdrs{SBKT}{file} -of $tempImages{PRD_KEY_FILE} -bin $tempImages{RAND_BLOB} $SIGN_BUILD_PARAMS");
+    if($openSigningTool)
+    {
+        # Create a signed container with new production keys
+        run_command("$OPEN_SIGN_KEY_TRANS_REQUEST "
+            . "$i_opSigningFlags "
+            . "-protectedPayload $tempImages{RAND_BLOB} "
+            . "-out $tempImages{PRD_KEY_FILE}");
+        # Sign new production key container with imprint keys
+        run_command("$OPEN_SIGN_REQUEST "
+            . "$i_opSigningFlags "
+            . "-protectedPayload $tempImages{PRD_KEY_FILE} "
+            . "-out $o_file");
+    }
+    else
+    {
+        # Create a signed container with new production keys
+        run_command("$SIGNING_DIR/build -good -if $sb_hdrs{SBKT}{file} -of $tempImages{PRD_KEY_FILE} -bin $tempImages{RAND_BLOB} $SIGN_BUILD_PARAMS");
+        # Sign new production key container with imprint keys
+        run_command("$SIGNING_DIR/build -good -if $sb_hdrs{HB_FW}{file} -of $o_file -bin $tempImages{PRD_KEY_FILE} $SIGN_BUILD_PARAMS");
+    }
+
 
-    # Sign new production key container with imprint keys
-    run_command("$SIGNING_DIR/build -good -if $sb_hdrs{HB_FW}{file} -of $o_file -bin $tempImages{PRD_KEY_FILE} $SIGN_BUILD_PARAMS");
 
     # Clean up temp images
     foreach my $image (keys %tempImages)
-- 
2.9.2

